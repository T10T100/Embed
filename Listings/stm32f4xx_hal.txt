; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--cpp --list --debug -c --asm --interleave -o.\objects\stm32f4xx_hal.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_hal.d --cpu=Cortex-M4.fp --apcs=interwork -O1 -Otime --diag_suppress=9931 -I.\device\GUI\inc -I.\device\hardware\inc -I.\device\init\inc -I.\misc\inc -I.\user\inc -I..\tester_1.03 -I.\memory\inc -I.\drivers\inc -ID:\myKeil\tester_1.03\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.4.0 -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.4.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=514 -D_RTE_ -DSTM32F417xx -DSTM32F417xx -DColorDepthBpp16 -Dtftili9486 -DSOFTWARE_GL -DGUI_ALLIGN_LAYSIZE_TO_POW2 --omf_browse=.\objects\stm32f4xx_hal.crf drivers\src\stm32f4xx_hal.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  HAL_MspInit PROC
;;;228      */
;;;229    __weak void HAL_MspInit(void)
000000  4770              BX       lr
;;;230    {
;;;231      /* NOTE : This function Should not be modified, when the callback is needed,
;;;232                the HAL_MspInit could be implemented in the user file
;;;233       */
;;;234    }
;;;235    
                          ENDP

                  HAL_InitTick PROC
;;;262      */
;;;263    __weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
000002  b510              PUSH     {r4,lr}
;;;264    {
000004  4604              MOV      r4,r0
;;;265      /*Configure the SysTick to have interrupt in 1ms time basis*/
;;;266      HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
000006  f7fffffe          BL       HAL_RCC_GetHCLKFreq
00000a  f44f727a          MOV      r2,#0x3e8
00000e  fbb0f0f2          UDIV     r0,r0,r2
000012  f7fffffe          BL       HAL_SYSTICK_Config
;;;267    
;;;268      /*Configure the SysTick IRQ priority */
;;;269      HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
000016  2200              MOVS     r2,#0
000018  4621              MOV      r1,r4
00001a  1e50              SUBS     r0,r2,#1
00001c  f7fffffe          BL       HAL_NVIC_SetPriority
;;;270    
;;;271      /* Return function status */
;;;272      return HAL_OK;
000020  2000              MOVS     r0,#0
;;;273    }
000022  bd10              POP      {r4,pc}
;;;274    
                          ENDP

                  HAL_Init PROC
;;;166      */
;;;167    HAL_StatusTypeDef HAL_Init(void)
000024  b510              PUSH     {r4,lr}
;;;168    {
;;;169      /* Configure Flash prefetch, Instruction cache, Data cache */ 
;;;170    #if (INSTRUCTION_CACHE_ENABLE != 0)
;;;171       __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
000026  484b              LDR      r0,|L1.340|
000028  6801              LDR      r1,[r0,#0]
00002a  f4417100          ORR      r1,r1,#0x200
00002e  6001              STR      r1,[r0,#0]
;;;172    #endif /* INSTRUCTION_CACHE_ENABLE */
;;;173    
;;;174    #if (DATA_CACHE_ENABLE != 0)
;;;175       __HAL_FLASH_DATA_CACHE_ENABLE();
000030  6801              LDR      r1,[r0,#0]
000032  f4416180          ORR      r1,r1,#0x400
000036  6001              STR      r1,[r0,#0]
;;;176    #endif /* DATA_CACHE_ENABLE */
;;;177    
;;;178    #if (PREFETCH_ENABLE != 0)
;;;179      __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
;;;180    #endif /* PREFETCH_ENABLE */
;;;181    
;;;182      /* Set Interrupt Group Priority */
;;;183      HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
000038  2003              MOVS     r0,#3
00003a  f7fffffe          BL       HAL_NVIC_SetPriorityGrouping
;;;184    
;;;185      /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
;;;186      HAL_InitTick(TICK_INT_PRIORITY);
00003e  200f              MOVS     r0,#0xf
000040  f7fffffe          BL       HAL_InitTick
;;;187      
;;;188      /* Init the low level hardware */
;;;189      HAL_MspInit();
000044  f7fffffe          BL       HAL_MspInit
;;;190      
;;;191      /* Return function status */
;;;192      return HAL_OK;
000048  2000              MOVS     r0,#0
;;;193    }
00004a  bd10              POP      {r4,pc}
;;;194    
                          ENDP

                  HAL_MspDeInit PROC
;;;239      */
;;;240    __weak void HAL_MspDeInit(void)
00004c  4770              BX       lr
;;;241    {
;;;242      /* NOTE : This function Should not be modified, when the callback is needed,
;;;243                the HAL_MspDeInit could be implemented in the user file
;;;244       */ 
;;;245    }
;;;246    
                          ENDP

                  HAL_DeInit PROC
;;;199      */
;;;200    HAL_StatusTypeDef HAL_DeInit(void)
00004e  b510              PUSH     {r4,lr}
;;;201    {
;;;202      /* Reset of all peripherals */
;;;203      __HAL_RCC_APB1_FORCE_RESET();
000050  4a41              LDR      r2,|L1.344|
000052  f04f30ff          MOV      r0,#0xffffffff
000056  6010              STR      r0,[r2,#0]
;;;204      __HAL_RCC_APB1_RELEASE_RESET();
000058  2100              MOVS     r1,#0
00005a  6011              STR      r1,[r2,#0]
;;;205    
;;;206      __HAL_RCC_APB2_FORCE_RESET();
00005c  1d12              ADDS     r2,r2,#4
00005e  6010              STR      r0,[r2,#0]
;;;207      __HAL_RCC_APB2_RELEASE_RESET();
000060  6011              STR      r1,[r2,#0]
;;;208    
;;;209      __HAL_RCC_AHB1_FORCE_RESET();
000062  4a3e              LDR      r2,|L1.348|
000064  6010              STR      r0,[r2,#0]
;;;210      __HAL_RCC_AHB1_RELEASE_RESET();
000066  6011              STR      r1,[r2,#0]
;;;211    
;;;212      __HAL_RCC_AHB2_FORCE_RESET();
000068  1d12              ADDS     r2,r2,#4
00006a  6010              STR      r0,[r2,#0]
;;;213      __HAL_RCC_AHB2_RELEASE_RESET();
00006c  6011              STR      r1,[r2,#0]
;;;214    
;;;215      __HAL_RCC_AHB3_FORCE_RESET();
00006e  1d12              ADDS     r2,r2,#4
000070  6010              STR      r0,[r2,#0]
;;;216      __HAL_RCC_AHB3_RELEASE_RESET();
000072  6011              STR      r1,[r2,#0]
;;;217    
;;;218      /* De-Init the low level hardware */
;;;219      HAL_MspDeInit();
000074  f7fffffe          BL       HAL_MspDeInit
;;;220        
;;;221      /* Return function status */
;;;222      return HAL_OK;
000078  2000              MOVS     r0,#0
;;;223    }
00007a  bd10              POP      {r4,pc}
;;;224    
                          ENDP

                  HAL_IncTick PROC
;;;310      */
;;;311    __weak void HAL_IncTick(void)
00007c  4838              LDR      r0,|L1.352|
;;;312    {
;;;313      uwTick++;
00007e  6801              LDR      r1,[r0,#0]  ; uwTick
000080  1c49              ADDS     r1,r1,#1
000082  6001              STR      r1,[r0,#0]  ; uwTick
;;;314    }
000084  4770              BX       lr
;;;315    
                          ENDP

                  HAL_GetTick PROC
;;;321      */
;;;322    __weak uint32_t HAL_GetTick(void)
000086  4836              LDR      r0,|L1.352|
;;;323    {
;;;324      return uwTick;
000088  6800              LDR      r0,[r0,#0]  ; uwTick
;;;325    }
00008a  4770              BX       lr
;;;326    
                          ENDP

                  HAL_Delay PROC
;;;337      */
;;;338    __weak void HAL_Delay(__IO uint32_t Delay)
00008c  b531              PUSH     {r0,r4,r5,lr}
;;;339    {
;;;340      uint32_t tickstart = 0;
;;;341      tickstart = HAL_GetTick();
00008e  f7fffffe          BL       HAL_GetTick
000092  4604              MOV      r4,r0
                  |L1.148|
;;;342      while((HAL_GetTick() - tickstart) < Delay)
000094  f7fffffe          BL       HAL_GetTick
000098  9900              LDR      r1,[sp,#0]
00009a  1b00              SUBS     r0,r0,r4
00009c  4288              CMP      r0,r1
00009e  d3f9              BCC      |L1.148|
;;;343      {
;;;344      }
;;;345    }
0000a0  bd38              POP      {r3-r5,pc}
;;;346    
                          ENDP

                  HAL_SuspendTick PROC
;;;356      */
;;;357    __weak void HAL_SuspendTick(void)
0000a2  f04f20e0          MOV      r0,#0xe000e000
;;;358    {
;;;359      /* Disable SysTick Interrupt */
;;;360      SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
0000a6  6901              LDR      r1,[r0,#0x10]
0000a8  f0210102          BIC      r1,r1,#2
0000ac  6101              STR      r1,[r0,#0x10]
;;;361    }
0000ae  4770              BX       lr
;;;362    
                          ENDP

                  HAL_ResumeTick PROC
;;;372      */
;;;373    __weak void HAL_ResumeTick(void)
0000b0  f04f20e0          MOV      r0,#0xe000e000
;;;374    {
;;;375      /* Enable SysTick Interrupt */
;;;376      SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
0000b4  6901              LDR      r1,[r0,#0x10]
0000b6  f0410102          ORR      r1,r1,#2
0000ba  6101              STR      r1,[r0,#0x10]
;;;377    }
0000bc  4770              BX       lr
;;;378    
                          ENDP

                  HAL_GetHalVersion PROC
;;;382      */
;;;383    uint32_t HAL_GetHalVersion(void)
0000be  4829              LDR      r0,|L1.356|
;;;384    {
;;;385     return __STM32F4xx_HAL_VERSION;
;;;386    }
0000c0  4770              BX       lr
;;;387    
                          ENDP

                  HAL_GetREVID PROC
;;;391      */
;;;392    uint32_t HAL_GetREVID(void)
0000c2  4829              LDR      r0,|L1.360|
;;;393    {
;;;394       return((DBGMCU->IDCODE) >> 16);
0000c4  6800              LDR      r0,[r0,#0]
0000c6  0c00              LSRS     r0,r0,#16
;;;395    }
0000c8  4770              BX       lr
;;;396    
                          ENDP

                  HAL_GetDEVID PROC
;;;400      */
;;;401    uint32_t HAL_GetDEVID(void)
0000ca  4827              LDR      r0,|L1.360|
;;;402    {
;;;403       return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
0000cc  6800              LDR      r0,[r0,#0]
0000ce  f3c0000b          UBFX     r0,r0,#0,#12
;;;404    }
0000d2  4770              BX       lr
;;;405    
                          ENDP

                  HAL_DBGMCU_EnableDBGSleepMode PROC
;;;409      */
;;;410    void HAL_DBGMCU_EnableDBGSleepMode(void)
0000d4  4824              LDR      r0,|L1.360|
;;;411    {
;;;412      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
0000d6  6841              LDR      r1,[r0,#4]
0000d8  f0410101          ORR      r1,r1,#1
0000dc  6041              STR      r1,[r0,#4]
;;;413    }
0000de  4770              BX       lr
;;;414    
                          ENDP

                  HAL_DBGMCU_DisableDBGSleepMode PROC
;;;418      */
;;;419    void HAL_DBGMCU_DisableDBGSleepMode(void)
0000e0  4821              LDR      r0,|L1.360|
;;;420    {
;;;421      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
0000e2  6841              LDR      r1,[r0,#4]
0000e4  f0210101          BIC      r1,r1,#1
0000e8  6041              STR      r1,[r0,#4]
;;;422    }
0000ea  4770              BX       lr
;;;423    
                          ENDP

                  HAL_DBGMCU_EnableDBGStopMode PROC
;;;427      */
;;;428    void HAL_DBGMCU_EnableDBGStopMode(void)
0000ec  481e              LDR      r0,|L1.360|
;;;429    {
;;;430      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
0000ee  6841              LDR      r1,[r0,#4]
0000f0  f0410102          ORR      r1,r1,#2
0000f4  6041              STR      r1,[r0,#4]
;;;431    }
0000f6  4770              BX       lr
;;;432    
                          ENDP

                  HAL_DBGMCU_DisableDBGStopMode PROC
;;;436      */
;;;437    void HAL_DBGMCU_DisableDBGStopMode(void)
0000f8  481b              LDR      r0,|L1.360|
;;;438    {
;;;439      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
0000fa  6841              LDR      r1,[r0,#4]
0000fc  f0210102          BIC      r1,r1,#2
000100  6041              STR      r1,[r0,#4]
;;;440    }
000102  4770              BX       lr
;;;441    
                          ENDP

                  HAL_DBGMCU_EnableDBGStandbyMode PROC
;;;445      */
;;;446    void HAL_DBGMCU_EnableDBGStandbyMode(void)
000104  4818              LDR      r0,|L1.360|
;;;447    {
;;;448      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
000106  6841              LDR      r1,[r0,#4]
000108  f0410104          ORR      r1,r1,#4
00010c  6041              STR      r1,[r0,#4]
;;;449    }
00010e  4770              BX       lr
;;;450    
                          ENDP

                  HAL_DBGMCU_DisableDBGStandbyMode PROC
;;;454      */
;;;455    void HAL_DBGMCU_DisableDBGStandbyMode(void)
000110  4815              LDR      r0,|L1.360|
;;;456    {
;;;457      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
000112  6841              LDR      r1,[r0,#4]
000114  f0210104          BIC      r1,r1,#4
000118  6041              STR      r1,[r0,#4]
;;;458    }
00011a  4770              BX       lr
;;;459    
                          ENDP

                  HAL_EnableCompensationCell PROC
;;;465      */
;;;466    void HAL_EnableCompensationCell(void)
00011c  2001              MOVS     r0,#1
;;;467    {
;;;468      *(__IO uint32_t *)CMPCR_CMP_PD_BB = (uint32_t)ENABLE;
00011e  fa90f1a0          RBIT     r1,r0
000122  fab1f181          CLZ      r1,r1
000126  0089              LSLS     r1,r1,#2
000128  f1014184          ADD      r1,r1,#0x42000000
00012c  f501111c          ADD      r1,r1,#0x270000
000130  f8c10400          STR      r0,[r1,#0x400]
;;;469    }
000134  4770              BX       lr
;;;470    
                          ENDP

                  HAL_DisableCompensationCell PROC
;;;476      */
;;;477    void HAL_DisableCompensationCell(void)
000136  2101              MOVS     r1,#1
;;;478    {
;;;479      *(__IO uint32_t *)CMPCR_CMP_PD_BB = (uint32_t)DISABLE;
000138  fa91f1a1          RBIT     r1,r1
00013c  2000              MOVS     r0,#0
00013e  fab1f181          CLZ      r1,r1
000142  0089              LSLS     r1,r1,#2
000144  f1014184          ADD      r1,r1,#0x42000000
000148  f501111c          ADD      r1,r1,#0x270000
00014c  f8c10400          STR      r0,[r1,#0x400]
;;;480    }
000150  4770              BX       lr
;;;481    
                          ENDP

000152  0000              DCW      0x0000
                  |L1.340|
                          DCD      0x40023c00
                  |L1.344|
                          DCD      0x40023820
                  |L1.348|
                          DCD      0x40023810
                  |L1.352|
                          DCD      ||.data||
                  |L1.356|
                          DCD      0x01030100
                  |L1.360|
                          DCD      0xe0042000

                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001

                          AREA ||.data||, DATA, ALIGN=2

                  uwTick
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "drivers\\src\\stm32f4xx_hal.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_hal_c_HAL_Init___Z7__REV16j|
#line 138 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.3.0\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_hal_c_HAL_Init___Z7__REV16j| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_hal_c_HAL_Init___Z7__REVSHi|
#line 153
|__asm___15_stm32f4xx_hal_c_HAL_Init___Z7__REVSHi| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_hal_c_HAL_Init___Z5__RRXj|
#line 328
|__asm___15_stm32f4xx_hal_c_HAL_Init___Z5__RRXj| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
