L 1 "memory\src\memory_alloc.cpp"
N#include "memory_alloc.h"
L 1 ".\memory\inc\memory_alloc.h" 1
N#ifndef __ALLOCATOR
N#define __ALLOCATOR
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5050106
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
N      namespace std {
N          #define __CLIBNS std::
N          extern "C" {
N    #else
S      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !1L || 0L
S
S    /* 7.18.2.1 */
S
S    /* minimum values of exact-width signed integer types */
S#define INT8_MIN                   -128
S#define INT16_MIN                -32768
S#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
S#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
S
S    /* maximum values of exact-width signed integer types */
S#define INT8_MAX                    127
S#define INT16_MAX                 32767
S#define INT32_MAX            2147483647
S#define INT64_MAX  __INT64_C(9223372036854775807)
S
S    /* maximum values of exact-width unsigned integer types */
S#define UINT8_MAX                   255
S#define UINT16_MAX                65535
S#define UINT32_MAX           4294967295u
S#define UINT64_MAX __UINT64_C(18446744073709551615)
S
S    /* 7.18.2.2 */
S
S    /* minimum values of minimum-width signed integer types */
S#define INT_LEAST8_MIN                   -128
S#define INT_LEAST16_MIN                -32768
S#define INT_LEAST32_MIN          (~0x7fffffff)
S#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
S
S    /* maximum values of minimum-width signed integer types */
S#define INT_LEAST8_MAX                    127
S#define INT_LEAST16_MAX                 32767
S#define INT_LEAST32_MAX            2147483647
S#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
S
S    /* maximum values of minimum-width unsigned integer types */
S#define UINT_LEAST8_MAX                   255
S#define UINT_LEAST16_MAX                65535
S#define UINT_LEAST32_MAX           4294967295u
S#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
S
S    /* 7.18.2.3 */
S
S    /* minimum values of fastest minimum-width signed integer types */
S#define INT_FAST8_MIN           (~0x7fffffff)
S#define INT_FAST16_MIN          (~0x7fffffff)
S#define INT_FAST32_MIN          (~0x7fffffff)
S#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
S
S    /* maximum values of fastest minimum-width signed integer types */
S#define INT_FAST8_MAX             2147483647
S#define INT_FAST16_MAX            2147483647
S#define INT_FAST32_MAX            2147483647
S#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
S
S    /* maximum values of fastest minimum-width unsigned integer types */
S#define UINT_FAST8_MAX            4294967295u
S#define UINT_FAST16_MAX           4294967295u
S#define UINT_FAST32_MAX           4294967295u
S#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
S
S    /* 7.18.2.4 */
S
S    /* minimum value of pointer-holding signed integer type */
S#if __sizeof_ptr == 8
S#define INTPTR_MIN INT64_MIN
S#else
S#define INTPTR_MIN INT32_MIN
S#endif
S
S    /* maximum value of pointer-holding signed integer type */
S#if __sizeof_ptr == 8
S#define INTPTR_MAX INT64_MAX
S#else
S#define INTPTR_MAX INT32_MAX
S#endif
S
S    /* maximum value of pointer-holding unsigned integer type */
S#if __sizeof_ptr == 8
S#define UINTPTR_MAX INT64_MAX
S#else
S#define UINTPTR_MAX INT32_MAX
S#endif
S
S    /* 7.18.2.5 */
S
S    /* minimum value of greatest-width signed integer type */
S#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
S
S    /* maximum value of greatest-width signed integer type */
S#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
S
S    /* maximum value of greatest-width unsigned integer type */
S#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
S
S    /* 7.18.3 */
S
S    /* limits of ptrdiff_t */
S#if __sizeof_ptr == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
S#else
S#define PTRDIFF_MIN INT32_MIN
S#define PTRDIFF_MAX INT32_MAX
S#endif
S
S    /* limits of sig_atomic_t */
S#define SIG_ATOMIC_MIN (~0x7fffffff)
S#define SIG_ATOMIC_MAX   2147483647
S
S    /* limit of size_t */
S#if __sizeof_ptr == 8
S#define SIZE_MAX UINT64_MAX
S#else
S#define SIZE_MAX UINT32_MAX
S#endif
S
S    /* limits of wchar_t */
S    /* NB we have to undef and redef because they're defined in both
S     * stdint.h and wchar.h */
S#undef WCHAR_MIN
S#undef WCHAR_MAX
S
S#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
S#else
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   65535
S#endif
S
S    /* limits of wint_t */
S#define WINT_MIN (~0x7fffffff)
S#define WINT_MAX 2147483647
S
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !1L || 0L
S
S    /* 7.18.4.1 macros for minimum-width integer constants */
S#define INT8_C(x)   (x)
S#define INT16_C(x)  (x)
S#define INT32_C(x)  (x)
S#define INT64_C(x)  __INT64_C(x)
S
S#define UINT8_C(x)  (x ## u)
S#define UINT16_C(x) (x ## u)
S#define UINT32_C(x) (x ## u)
S#define UINT64_C(x) __UINT64_C(x)
S
S    /* 7.18.4.2 macros for greatest-width integer constants */
S#define INTMAX_C(x)  __ESCAPE__(x ## ll)
S#define UINTMAX_C(x) __ESCAPE__(x ## ull)
S
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
N         }  /* extern "C" */
N      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
N    #ifndef __STDINT_NO_EXPORTS
N      using ::std::int8_t;
N      using ::std::int16_t;
N      using ::std::int32_t;
N      using ::std::int64_t;
N      using ::std::uint8_t;
N      using ::std::uint16_t;
N      using ::std::uint32_t;
N      using ::std::uint64_t;
N      using ::std::int_least8_t;
N      using ::std::int_least16_t;
N      using ::std::int_least32_t;
N      using ::std::int_least64_t;
N      using ::std::uint_least8_t;
N      using ::std::uint_least16_t;
N      using ::std::uint_least32_t;
N      using ::std::uint_least64_t;
N      using ::std::int_fast8_t;
N      using ::std::int_fast16_t;
N      using ::std::int_fast32_t;
N      using ::std::int_fast64_t;
N      using ::std::uint_fast8_t;
N      using ::std::uint_fast16_t;
N      using ::std::uint_fast32_t;
N      using ::std::uint_fast64_t;
N      using ::std::intptr_t;
N      using ::std::uintptr_t;
N      using ::std::intmax_t;
N      using ::std::uintmax_t;
N    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 5 ".\memory\inc\memory_alloc.h" 2
N#include <errno.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\errno.h" 1
N/* errno.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.3 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 1 */
N
N/*
N * RCS $Revision: 179217 $
N * Checkin $Date: 2013-03-12 14:03:19 +0000 (Tue, 12 Mar 2013) $
N * Revising $Author: drodgman $
N */
N
N#ifndef __errno_h
N#define __errno_h
N#define __ARMCLIB_VERSION 5050106
N
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N
N  #ifndef __ERRNO_DECLS
N  #define __ERRNO_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
N        namespace std {
N        #define __CLIBNS std::
N        extern "C" {
N    #else
S      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
Nextern _ARMABI_PURE volatile int *__aeabi_errno_addr(void);
Xextern __declspec(__nothrow) __attribute__((const)) volatile int *__aeabi_errno_addr(void);
N
N
N    #ifdef __cplusplus
N         }  /* extern "C" */
N      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __ERRNO_DECLS */
N
N  #ifdef __cplusplus
N    #ifndef __ERRNO_NO_EXPORTS
N      using ::std::__aeabi_errno_addr;
N    #endif /* __ERRNO_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#define errno (*__CLIBNS __aeabi_errno_addr())
N/*
N * expands to a modifiable lvalue that has type volatile int, the value of
N * which is set to a positive error code by several library functions. It is
N * initialised to zero at program startup, but is never set to zero by any
N * library function. The value of errno may be set to nonzero by a library
N * function call whether or not there is an error, provided the use of errno
N * is not documented in the description of the function in the Standard.
N */
N
N
N/*
N * Error numbers defined in the C standard need the ABI portability
N * mechanism.
N */
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N/* The ABI-defined signal numbers (EDOM, ERANGE and EILSEQ) are
N * defined differently depending on ABI conformance level. */
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
Sextern const int __aeabi_EDOM;
Sextern const int __aeabi_ERANGE;
Sextern const int __aeabi_EILSEQ;
S#define EDOM (__aeabi_EDOM)
S#define ERANGE (__aeabi_ERANGE)
S#define EILSEQ (__aeabi_EILSEQ)
N#else
N
N#define EDOM    1
N/*
N * If a mathematical function suffers a domain error (an input
N * argument is outside the domain over which the mathematical
N * function is defined, e.g. log of a negative number) the integer
N * expression errno acquires the value of the macro EDOM.
N *
N * EDOM is also returned by ftell, fgetpos and fsetpos when they
N * fail.
N */
N
N#define ERANGE 2
N/*
N * If a mathematical function suffers a range error (the result of
N * the function is too large or too small to be accurately
N * represented in the output floating-point format), the integer
N * expression errno acquires the value of the macro ERANGE.
N *
N * ERANGE is used by functions in math.h and complex.h, and also by
N * the strto* and wcsto* family of decimal-to-binary conversion
N * functions (both floating and integer) and by floating-point
N * conversions in scanf.
N */
N
N#define EILSEQ  4
N/*
N * EILSEQ is generated by the restartable multi-byte character
N * processing routines to indicate an encoding error: that is, it is
N * generated by mbrtowc, wcrtomb, mbsrtowcs and wcsrtombs, but not
N * by mbtowc, wctomb, mbstowcs or wcsrtombs.
N *
N * It is also generated by the wide-character stdio functions:
N * fputwc, putwc, putwchar, fputws, fgetwc, getwc, getwchar, fgetws.
N */
N
N#endif /* end of conditional definition of ABI-defined signals */
N
N#define ESIGNUM 3
N/*
N * ESIGNUM is generated by signal() if the user attempts to change
N * the handling of a nonexistent signal. ESIGNUM is not part of the
N * ANSI C standard.
N */
N
N#define EINVAL  5
N#define ENOMEM  6
N/*
N * EINVAL and ENOMEM can be generated by posix_memalign().
N */
N
N#endif
N
N/* end of errno.h */
N
L 6 ".\memory\inc\memory_alloc.h" 2
N#include "List.h"
L 1 ".\misc\inc\List.h" 1
N#ifndef __LIST
N#define __LIST
N#include <stdint.h>
N#include <vector>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\vector" 1
N// -*- C++ -*-
N/***************************************************************************
N *
N * vector - declarations for the Standard Library vector class
N *
N * $Id: vector 172106 2011-11-02 17:04:12Z statham $
N *
N ***************************************************************************
N *
N * Copyright (c) 1994
N * Hewlett-Packard Company
N *
N * Permission to use, copy, modify, distribute and sell this software
N * and its documentation for any purpose is hereby granted without fee,
N * provided that the above copyright notice appear in all copies and
N * that both that copyright notice and this permission notice appear
N * in supporting documentation.  Hewlett-Packard Company makes no
N * representations about the suitability of this software for any
N * purpose.  It is provided "as is" without express or implied warranty.
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_VECTOR_INCLUDED
N#define _RWSTD_VECTOR_INCLUDED
N
N#include <limits>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\limits" 1
N// -*- C++ -*-
N/***************************************************************************
N *
N * limits - Declarations for the C++ Standard Library class numeric_limits
N *
N * $Id: limits 179218 2013-03-12 14:04:12Z kwalker $
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_LIMITS_INCLUDED
N#define _RWSTD_LIMITS_INCLUDED
N
N#include <rw/_defs.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_defs.h" 1
N/***************************************************************************
N *
N * _defs.h - Common macro definitions to be included by every library file
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id: _defs.h 172106 2011-11-02 17:04:12Z statham $
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_DEFS_H_INCLUDED
N#define _RWSTD_DEFS_H_INCLUDED
N
N#include <rw/_config.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_config.h" 1
N/***************************************************************************
N *
N * _config.h - Compiler and C library configuration definitions
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id: _config.h 186353 2014-07-29 16:30:44Z ransin01 $
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2000 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_CONFIG_H_INCLUDED
N#define _RWSTD_CONFIG_H_INCLUDED
N
N// Always use the auto-generated config file for ARM Compilers
N#include <rw/config.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/config.h" 1
N/* Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved. */
N/* Copyright (c) 2002 ARM Ltd. All Rights Reserved.                        */
N#ifndef __RW_CONFIG_H_INCLUDED
N#define __RW_CONFIG_H_INCLUDED
N
N#define _RWSTD_NO_NATIVE_IO // Rogue Wave global config options
N#define _RWSTD_NO_CONST_FLT_ROUNDS // auto config
N#ifndef __EXCEPTIONS
N#define _RWSTD_NO_EXCEPTIONS // auto config
N#else
N#endif
N#define _RWSTD_NO_FILENO // auto config
N#ifndef __EXCEPTIONS
N#define _RWSTD_NO_FUNCTION_TRY_BLOCK // auto config
N#endif
N#define _RWSTD_NO_IEEEFP_H_REQUIRED // auto config
N#define _RWSTD_LLONG_PRINTF_PREFIX "ll"
N#define _RWSTD_NO_LRAND48 // auto config
N#define _RWSTD_NO_MATH_EXCEPTION // auto config
N#define _RWSTD_NO_MBSTATE_COMPARE // auto config
N#ifndef __EXCEPTIONS
N#define _RWSTD_NO_NEW_THROWS // auto config
N#else
N#endif
N#define _RWSTD_NO_NL_TYPES_H // auto config
N#define _RWSTD_NO_SSIZE_T // auto config
N#ifndef __EXCEPTIONS
N#define _RWSTD_NO_UNCAUGHT_EXCEPTION // auto config
N#else
N#endif
N#define _RWSTD_WINT_T int
N
N#endif /* __RW_CONFIG_H_INCLUDED */
L 39 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_config.h" 2
N
N// Library version number
N// 
N#define _RWSTD_VER 0x02020300
N//                    | | | |
N//                   AABBCCDD
N//                    | | | |
N//                    | | | +--- DD = Point release or "patch" release. 
N//                    | | |      Left D-digit is reserved for alpha releases
N//                    | | |      and right D-digit for beta releases
N//                    | | |      
N//                    | | +----- CC = Maintenance number
N//                    | +------- BB = Minor Release number
N//                    +--------- AA = Major Release number
N
N/*********************************************************************
N *                OVERRIDES FOR CONFIGURATION MACROS                 *
N *********************************************************************/
N
N/********************** ARM armcc **************************************/
N
N/* If implicit includes are switched off, include the file.cc explicitly */
N#ifndef __IMPLICIT_INCLUDE
S#  define _RWSTD_COMPILE_INSTANTIATE
N#endif /* __IMPLICIT_INCLUDE */
N#if __TARGET_ARCH_AARCH64
S#  define _RWSTD_NO_LONG_DOUBLE 1
N#endif /* __TARGET_ARCH_AARCH64 */
N
N/********************** EDG eccp *************************************/
N
N// NOTE: the __EDG__ macro is #defined by most edg-based compilers
N
N#if defined (__EDG__) && !defined (__DECCXX)
X#if 1L && !0L
N#  define _RWSTD_NO_DEPRECATED_C_HEADERS
N#  undef _RWSTD_NO_NEW_HEADER
N#  undef _RWSTD_NO_LIBC_IN_STD
N
N#  ifdef _RWSTD_MULTI_THREAD
S     // std::uncaught_exception() not thread-safe
S     // in the vanilla front-end (demo)
S#    define _RWSTD_NO_UNCAUGHT_EXCEPTION
N#  endif   // _RWSTD_MULTI_THREAD
N#endif   // __EDG__
N
N/********************** gcc ******************************************/
N
N/* armcc supports __attribute__ */
N#define _RWSTD_GNUC_ATTRIBUTE(attr)   __attribute__ (attr)
N
N/********************** Threads ***************************************/
N
N#ifdef _RWSTD_DCE_THREADS
S#  define _RWSTD_NO_STATIC_MUTEX_INIT
N#endif   // _RWSTD_DCE_THREADS
N
N/********************** Miscellaneous *********************************/
N
N// g++ cannot inline functions that take a variable number of arguments
N// or functions that contain static (local) variables
N#if !defined (__GNUG__) || __GNUG__ > 2 || __GNUG_MINOR__ > 96
X#if !0L || __GNUG__ > 2 || __GNUG_MINOR__ > 96
N#  define _INLINE_VARARGS      inline
N#  if !defined (__HP_aCC) || __HP_aCC > 012100
X#  if !0L || __HP_aCC > 012100
N     // working around a known aCC 1.21 bug
N#    define _INLINE_WITH_STATICS inline
N#  endif   // !__HP_aCC || __HP_aCC > 012100
N#endif   // !__GNUG__ || __GNUG__ > 2 || __GNUG_MINOR__ > 96
N
N#ifdef _RWSTD_NO_STATIC_TEMPLATE_MEMBER_INIT
S   // static mutex initialization depends on the compiler's (and the
S   // linker's in gcc's case) ability to correctly handle explicitly
S   // initialized static members of class templates
S#  ifndef _RWSTD_NO_STATIC_MUTEX_INIT
S#    define _RWSTD_NO_STATIC_MUTEX_INIT
S#  endif
N#endif   // _RWSTD_NO_STATIC_TEMPLATE_MEMBER_INIT
N
N/********************** Environment *********************************/
N
N/*
N * Most (but not all) non-unix systems convert new line to carriage
N * return / line feed on output:
N */
N#if defined (__OS2__) || defined (_WIN32) || defined (_WIN64)
X#if 0L || 0L || 0L
S#  define _RWSTD_CRLF_CONVENTION
N#endif
N
N
N// define wherever atomic instructions are not provided
N// affects the size of string reference (i.e., is binary incompatible)
N#if    !defined (__DECCXX)                           \
N    && !(defined (__i386__) && defined (__GNUG__))   \
N    && !defined (_WIN32) && !defined (_WIN64)
X#if    !0L                               && !(0L && 0L)       && !0L && !0L
N#  ifndef _RWSTD_NO_TEST_AND_SET
N#    define _RWSTD_NO_TEST_AND_SET
N#  endif   // _RWSTD_NO_TEST_AND_SET
N#endif   // !_WIN32 && !(__i386__ && __GNUG__)
N
N
N#ifdef _RWSTD_NO_WCHAR_T
S#  ifndef _RWSTD_NO_NATIVE_WCHAR_T /* may be defined in config.h */
S#    define _RWSTD_NO_NATIVE_WCHAR_T 1
S#  endif
N#endif
N
N
N#ifndef _RWSTD_NO_STL_SPECIALIZATION
N// #ifdef _RWSTD_NO_CLASS_PARTIAL_SPEC
N// disable partial specialization for void* of STL sequences
N#  define _RWSTD_NO_STL_SPECIALIZATION
N// #endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N#endif   // _RWSTD_NO_STL_SPECIALIZATION
N
N// 
N// Macro for path to the ANSI 'C' headers 
N// Must be set specifically for each platform when the
N// C++ wrappers for 'C' headers are used.
N//
N#define _RWSTD_ANSIC(x) </usr/include/x>
N
N// define unless already specified
N#ifndef _RWSTD_LDBL_PRINTF_PREFIX
N#  define _RWSTD_LDBL_PRINTF_PREFIX   "L"
N#endif   // _RWSTD_LDBL_PRINTF_PREFIX
N
N#ifndef _RWSTD_LDBL_SCANF_PREFIX
N#  define _RWSTD_LDBL_SCANF_PREFIX   "L"
N#endif   // _RWSTD_LDBL_SCANF_PREFIX
N
N
N/********************** Library Option Dependencies *************************/
N
N/*
N * The following macro sets the default size of file stream internal buffers
N */
N
N#ifndef _RWSTD_DEFAULT_BUFSIZE         // specified on command line?
N#  define _RWSTD_DEFAULT_BUFSIZE   512
N#endif
N
N#ifndef _RWSTD_NO_LONG_LONG
N   #if defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__) && !defined(__clang__)
X   #if 1L && !0L && !0L
N     /* strict armcc has '__int64' */
N     #define _RWSTD_LONG_LONG __int64
N   #endif
N   /* armclang and non-strict armcc allow 'long long' in system headers */
N   // Win32/64 #defines _RWSTD_LONG_LONG to __int64
N#  ifndef _RWSTD_LONG_LONG
S#    define _RWSTD_LONG_LONG long long
N#  endif   // _RWSTD_LONG_LONG
N#endif   // _RWSTD_NO_LONG_LONG
N
N
N// disable all extensions in strict ANSI mode
N#ifdef _RWSTD_STRICT_ANSI
S#  define _RWSTD_NO_EXT_FILEBUF
S#  define _RWSTD_NO_EXT_VECTOR_BOOL_REF_OPS
S#  define _RWSTD_NO_EXT_LOCALE
S#  define _RWSTD_NO_EXT_DEEP_STRING_COPY
S   // no support for exceptions derived from ios_base::failure
S#  define _RWSTD_NO_EXT_FAILURE
S   // no support for writing out integral values in base 2
S#  define _RWSTD_NO_EXT_BIN_IO
S   // no support for optional mt-locking in iostreams
S#  define _RWSTD_NO_EXT_REENTRANT_IO
S   // allocator<const T> not possible
S#  define _RWSTD_NO_EXT_CONST_ALLOCATOR
S   // no definitions provided for missing operator new or delete
S#  define _RWSTD_NO_EXT_OPERATOR_NEW
S   // void std::count<>() not provided (except when necessary)
S#  define _RWSTD_NO_EXT_VOID_COUNT
S   // void std::distance<>()  not provided
S#  define _RWSTD_NO_EXT_VOID_DISTANCE
N#endif   // _RWSTD_STRICT_ANSI
N
N   // macros that are enabled in library source files
N#ifdef _RWSTD_LIB_SRC
S   // don't instantiate templates in library source code
S   //  (but see _RWSTD_INSTANTIATE_TEMPLATES macro below) 
S#  define _RWSTD_NO_TEMPLATE_DEFINITIONS
S   // don't provide definitions of operator new in library 
S#  define _RWSTD_NO_EXT_OPERATOR_NEW
N#endif  // _RWSTD_LIB_SRC
N
N#if _MSC_VER <= 1300
N   // msvc60 expects a definition to be provided for all variants
N   // of operator new/delete that are declared. This means that either
N   // the operators must be defined - preventing redefinition in user code -
N   // or that they must be undeclared - preventing them from being called
N   // directly in user code. We have chosen the former option.
N#  undef _RWSTD_NO_EXT_OPERATOR_NEW
N#endif  // _MSC_VER
N
N#ifdef _RWSTD_INSTANTIATE_TEMPLATES
S   // instantiate templates (this macro appears in instance.cpp)
S#  undef _RWSTD_NO_TEMPLATE_DEFINITIONS
N#endif
N
N
N#endif   // _RWSTD_CONFIG_H_INCLUDED
N
L 38 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_defs.h" 2
N
N
N// provide definitions for C++ versions of standard C headers
N// if a header is not available its name is #defined to the name of
N// this file (it's harmless and avoids polluting code with
N// tons of ugly platform-specific #ifdefs)
N#ifndef _RWSTD_NO_NEW_HEADER
N
N#  define _RWSTD_CASSERT   <cassert>
N#  define _RWSTD_CCTYPE    <cctype>
N#  define _RWSTD_CERRNO    <cerrno>
N#  define _RWSTD_CFLOAT    <cfloat>
N#  define _RWSTD_CISO646   <ciso646>
N#  define _RWSTD_CLIMITS   <climits>
N#  define _RWSTD_CLOCALE   <clocale>
N#  define _RWSTD_CMATH     <cmath>
N#  define _RWSTD_CSETJMP   <csetjmp>
N#  define _RWSTD_CSIGNAL   <csignal>
N#  define _RWSTD_CSTDARG   <cstdarg>
N#  define _RWSTD_CSTDDEF   <cstddef>
N#  define _RWSTD_CSTDIO    <cstdio>
N#  define _RWSTD_CSTDLIB   <cstdlib>
N#  define _RWSTD_CSTRING   <cstring>
N#  define _RWSTD_CTIME     <ctime>
N
N#  ifndef _RWSTD_NO_WCHAR_H
N#    define _RWSTD_CWCHAR  <cwchar>
N#  else
S#    define _RWSTD_CWCHAR  <rw/_defs.h>
N#  endif   // _RWSTD_NO_WCHAR_H
N
N#  ifndef _RWSTD_NO_WCTYPE_H
N#    define _RWSTD_CWCTYPE <cwctype>
N#  else
S#    define _RWSTD_CWCTYPE <rw/_defs.h>
N#  endif   // _RWSTD_NO_WCTYPE_H
N
N#else   // if defined (_RWSTD_NO_NEW_HEADER)
S
S#  define _RWSTD_CASSERT   <assert.h>
S#  define _RWSTD_CCTYPE    <ctype.h>
S#  define _RWSTD_CERRNO    <errno.h>
S#  define _RWSTD_CFLOAT    <float.h>
S#  define _RWSTD_CISO646   <iso646.h>
S#  define _RWSTD_CLIMITS   <limits.h>
S#  define _RWSTD_CLOCALE   <locale.h>
S#  define _RWSTD_CMATH     <math.h>
S#  define _RWSTD_CSETJMP   <setjmp.h>
S#  define _RWSTD_CSIGNAL   <signal.h>
S#  define _RWSTD_CSTDARG   <stdarg.h>
S#  define _RWSTD_CSTDDEF   <stddef.h>
S#  define _RWSTD_CSTDIO    <stdio.h>
S#  define _RWSTD_CSTDLIB   <stdlib.h>
S#  define _RWSTD_CSTRING   <string.h>
S#  define _RWSTD_CTIME     <time.h>
S
S#  ifndef _RWSTD_NO_WCHAR_H
S#    define _RWSTD_CWCHAR  <wchar.h>
S#  else
S#    define _RWSTD_CWCHAR  <rw/_defs.h>
S#  endif   // _RWSTD_NO_WCHAR_H
S
S#  ifndef _RWSTD_NO_WCTYPE_H
S#    define _RWSTD_CWCTYPE <wctype.h>
S#  else
S#    define _RWSTD_CWCTYPE <rw/_defs.h>
S#  endif   // _RWSTD_NO_WCTYPE_H
S
N#endif   // _RWSTD_NO_NEW_HEADER
N
N
N#if defined(_WIN64)
X#if 0L
S#  define _RWSTD_SYS_TYPES_H <basetsd.h>
S#elif defined(_WIN32)
X#elif 0L
S#  define _RWSTD_SYS_TYPES_H <rw/_defs.h>
N#else
N#  define _RWSTD_SYS_TYPES_H <sys/types.h>
N#endif   // _WIN32
N
N
N#ifdef _RWSTD_REQUIRES_IEEEFP
S// non-standard file required on Some platforms (e.g., Siemens) for <limits>
S#  define _RWSTD_IEEEFP <ieeefp.h>
N#else
N#  define _RWSTD_IEEEFP <rw/_defs.h>
N#endif
N
N
N// provide default #definitions of ANSI C library headers
N#if !defined (_RWSTD_NO_ASSERT_H) && !defined (_RWSTD_ANSI_C_ASSERT_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_ASSERT_H "/usr/include/assert.h"
N#endif
N#if !defined (_RWSTD_NO_CTYPE_H) && !defined (_RWSTD_ANSI_C_CTYPE_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_CTYPE_H "/usr/include/ctype.h"
N#endif
N#if !defined (_RWSTD_NO_ERRNO_H) && !defined (_RWSTD_ANSI_C_ERRNO_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_ERRNO_H "/usr/include/errno.h"
N#endif
N#if !defined (_RWSTD_NO_FLOAT_H) && !defined (_RWSTD_ANSI_C_FLOAT_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_FLOAT_H "/usr/include/float.h"
N#endif
N#if !defined (_RWSTD_NO_ISO646_H) && !defined (_RWSTD_ANSI_C_ISO646_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_ISO646_H "/usr/include/iso646.h"
N#endif
N#if !defined (_RWSTD_NO_LIMITS_H) && !defined (_RWSTD_ANSI_C_LIMITS_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_LIMITS_H "/usr/include/limits.h"
N#endif
N#if !defined (_RWSTD_NO_LOCALE_H) && !defined (_RWSTD_ANSI_C_LOCALE_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_LOCALE_H "/usr/include/locale.h"
N#endif
N#if !defined (_RWSTD_NO_MATH_H) && !defined (_RWSTD_ANSI_C_MATH_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_MATH_H "/usr/include/math.h"
N#endif
N#if !defined (_RWSTD_NO_SETJMP_H) && !defined (_RWSTD_ANSI_C_SETJMP_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_SETJMP_H "/usr/include/setjmp.h"
N#endif
N#if !defined (_RWSTD_NO_SIGNAL_H) && !defined (_RWSTD_ANSI_C_SIGNAL_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_SIGNAL_H "/usr/include/signal.h"
N#endif
N#if !defined (_RWSTD_NO_STDARG_H) && !defined (_RWSTD_ANSI_C_STDARG_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_STDARG_H "/usr/include/stdarg.h"
N#endif
N#if !defined (_RWSTD_NO_STDDEF_H) && !defined (_RWSTD_ANSI_C_STDDEF_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_STDDEF_H "/usr/include/stddef.h"
N#endif
N#if !defined (_RWSTD_NO_STDIO_H) && !defined (_RWSTD_ANSI_C_STDIO_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_STDIO_H "/usr/include/stdio.h"
N#endif
N#if !defined (_RWSTD_NO_STDLIB_H) && !defined (_RWSTD_ANSI_C_STDLIB_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_STDLIB_H "/usr/include/stdlib.h"
N#endif
N#if !defined (_RWSTD_NO_STRING_H) && !defined (_RWSTD_ANSI_C_STRING_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_STRING_H "/usr/include/string.h"
N#endif
N#if !defined (_RWSTD_NO_TIME_H) && !defined (_RWSTD_ANSI_C_TIME_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_TIME_H "/usr/include/time.h"
N#endif
N#if !defined (_RWSTD_NO_WCHAR_H) && !defined (_RWSTD_ANSI_C_WCHAR_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_WCHAR_H "/usr/include/wchar.h"
N#endif
N#if !defined (_RWSTD_NO_WCTYPE_H) && !defined (_RWSTD_ANSI_C_WCTYPE_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_WCTYPE_H "/usr/include/wctype.h"
N#endif
N
N
N// Macro for determining the number of bits in a word.
N// Used by vector<bool>.
N//
N#define _RWSTD_WORD_BIT (int(CHAR_BIT*sizeof(unsigned int)))
N
N
N//
N// These macros tune the speed vs. space optimization of container
N// performance with regard to allocation of memory. These have been tuned
N// with speed efficiency as a primary conern. Space efficiency was
N// considered, but was secondary. (refer to Onyx QA Entry #4920)
N//
N// The ratio parameter must be above one for an amortized constant time
N// algorithm.  Lowering the ratio will lower rapidity and improve space
N// efficiency. This effect will be most noticable when working with
N// containers of few elements (few being less than 32 for the general case)
N// If your use case is with containers that typically have many elements
N// lowering the ratio will have less effect on rapidity.
N//
N// The minimum elements parameter refers to minimum amount of additional
N// capcity requested (in number of elements) when more memory is needed.
N// Rapidity with containers of few elements will be affected most noticably
N// as this amount this is lowered.
N//
N// For strings, the specializations on char and wchar_t were seen as an
N// exploitable common case, and have their own more specialized template
N// function overloads in the string header.  These are tweakable here
N// with the STRING version of these macros.
N//
N#if !defined(_RWSTD_MINIMUM_NEW_CAPACITY)
X#if !0L
N#  define _RWSTD_MINIMUM_NEW_CAPACITY _RWSTD_C::size_t (32)
N#endif
N#if !defined(_RWSTD_NEW_CAPACITY_RATIO)
X#if !0L
N   // using long doubles to eliminate bogus warnings on g++ 2.95.2/sparc
N   // (-W -O2/3 only): warning: overflow on truncation to integer
N   //#  define _RWSTD_NEW_CAPACITY_RATIO 1.618L
N#  define _RWSTD_INCREASE_CAPACITY(x) ((x) + ((x) >> 1) + ((x) >> 3)) // 'x * 1.625'
N#endif
N#if !defined(_RWSTD_MINIMUM_STRING_CAPACITY)
X#if !0L
N#  define _RWSTD_MINIMUM_STRING_CAPACITY _RWSTD_C::size_t (128)
N#endif
N#if !defined(_RWSTD_STRING_CAPACITY_RATIO)
X#if !0L
N   //#  define _RWSTD_STRING_CAPACITY_RATIO 1.618L
N#  define _RWSTD_INCREASE_STRING_CAPACITY(x) _RWSTD_INCREASE_CAPACITY(x)
N#endif
N
N
N// set up Win32/64 DLL export/import directives
N// _DLL - defined by the compiler when either -MD or -MDd is used
N// RWDLL - defined for all Rogue Wave products to be built as shared libs
N// _RWSHARED - defined for stdlib to be built/used as a shared lib
N#if    (defined (_WIN32) || defined (_WIN64)) \
N    && (defined (RWDLL) || defined (_RWSHARED))
X#if    (0L || 0L)     && (0L || 0L)
S#  ifdef _RWBUILD_std
S     // building a shared lib, export names
S#    define _RWSTD_EXPORT   __declspec (dllexport)
S#  else
S     // using a shared lib, import names
S#    define _RWSTD_EXPORT   __declspec (dllimport)
S#  endif
S
S   // disable warnings:
S   // C4251: class needs to have dll-interface to be used by cliens
S   // C4275: non dll-interface class used as base for dll-interface class
S#  pragma warning (disable: 4251)
S#  pragma warning (disable: 4275)
N#else
N// disable Windows hacks
N#  define _RWSTD_EXPORT
N#endif
N
N
N// The member variable string::npos is required to be static to allow its
N// use in constant expressions.  For compilers that do not support static
N// intialization an enumeration is used.  This workaround is not available
N// on LLP64 architectures however, where enums are 32 bit.  In this case it
N// we don't have a workaround to support the use of npos in constant
N// expressions, the macro _RWSTD_NPOS must be used instead
N#if defined(_RWSTD_LLP64_ARCHITECTURE) && defined(_RWSTD_NO_STATIC_CONST_MEMBER_INIT)
X#if 0L && 0L
S#  define _RWSTD_NPOS _RWSTD_C::size_t(-1)
N#else
N#  define _RWSTD_NPOS string::npos
N#endif
N
N
N/*
N** Miscellaneous workarounds.
N*/
N
N#ifdef _RWSTD_NO_BOOL
S#  ifdef _RWSTD_MSVC_BOOL_WARNING
S#    pragma warning ( disable : 4237 )
S#  endif
S
S   typedef int     bool;
S
S#  ifndef true
S#    define true    1
S#  endif
S
S#  ifndef false
S#    define false   0
S#  endif
N#endif // _RWSTD_NO_BOOL
N
N
N#ifndef _RWSTD_NO_TYPENAME
N#  define _TYPENAME typename
N#else
S#  define _TYPENAME
N#endif
N
N#if defined (SNI) || defined (__SUNPRO_CC) && __SUNPRO_CC <= 0x520
X#if 0L || 0L && __SUNPRO_CC <= 0x520
S#  define _TYPENAME_CTOR
N#else
N#  define _TYPENAME_CTOR _TYPENAME
N#endif
N
N#ifndef _RWSTD_NO_EXPLICIT
N#  define _EXPLICIT explicit
N#else
S#  define _EXPLICIT
N#endif
N
N
N#ifndef _RWSTD_NO_MUTABLE
N#  define _MUTABLE mutable
N#else
S#  define _MUTABLE
N#endif
N
N
N//
N// Macro for forming or omitting default template arguments in constructors
N//
N
N#ifndef _RWSTD_NO_DEFAULT_TEMPLATE_ARGS
N#  define _RWSTD_DEFAULT_ARG(n) = n
N#else
S#  define _RWSTD_DEFAULT_ARG(n)
N#endif
N
N
N// MSVC version 12.00.xxxx (and perhaps prior) can't parse template
N// re-declarations if the previous declaration contains two or more
N// default template parameters (go figure)
N#if defined (_MSC_VER) && _MSC_VER <= 1300
X#if 0L && _MSC_VER <= 1300
S#  define _RWSTD_REDECLARED_DEFAULT(arg)   = arg
N#else   // if !(!defined (_MSC_VER) || (_MSC_VER <= 1300))
N#  define _RWSTD_REDECLARED_DEFAULT(ignore)
N#endif   // !defined (_MSC_VER) || (_MSC_VER <= 1300)
N
N
N//
N// Macro for forming or ommitting default template parameters.
N//
N#ifndef _RWSTD_NO_SIMPLE_DEFAULT_TEMPLATES
N#  define _RWSTD_SIMPLE_DEFAULT(a)  = a
N#  ifndef _RWSTD_NO_COMPLEX_DEFAULT_TEMPLATES
N#    define _RWSTD_COMPLEX_DEFAULT(a)  = a
N#  else
S#    define _RWSTD_COMPLEX_DEFAULT(a)
N#  endif
N#else   // if defined (_RWSTD_NO_SIMPLE_DEFAULT_TEMPLATES)
S#  ifndef _RWSTD_NO_COMPLEX_DEFAULT_TEMPLATES
S#    define _RWSTD_NO_COMPLEX_DEFAULT_TEMPLATES
S#  endif
S#  define _RWSTD_SIMPLE_DEFAULT(a)
S#  define _RWSTD_COMPLEX_DEFAULT(a)
S#  ifndef _RWSTD_NO_DEFAULT_TEMPLATES
S#    define _RWSTD_NO_DEFAULT_TEMPLATES
S#  endif
N#endif   // _RWSTD_NO_SIMPLE_DEFAULT_TEMPLATES
N
N
N// Macro for casting, using either the "old" method
N// or the new C++ cast system
N#ifdef _RWSTD_NO_STATIC_CAST
S#  define _RWSTD_STATIC_CAST(x, y)      ((x)y)
S#  define _RWSTD_REINTERPRET_CAST(x, y) ((x)y)
S#  define _RWSTD_CONST_CAST(x, y)       ((x)y)
N#else
N#  define _RWSTD_STATIC_CAST(x, y)      static_cast< x >(y)
N#  define _RWSTD_REINTERPRET_CAST(x, y) reinterpret_cast< x >(y)
N#  define _RWSTD_CONST_CAST(x, y)       const_cast< x >(y)
N#endif   // _RWSTD_NO_STATIC_CAST
N
N//
N// Macros for the new template specialization syntax
N//
N
N#ifdef _RWSTD_NO_NEW_FUNC_TEMPLATE_SYNTAX
S#  define _RWSTD_SPECIALIZED_FUNCTION
N#else
N#  define _RWSTD_SPECIALIZED_FUNCTION template<>
N#endif
N
N#ifdef _RWSTD_NO_NEW_CLASS_TEMPLATE_SYNTAX
S#  define _RWSTD_SPECIALIZED_CLASS
N#else
N#  define _RWSTD_SPECIALIZED_CLASS template<>
N#endif
N
N// for compilers or environments that do not support namespaces
N#ifndef _RWSTD_NO_NAMESPACE
N#  define _RWSTD_NAMESPACE_BEGIN(name)    namespace name {
N#  define _RWSTD_NAMESPACE_END            }
N
N#  define _USING(name)                    using name
N
N#  ifdef _MSC_VER
S#    define _STD                       ::std
S#    define _STD_RW                    ::std
S#    define _RW                        ::__rw
N#  else
N#    define _STD                       std
N#    define _STD_RW                    std
N#    define _RW                        __rw
N#  endif
N
N#else   // if defined (_RWSTD_NO_NAMESPACE)
S#  define _RWSTD_NAMESPACE_BEGIN(ignore)
S#  define _RWSTD_NAMESPACE_END
S
S#  define _USING(ignore)              typedef void __rw_unused_typedef
S
S#  define _STD
S#  define _STD_RW
S#  define _RW
N#endif   // _RWSTD_NO_NAMESPACE
N
N//
N// for compilers that don't like specialized friends
N// such as operator== in template classes
N//
N#ifdef _RWSTD_NO_SPECIALIZED_FRIEND
S#  ifdef __TURBOC__
S#    define _RWSTD_SPECIALIZED_FRIEND(name)   (_STD_RW::name)
S#  else   // if !defined (__TURBOC__)
S#    define _RWSTD_SPECIALIZED_FRIEND(name)   name
S#  endif   // __TURBOC__
N#else   // if defined (_RWSTD_NO_SPECIALIZED_FRIEND)
N#  ifdef __TURBOC__
S#    define _RWSTD_SPECIALIZED_FRIEND(name)   (_STD_RW::name)
N#  else   // if !defined (__TURBOC__)
N     // the space between `name' and `<>' is necessary
N     // to prevent ..._FRIEND (operator<) from expanding into operator<<>
N     // (only the GNU preprocessor inserts a space)
N#    define _RWSTD_SPECIALIZED_FRIEND(name)   name <>
N#  endif  // __TURBOC__
N#endif   // _RWSTD_NO_SPECIALIZED_FRIEND
N
N
N//
N// If compiler supports member and default templates then it support
N// the _RWSTD_ALLLOCATOR
N//
N#if    !defined(_RWSTD_NO_MEMBER_TEMPLATES) \
N    && !defined(_RWSTD_NO_SIMPLE_DEFAULT_TEMPLATES) \
N    && !defined(_RWSTD_NO_MEM_CLASS_TEMPLATES)
X#if    !0L     && !0L     && !0L
N#  define _RWSTD_ALLOCATOR
N#endif
N
N
N#define _RWSTD_MB_CUR_MAX 16  //???  Need to find absolute maximum for this
N
N
N// helper macros for token pasting
N#define _RWSTD_DO_PASTE(a, b)   a ## b
N#define _RWSTD_PASTE(a, b)      _RWSTD_DO_PASTE (a, b)
N
N#ifdef _RWSTD_MULTI_THREAD
S// synchronizes access by all objects holding the same mutex
S#  define _RWSTD_MT_GUARD(mutex)  \
S          _RW::__rw_guard _RWSTD_PASTE (__guard, __LINE__) (mutex)
X#  define _RWSTD_MT_GUARD(mutex)            _RW::__rw_guard _RWSTD_PASTE (__guard, __LINE__) (mutex)
S
S// synchronizes access by all threads
S#  define _RWSTD_MT_STATIC_GUARD(name)        \
S          static _RW::__rw_mutex name; \
S          _RWSTD_MT_GUARD (name)
X#  define _RWSTD_MT_STATIC_GUARD(name)                  static _RW::__rw_mutex name;           _RWSTD_MT_GUARD (name)
S
S// synchronizes access by all objects of the same type
S#  define _RWSTD_MT_CLASS_GUARD(name, type) \
S          _RWSTD_MT_GUARD (_RW::__rw_get_static_mutex ((type*)0))
X#  define _RWSTD_MT_CLASS_GUARD(name, type)           _RWSTD_MT_GUARD (_RW::__rw_get_static_mutex ((type*)0))
S
S#  define _RWSTD_ATOMIC_PREINCREMENT(x, mutex) \
S          _RW::__rw_atomic_preincrement (x, mutex)
X#  define _RWSTD_ATOMIC_PREINCREMENT(x, mutex)           _RW::__rw_atomic_preincrement (x, mutex)
S
S#  define _RWSTD_ATOMIC_PREDECREMENT(x, mutex) \
S          _RW::__rw_atomic_predecrement (x, mutex)
X#  define _RWSTD_ATOMIC_PREDECREMENT(x, mutex)           _RW::__rw_atomic_predecrement (x, mutex)
S
S#  define _RWSTD_ATOMIC_SWAP(x, y, mutex) \
S          _RW::__rw_atomic_exchange  (x, y, mutex)
X#  define _RWSTD_ATOMIC_SWAP(x, y, mutex)           _RW::__rw_atomic_exchange  (x, y, mutex)
S
S#  ifndef _RWSTD_NO_EXT_REENTRANT_IO
S// conditional swap used in iostreams
S#    define _RWSTD_ATOMIC_IO_SWAP(x, y, mutex)           \
S            ((this->flags () & _RWSTD_IOS_NOLOCK) ?      \
S                _RW::__rw_ordinary_exchange  (x, y)      \
S             :  _RW::__rw_atomic_exchange  (x, y, mutex))
X#    define _RWSTD_ATOMIC_IO_SWAP(x, y, mutex)                       ((this->flags () & _RWSTD_IOS_NOLOCK) ?                      _RW::__rw_ordinary_exchange  (x, y)                   :  _RW::__rw_atomic_exchange  (x, y, mutex))
S
S#  else
S#    define _RWSTD_ATOMIC_IO_SWAP(x, y, mutex)           \
S            _RWSTD_ATOMIC_SWAP(x, y, mutex)
X#    define _RWSTD_ATOMIC_IO_SWAP(x, y, mutex)                       _RWSTD_ATOMIC_SWAP(x, y, mutex)
S#  endif    // _RWSTD_NO_EXT_REENTRANT_IO
S
N#else   // if !defined _RWSTD_MULTI_THREAD
N
N#  define _RWSTD_MT_GUARD(ignore)                   ((void)0)
N#  define _RWSTD_MT_STATIC_GUARD(name)              _RWSTD_MT_GUARD (name)
N#  define _RWSTD_MT_CLASS_GUARD(name, ignore)       _RWSTD_MT_GUARD (name)
N
N#  define _RWSTD_ATOMIC_PREINCREMENT(x, ignore)     ++(x)
N#  define _RWSTD_ATOMIC_PREDECREMENT(x, ignore)     --(x)
N#  define _RWSTD_ATOMIC_SWAP(x, y, ignore)  \
N          _RW::__rw_atomic_exchange ((x), (y), false)
X#  define _RWSTD_ATOMIC_SWAP(x, y, ignore)            _RW::__rw_atomic_exchange ((x), (y), false)
N
N#  define _RWSTD_ATOMIC_IO_SWAP(x, y, ignore)  \
N          _RW::__rw_ordinary_exchange ((x), (y))
X#  define _RWSTD_ATOMIC_IO_SWAP(x, y, ignore)            _RW::__rw_ordinary_exchange ((x), (y))
N
N#endif   // _RWSTD_MULTI_THREAD
N
N
N// macro for qualifying C library names in the std namespace
N#ifndef _RWSTD_NO_LIBC_IN_STD
N# define _RWSTD_C std
N#else
S# define _RWSTD_C
N#endif
N
N#define _RWSTD_INVALID_FILE_DESC -1
N#define _RWSTD_INVALID_FILE_PTR   0
N
N#ifndef _RWSTD_NO_NATIVE_IO
S# define _RWSTD_INVALID_FILE     -1
S# define _RWSTD_INVALID_OPENMODE -1
N#else
N# define _RWSTD_INVALID_FILE      (FILE*)0
N# define _RWSTD_INVALID_OPENMODE  0
N#endif // _RWSTD_NO_NATIVE_IO
N
N
N// std::ios_base static const data members' values
N#define _RWSTD_IOS_BOOLALPHA    0x00001
N#define _RWSTD_IOS_DEC          0x00002
N#define _RWSTD_IOS_FIXED        0x00004
N#define _RWSTD_IOS_HEX          0x00008
N#define _RWSTD_IOS_INTERNAL     0x00010
N#define _RWSTD_IOS_LEFT         0x00020
N#define _RWSTD_IOS_OCT          0x00040
N#define _RWSTD_IOS_RIGHT        0x00080
N#define _RWSTD_IOS_SCIENTIFIC   0x00100
N#define _RWSTD_IOS_SHOWBASE     0x00200
N#define _RWSTD_IOS_SHOWPOINT    0x00400
N#define _RWSTD_IOS_SHOWPOS      0x00800
N#define _RWSTD_IOS_SKIPWS       0x01000
N#define _RWSTD_IOS_UNITBUF      0x02000
N#define _RWSTD_IOS_UPPERCASE    0x04000
N#define _RWSTD_IOS_BIN          0x08000
N// NOLOCK[BUF] used rather than LOCK[BUF] to maintain functional compatibility
N// with release 2.2 (which was always safe when these bits were cleared)
N#define _RWSTD_IOS_NOLOCK       0x10000
N#define _RWSTD_IOS_NOLOCKBUF    0x20000
N
N#define _RWSTD_IOS_FLOATFIELD   _RWSTD_IOS_FIXED | _RWSTD_IOS_SCIENTIFIC
N
N#define _RWSTD_IOS_ADJUSTFIELD    \
N        (_RWSTD_IOS_LEFT | _RWSTD_IOS_RIGHT | _RWSTD_IOS_INTERNAL)
X#define _RWSTD_IOS_ADJUSTFIELD            (_RWSTD_IOS_LEFT | _RWSTD_IOS_RIGHT | _RWSTD_IOS_INTERNAL)
N
N#ifndef _RWSTD_NO_EXT_BIN_IO
N#  define _RWSTD_IOS_BASEFIELD    \
N          (_RWSTD_IOS_DEC | _RWSTD_IOS_HEX | _RWSTD_IOS_OCT | _RWSTD_IOS_BIN)
X#  define _RWSTD_IOS_BASEFIELD              (_RWSTD_IOS_DEC | _RWSTD_IOS_HEX | _RWSTD_IOS_OCT | _RWSTD_IOS_BIN)
N#else
S#  define _RWSTD_IOS_BASEFIELD    \
S          (_RWSTD_IOS_DEC | _RWSTD_IOS_HEX | _RWSTD_IOS_OCT)
X#  define _RWSTD_IOS_BASEFIELD              (_RWSTD_IOS_DEC | _RWSTD_IOS_HEX | _RWSTD_IOS_OCT)
N#endif   // _RWSTD_NO_EXT_BIN_IO
N
N
N#define _RWSTD_IOS_GOODBIT       0x00
N#define _RWSTD_IOS_BADBIT        0x01
N#define _RWSTD_IOS_EOFBIT        0x02
N#define _RWSTD_IOS_FAILBIT       0x04
N
N#define _RWSTD_IOS_APP           0x01
N#define _RWSTD_IOS_BINARY        0x02
N#define _RWSTD_IOS_IN            0x04
N#define _RWSTD_IOS_OUT           0x08
N#define _RWSTD_IOS_TRUNC         0x10
N#define _RWSTD_IOS_ATE           0x20
N
N#ifndef _RWSTD_STRICT_ANSI
N#  define _RWSTD_IOS_NOCREATE    0x40
N#  define _RWSTD_IOS_NOREPLACE   0x80
N#else
S#  define _RWSTD_IOS_NOCREATE    0
S#  define _RWSTD_IOS_NOREPLACE   0
N#endif
N
N#define _RWSTD_IOS_MASK                         \
N        (  _RWSTD_IOS_APP | _RWSTD_IOS_BINARY   \
N         | _RWSTD_IOS_IN | _RWSTD_IOS_OUT       \
N         | _RWSTD_IOS_TRUNC | _RWSTD_IOS_ATE    \
N         | _RWSTD_IOS_NOCREATE | _RWSTD_IOS_NOREPLACE)
X#define _RWSTD_IOS_MASK                                 (  _RWSTD_IOS_APP | _RWSTD_IOS_BINARY            | _RWSTD_IOS_IN | _RWSTD_IOS_OUT                | _RWSTD_IOS_TRUNC | _RWSTD_IOS_ATE             | _RWSTD_IOS_NOCREATE | _RWSTD_IOS_NOREPLACE)
N
N
N#if    !defined (_RWSTD_NO_STATIC_IOSTREAM_INIT)  \
N    && !defined (_RWSTD_NO_IOSTREAM_OBJECT_REFS)
X#if    !0L      && !0L
N   // standard iostream objects are references
N#  define _RWSTD_IOSTREAM_OBJECT(name)   &name
N#else
S   // standard iostream objects are declared to be real objects
S   // they may be implemented as real objects of the same type
S   // that get destroyed during program lifetime or as objects
S   // of some POD type that do not get destroyed at all
S#  define _RWSTD_IOSTREAM_OBJECT(name)   name
N#endif   //  _RWSTD_NO_STATIC_IOSTREAM_INIT && !_RWSTD_NO_IOSTREAM_OBJECT_REFS
N
N
N// exceptions can be completely disabled (bodies of catch blocks are still
N// compiled but will be removed by the optimizing stage of the compiler)
N// this approach reveals any errors even if _RWSTD_NO_EXCEPTIONS is #defined
N#ifndef _RWSTD_NO_EXCEPTIONS
S#  define _TRY           try
S#  define _CATCH(ex)     catch (ex)
S#  define _CATCH_T(ex)   catch (ex)
S#  define _THROW(ex)     throw ex
S#  define _RETHROW       throw
N#else   // if defined (_RWSTD_NO_EXCEPTIONS)
N#  define _TRY
N#  define _CATCH(ignore)   while (0)
N#  define _CATCH_T(type)   for (type; 0;) 
N#  define _THROW(ignore)   ((void)0)
N#  define _RETHROW         ((void)0)
N#endif   // _RWSTD_NO_EXCEPTIONS
N
N
N// for compilers that can't handle standard allocators we provide four
N// workarounds: _RWSTD_REBIND, used in place of _Allocator::rebind, allows
N// containers to use the same allocator for different data types
N// _RWSTD_ALLOC_TYPE is required to "rebind", or rather wrap,  the user
N// supplied non-conforming allocator in allocator_interface so that the
N// container need not be aware of the allocator's special properties (namely
N// the fact that the allocator allocates in terms of bytes rather than
N// elemements)
N//
N// _RWSTD_VALUE_ALLOC creates a temporary allocator_interface wrapper
N// from the given parameter (usually *this) when allocating values in
N// the sequence containers with non-conforming allocators.
N// _RWSTD_VALUE_ALLOC_CAST casts the given container to a reference to
N// a value allocator, allowing access to inherited allocator members
N// outside of the class.  For non-conforming compilers, this macro is
N// equivalent to _RWSTD_VALUE_ALLOC.
N//
N// NOTE: the spaces around type below are necessary to prevent errors
N//       if `to' is a template-id and the preprocessor doesn't put
N//       the spaces there automatically (GNU does, Sun does not)
N#ifdef _RWSTD_ALLOCATOR
N#  define _RWSTD_REBIND(from, to) \
N          _TYPENAME from::template rebind < to >::other
X#  define _RWSTD_REBIND(from, to)           _TYPENAME from::template rebind < to >::other
N#  define _RWSTD_ALLOC_TYPE(_Allocator, _ValueType)   _Allocator
N#  define _RWSTD_VALUE_ALLOC(ignore, call)            allocator_type::call
N#  define _RWSTD_VALUE_ALLOC_CAST(rvalue) \
N          _RWSTD_STATIC_CAST (allocator_type&, rvalue)
X#  define _RWSTD_VALUE_ALLOC_CAST(rvalue)           _RWSTD_STATIC_CAST (allocator_type&, rvalue)
N#else   // if !defined (_RWSTD_ALLOCATOR)
S#  define _RWSTD_REBIND(from, to) \
S          _STD_RW::allocator_interface < from, to >
X#  define _RWSTD_REBIND(from, to)           _STD_RW::allocator_interface < from, to >
S#  define _RWSTD_ALLOC_TYPE(_Allocator, _ValueType)   \
S          _RWSTD_REBIND (_Allocator, _ValueType)
X#  define _RWSTD_ALLOC_TYPE(_Allocator, _ValueType)             _RWSTD_REBIND (_Allocator, _ValueType)
S#  define _RWSTD_VALUE_ALLOC(type, call)      type(*this).call
S#  define _RWSTD_VALUE_ALLOC_CAST(rvalue)     _C_value_alloc_type(rvalue)
N#endif   // _RWSTD_ALLOCATOR
N
N
N// for compilers that can't deal with template functions parametrized
N// on the function's return type (as opposed to function arguments)
N//
N// NOTE: the spaces around type below are necessary to prevent errors
N//       if `type' is a template-id and the preprocessor doesn't put
N//       the spaces there automatically (GNU does, Sun does not)
N#ifndef _RWSTD_NO_TEMPLATE_ON_RETURN_TYPE
N#  define _STD_USE_FACET(type, arg)    _STD::use_facet < type >(arg)
N#  define _USE_FACET(type, arg)        use_facet < type >(arg)
N#  define _GET_TEMP_BUFFER(type, size) get_temporary_buffer < type >(size)
N#else   // if defined (_RWSTD_NO_TEMPLATE_ON_RETURN_TYPE)
S#  define _STD_USE_FACET(type, arg)    _STD::use_facet (arg, (type*)(0))
S#  define _USE_FACET(type, arg)        use_facet (arg, (type*)(0))
S#  define _GET_TEMP_BUFFER(type, size) get_temporary_buffer (size, (type*)0)
N#endif   // _RWSTD_NO_TEMPLATE_ON_RETURN_TYPE
N
N
N#ifndef _RWSTD_NO_NONCLASS_ARROW_RETURN
N   // expected signature: "_TypeT* operator->()"
N   // and/or:             "const _TypeT* operator->() const"
N#  define _RWSTD_OPERATOR_ARROW(signature) signature { return &**this; }
N#else
S#  define _RWSTD_OPERATOR_ARROW(ignore)
N#endif   // _RWSTD_NO_NONCLASS_ARROW_RETURN
N
N
N// to prevent warnings about unused arguments
N#define _RWSTD_UNUSED(arg)   ((void)&arg)
N
N
N// allows all externs to be declared/defined only in headers
N// and defined just by first #defining _RWSTD_DEFINE_EXTERNS
N// and then #including the header in a .cpp file
N#ifndef _RWSTD_DEFINE_EXTERNS
N#  define _RWSTD_EXTERN(decl, ignore)   extern decl
N#else
S#  define _RWSTD_EXTERN(decl, value)    extern decl = value
N#endif   // _RWSTD_DEFINE_EXTERNS
N
N
N// allows static const integral or enum class members to be initialized
N// inside the class and defined (w/o being initialized) outside
N// of the class (as required by 9.4.2, p4)
N#if !defined(_RWSTD_NO_STATIC_CONST_MEMBER_INIT)
X#if !0L
N#  define _RWSTD_STATIC_CONST(type, init)    static const type init
N#  define _RWSTD_DEFINE_STATIC_CONST(decl)   decl
N#else
S#  define _RWSTD_STATIC_CONST(ignore, init)  enum { init }
S#  define _RWSTD_DEFINE_STATIC_CONST(ignore)
N#endif   // _RWSTD_NO_STATIC_CONST_MEMBER_INIT
N
N
N// Selection of vendor dependent "format" string argument to wcsftime()
N#ifndef _RWSTD_NO_WCSFTIME
N   // 7.24.5.1 of C99 - wcsftime()'s 3rd arg is const wchar* [restrict]
N   //                   HP-UX 11 (and perhaps others) still uses const char*
N#  ifndef _RWSTD_NO_WCSFTIME_WCHAR_T_FMAT
N#     define _RWSTD_FMT_TYPE(arg)  const wchar_t* arg
N#     define _RWSTD_FMT_ASSGN(str) L##str
N#  else
S#     define _RWSTD_FMT_TYPE(arg)  const char* arg
S#     define _RWSTD_FMT_ASSGN(str) str
N#  endif
N#else   // if defined (_RWSTD_NO_WCSFTIME)
S#  define _RWSTD_FMT_TYPE(arg)     const char* arg
S#  define _RWSTD_FMT_ASSGN(str)    str
N#endif // _RWSTD_NO_WCSFTIME
N
N
N// _Iterator typedefs
N// (note that you must use a semi-colon at the end of this macro)
N#define _RWSTD_ITERATOR_TYPES(_Iterator)                               \
N     typedef _TYPENAME _Iterator::difference_type difference_type;     \
N     typedef _TYPENAME _Iterator::value_type value_type;               \
N     typedef _TYPENAME _Iterator::pointer pointer;                     \
N     typedef _TYPENAME _Iterator::reference reference;                 \
N     typedef _TYPENAME _Iterator::iterator_category iterator_category
X#define _RWSTD_ITERATOR_TYPES(_Iterator)                                    typedef _TYPENAME _Iterator::difference_type difference_type;          typedef _TYPENAME _Iterator::value_type value_type;                    typedef _TYPENAME _Iterator::pointer pointer;                          typedef _TYPENAME _Iterator::reference reference;                      typedef _TYPENAME _Iterator::iterator_category iterator_category
N
N// helpers making working w/o iterator_traits transparent
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N#  define _RWSTD_VALUE_TYPE(iterT) \
N       (_TYPENAME _STD::iterator_traits< iterT >::value_type*)0
X#  define _RWSTD_VALUE_TYPE(iterT)        (_TYPENAME _STD::iterator_traits< iterT >::value_type*)0
N#  define _RWSTD_DIFFERENCE_TYPE(iterT)   \
N       (_TYPENAME _STD::iterator_traits< iterT >::difference_type*)0
X#  define _RWSTD_DIFFERENCE_TYPE(iterT)          (_TYPENAME _STD::iterator_traits< iterT >::difference_type*)0
N#  define _RWSTD_ITERATOR_CATEGORY(iterT, ignore) \
N       _TYPENAME_CTOR _STD::iterator_traits< iterT >::iterator_category ()
X#  define _RWSTD_ITERATOR_CATEGORY(iterT, ignore)        _TYPENAME_CTOR _STD::iterator_traits< iterT >::iterator_category ()
N
N#else   // if defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
S
S#  define _RWSTD_VALUE_TYPE(iterT) __value_type ((iterT*)0)
S   // assume default ctor is defined and accessible
S#  define _RWSTD_DIFFERENCE_TYPE(iterT)   \
S       _STD::__distance_type (iterT ())
X#  define _RWSTD_DIFFERENCE_TYPE(iterT)          _STD::__distance_type (iterT ())
S   // macro cannot use the default ctor to construct a temporary
S   // with the type of the first argument since the default ctor
S   // may not exist or be accessible (e.g., istream_iterator<>)
S#  define _RWSTD_ITERATOR_CATEGORY(ignore, iter) \
S       _STD::__iterator_category (iter)
X#  define _RWSTD_ITERATOR_CATEGORY(ignore, iter)        _STD::__iterator_category (iter)
S
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N// Use -D_RWSTDDEBUG to compile a version of the libraries to debug
N// the user's code.  This will perform pre- and post-condition checks
N// upon entering routines, but will be larger and run more slowly.
N// This option affects the binary compatibility of generated code.
N
N
N#if defined(RWDEBUG) && !defined(_RWSTDDEBUG)
X#if 0L && !0L
S#  define _RWSTDDEBUG 1
N#endif
N
N
N#if defined(_RWSTDDEBUG) && _RWSTDDEBUG
X#if 0L && _RWSTDDEBUG
S#  define _RWSTD_ASSERT(expr)                                                \
S     ((expr) ? (void)0 : _RW::__rw_assert_fail (#expr, __MODULE__, __LINE__, \
S                                                __PRETTY_FUNCTION__))
X#  define _RWSTD_ASSERT(expr)                                                     ((expr) ? (void)0 : _RW::__rw_assert_fail (#expr, __MODULE__, __LINE__,                                                 __PRETTY_FUNCTION__))
N#else   //  if !defined (_RWSTDDEBUG)
N#  define _RWSTD_ASSERT(ignore)         ((void)0)
N#endif   // _RWSTDDEBUG
N
N// compile-time assertion - asserts constant expressions during
N// compilation with no runtime overhead; failed assertions are reported
N// as compilation errors
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
Ntemplate <bool __b>
Nstruct __rw_compile_assert;
N
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
Nstruct __rw_compile_assert<true> { enum { _C_ok }; };
N
N#define _RWSTD_COMPILE_ASSERT(const_expr) \
N        ((void)_RW::__rw_compile_assert<(const_expr)>::_C_ok)
X#define _RWSTD_COMPILE_ASSERT(const_expr)         ((void)_RW::__rw_compile_assert<(const_expr)>::_C_ok)
N
N// called for failed assertions
Nvoid _RWSTD_EXPORT
Xvoid 
N__rw_assert_fail (const char *__expr,
N                       const char *__file, int __line, const char *__func);
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N#  define _RWSTD_STR(x)       #x
N#  define _RWSTD_STRSTR(x)    _RWSTD_STR(x)
N
N#if defined(_RWSTDDEBUG) && _RWSTDDEBUG
X#if 0L && _RWSTDDEBUG
S#  define _RWSTD_FUNC(ignore) _RWSTD_FILE_LINE, __PRETTY_FUNCTION__
S#  define _RWSTD_FILE_LINE   __MODULE__ ":" _RWSTD_STRSTR (__LINE__)
N#else
N#  define _RWSTD_FUNC(ignore) _RWSTD_FILE_LINE, ""
N#  define _RWSTD_FILE_LINE   ""
N#endif
N
N/* at least some of the _RWSTD_REQUIRES are needed for conformance */
N#  define _RWSTD_REQUIRES(pred, args)   (pred) ? (void)0 : _RW::__rw_throw args
N
N// function exception specification
N#if    !defined (_RWSTD_NO_EXCEPTIONS) \
N    && !defined (_RWSTD_NO_EXCEPTION_SPECIFICATION)
X#if    !1L     && !0L
S   // type_id_list is a possibly empty parenthesized list
S   //of comma-separated type-id's
S#  define _THROWS(type_id_list)   throw type_id_list
N#else   // if _RWSTD_NO_EXCEPTIONS || _RWSTD_NO_EXCEPTION_SPECIFICATION
N#  define _THROWS(ignore)
N#endif   // !_RWSTD_NO_EXCEPTIONS && !_RWSTD_NO_EXCEPTION_SPECIFICATION
N
N
N// for convenience
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N#  define _DISTANCE(first, last, ignore) _STD_RW::distance (first, last)
N#else
S#  define _DISTANCE(first, last, type) _RW::__rw_distance (first, last, type())
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// pointers to the incomplete types declared below are used
N// to disambiguate calls to template member functions
N// bodies provided only to work around an HP aCC 3.14.10 bug
Ntemplate <bool __b>
Nstruct __rw_select { };
N
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
Nstruct __rw_select<true> { };
N
N#define _RWSTD_DISPATCH_INT(yes) const _RW::__rw_select < yes >*
N#define _RWSTD_DISPATCH(iter) \
N        ((_RW::__rw_select<numeric_limits< iter >::is_integer>*)0)
X#define _RWSTD_DISPATCH(iter)         ((_RW::__rw_select<numeric_limits< iter >::is_integer>*)0)
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N#if defined (__IBMCPP__) && __IBMCPP <= 500
X#if 0L && __IBMCPP <= 500
S
S// working around an xlC 5.0 bug
S_USING (__rw::__rw_select);
S
N#endif
N
N
N// select appropriate C multibyte conversion function based on
N// whether "restartable" functions are available.
N
N
N#ifndef _RWSTD_NO_MBRTOWC
N   // reentrant versions return size_t - see 7.24.6.3.2 of C99
N#  define _RWSTD_MBTOWC(to, from, size, state) mbrtowc (to, from, size, state)
N#elif !defined (_RWSTD_NO_MBTOWC)
S   // non-reentrant versions return int - see 7.20.7.2 of C99
S#  define _RWSTD_MBTOWC(to, from, size, ignore_state) \
S          _RWSTD_C::size_t (mbtowc(to, from, size))
X#  define _RWSTD_MBTOWC(to, from, size, ignore_state)           _RWSTD_C::size_t (mbtowc(to, from, size))
S#else
S   // mbtowc not supported
S#  define _RWSTD_MBTOWC(ign1, ign2, ign3, ign4) _RWSTD_C::size_t (-1)
N#endif   // _RWSTD_NO_MBRTOWC
N
N#ifndef _RWSTD_NO_WCRTOMB
N#  define _RWSTD_WCTOMB(to, from, state)       wcrtomb (to, from, state)
N#else   // if defined (_RWSTD_NO_WCRTOMB)
S#  define _RWSTD_WCTOMB(to, from, ignore_state) \
S          _RWSTD_C::size_t (wctomb (to, from))
X#  define _RWSTD_WCTOMB(to, from, ignore_state)           _RWSTD_C::size_t (wctomb (to, from))
N#endif   // _RWSTD_NO_WCRTOMB
N
N
N// unsafe when underlying libc doesn't support mbsinit
N// as described in 7.24.6.3.1 of C99
N#ifndef _RWSTD_NO_MBSINIT
N# if defined(SNI) && defined(_RWSTD_STRICT_ANSI)
X# if 0L && 0L
S#  define _MBSINIT(ps)   __SNI::mbsinit (ps)
N# else
N#  define _MBSINIT(ps)   mbsinit (ps)
N# endif
N#else   // if defined (_RWSTD_NO_MBSINIT)
S#  define _MBSINIT(ps)   (0 == (ps))
N#endif   // _RWSTD_NO_MBSINIT
N
N
N// enable only in debug mode and only id partial class specialization
N// is supported; prevent multiple definition of _RWSTD_NO_DEBUG_ITER
N#if    defined(_RWSTDDEBUG) && !defined (_RWSTD_NO_CLASS_PARTIAL_SPEC) \
N    && !defined (_RWSTD_NO_DEBUG_ITER) && !defined (SNI)
X#if    0L && !0L     && !0L && !0L
S#  define _RWSTD_ASSERT_RANGE(first, last) \
S      _RWSTD_ASSERT (_RW::__rw_valid_range (first, last))
X#  define _RWSTD_ASSERT_RANGE(first, last)       _RWSTD_ASSERT (_RW::__rw_valid_range (first, last))
S#  define _RWSTD_ASSERT_IN_RANGE(it, first, last) \
S      _RWSTD_ASSERT (_RW::__rw_in_range (it, first, last))
X#  define _RWSTD_ASSERT_IN_RANGE(it, first, last)       _RWSTD_ASSERT (_RW::__rw_in_range (it, first, last))
S#  define _RWSTD_ASSERT_DEREF(it) \
S      _RWSTD_ASSERT (_RW::__rw_dereferenceable (it))
X#  define _RWSTD_ASSERT_DEREF(it)       _RWSTD_ASSERT (_RW::__rw_dereferenceable (it))
N#else
N#  ifndef _RWSTD_NO_DEBUG_ITER
N#    define  _RWSTD_NO_DEBUG_ITER
N#  endif   // _RWSTD_NO_DEBUG_ITER
N
N#  define _RWSTD_ASSERT_RANGE(ign1, ign2)          ((void)0)
N#  define _RWSTD_ASSERT_IN_RANGE(ign1, ign2, ign3) ((void)0)
N#  define _RWSTD_ASSERT_DEREF(ignore)              ((void)0)
N#endif   // _RWSTDDEBUG && !_RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N// convenience macro to get the "real" iterator embedded in __rw_debug_iter<>
N#ifndef _RWSTD_NO_DEBUG_ITER
S#  define _ITER_BASE(it)   ((it).base ())
N#else   // if defined (_RWSTD_NO_DEBUG_ITER)
N#  define _ITER_BASE(it)   (it)
N#endif   // _RWSTD_NO_DEBUG_ITER
N
N
N// will use the deduced native type rather than the typedef to prevent
N// conflicts caused by inconsistent definition of wint_t (gcc 2.95.2/AIX)
N#ifndef _RWSTD_WINT_T
S   // hardcode if wint_t is not available in <wchar.h>
S   // used by std::traits and std::basic_[i|o]stream
S#  define _RWSTD_WINT_T int
N#endif   // _RWSTD_WINT_T
N
N
N// used by std::traits and std::basic_[i|o]stream,
N// required to be int by 21.1.3.1, p2
N#define _RWSTD_INT_T int
N
N
N// ssize_t is defined by POSIX.1
N#ifndef _RWSTD_SSIZE_T
N#  ifdef _WIN64
S#    define _RWSTD_SSIZE_T SSIZE_T
N#  else
N#    define _RWSTD_SSIZE_T long
N#  endif
N#endif
N
N
N#if defined(SNI)
X#if 0L
S#  define _RWSTD_USING_SNI(name) _USING(__SNI::name)
S#  if defined(_RWSTD_STRICT_ANSI)
S#    define fileno(p)       (int) ((p)->_file)
S#  endif
N#else
N#  define _RWSTD_USING_SNI(ignore)    typedef void __rw_unused_typedef
N#endif
N
N
N#ifndef _RWSTD_TMPBUF_SIZE
N#  define _RWSTD_TMPBUF_SIZE 4096
N#endif
N
N#ifndef _RWSTD_NO_STRTOLL
N#  define _STRTOLL           strtoll
N#else
S   // libc has no strtoll, use strtol instead
S#  define _STRTOLL           (_RWSTD_LONG_LONG)strtol
N#endif   // _RWSTD_NO_STRTOLL
N
N
N#ifndef _RWSTD_NO_STRTOULL
N#  define _STRTOULL          strtoull
N#else
S   // libc has no strtoull, use strtoul instead
S#  define _STRTOULL          (unsigned _RWSTD_LONG_LONG)strtoul
N#endif   // _RWSTD_NO_STRTOULL
N
N
N#if     defined (_RWSTD_INSTANTIATE_TEMPLATES)       \
N    && !defined (_RWSTD_NO_EXPLICIT_INSTANTIATION)   \
N    && !defined (_RWSTD_NO_INSTANTIATE)
X#if     0L           && !0L       && !0L
S#  define _RWSTD_INSTANTIATE_1(arg)          template arg
S#  define _RWSTD_INSTANTIATE_2(a1, a2)       template a1, a2
S#  define _RWSTD_INSTANTIATE_3(a1, a2, a3)   template a1, a2, a3
N#else
N#  if    defined (_MSC_VER)                          \
N      && !defined (_RWSTD_NO_EXPLICIT_INSTANTIATION) \
N      && !defined (_RWSTD_NO_INSTANTIATE)
X#  if    0L                                && !0L       && !0L
S     // disable warning C4231: nonstandard extension used :
S     //         'extern' before template explicit instantiation
S#    pragma warning (disable: 4231)
S#    define _RWSTD_INSTANTIATE_1(arg)        extern template arg
S#    define _RWSTD_INSTANTIATE_2(a1, a2)     extern template a1, a2
S#    define _RWSTD_INSTANTIATE_3(a1, a2, a3) extern template a1, a2, a3
N#  else
N#    define _RWSTD_INSTANTIATE_1(ignore)           \
N            typedef void __rw_unused_typedef
X#    define _RWSTD_INSTANTIATE_1(ignore)                       typedef void __rw_unused_typedef
N#    define _RWSTD_INSTANTIATE_2(ign1, ign2)       \
N            typedef void __rw_unused_typedef
X#    define _RWSTD_INSTANTIATE_2(ign1, ign2)                   typedef void __rw_unused_typedef
N#    define _RWSTD_INSTANTIATE_3(ign1, ign2, ign3) \
N            typedef void __rw_unused_typedef
X#    define _RWSTD_INSTANTIATE_3(ign1, ign2, ign3)             typedef void __rw_unused_typedef
N#  endif
N#endif   // _RWSTD_INSTANTIATE_TEMPLATES
N
N
N#ifndef _RWSTD_NO_UNCAUGHT_EXCEPTION
S#  define _UNCAUGHT_EXCEPTION()   uncaught_exception()
N#else   // if defined (_RWSTD_NO_UNCAUGHT_EXCEPTION)
N#  define _UNCAUGHT_EXCEPTION()   true
N#endif   // _RWSTD_NO_UNCAUGHT_EXCEPTION
N
N// allows for efficient compilation without implicit inclusion; only
N// specializations explicitly instantiated in the library are available
N#if     defined _RWSTD_COMPILE_INSTANTIATE               \
N    && (   !defined (_RWSTD_NO_TEMPLATE_DEFINITIONS)     \
N        ||  defined (_RWSTD_NO_EXPLICIT_INSTANTIATION)   \
N        ||  defined (_RWSTD_NO_IMPLICIT_INSTANTIATION)   \
N        ||  defined (_RWSTD_NO_INSTANTIATE))
X#if     0L                   && (   !0L             ||  0L           ||  0L           ||  0L)
S#  define _RWSTD_DEFINE_TEMPLATE(name)     !(_RWSTD_NO_ ## name ## _DEFINITION)
N#else
N#  define _RWSTD_DEFINE_TEMPLATE(ignore)   0
N#endif
N
N
N// introduce namespace std so that "using namespace std;" always works
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N_RWSTD_NAMESPACE_END   // std
X}   
N
N#ifndef _RWSTD_NO_NAMESPACE
N#ifdef __EDG_IMPLICIT_USING_STD 
S/* Implicitly include a using directive for the STD namespace when this */ 
S/* preprocessing flag is TRUE. */ 
Susing namespace ::std; 
N#endif /* ifdef __EDG_IMPLICIT_USING_STD */ 
N#endif /* _RWSTD_NO_NAMESPACE */
N
N#endif   // _RWSTD_DEFS_H_INCLUDED
N
L 36 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\limits" 2
N#include <rw/_math.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_math.h" 1
N/***************************************************************************
N *
N * _math.h - Standard Library vs math.h exception conflict hack.
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id: _math.h 172106 2011-11-02 17:04:12Z statham $
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N ***************************************************************************/
N
N#ifndef _RWSTD_MATH_H_INCLUDED
N#define _RWSTD_MATH_H_INCLUDED
N
N#include <rw/_defs.h>
N
N// avoid a conflicting exception structure on platforms where
N// struct exception is defined unguarded in <math.h>
N#ifndef _RWSTD_NO_MATH_EXCEPTION
S#  undef exception
S#  define exception math_exception
N#endif   // _RWSTD_NO_MATH_EXCEPTION
N
N#include _RWSTD_CMATH
X#include <cmath>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cmath" 1
N/*
N * C++ header for C header math.h
N * Copyright 1997 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision: 177844 $
N * Checkin $Date: 2012-11-21 11:51:12 +0000 (Wed, 21 Nov 2012) $
N * Revising $Author: pwright $
N */
N
N#ifndef __cmath
N#define __cmath
N#define __ARMCLIB_VERSION 5050106
N
N  #define __MATH_NO_EXPORTS 1
N  #include <math.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\math.h" 1
N/*
N * math.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.5
N * Copyright (C) Codemist Ltd., 1988
N * Copyright 1991-1998,2004-2006,2014 ARM Limited. All rights reserved
N */
N
N/*
N * RCS $Revision: 185525 $ Codemist 0.03
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: statham $
N */
N
N/*
N * Parts of this file are based upon fdlibm:
N *
N * ====================================================
N * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
N *
N * Developed at SunSoft, a Sun Microsystems, Inc. business.
N * Permission to use, copy, modify, and distribute this
N * software is freely granted, provided that this notice
N * is preserved.
N * ====================================================
N */
N
N#ifndef __math_h
N#define __math_h
N#define __ARMCLIB_VERSION 5050106
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N/*
N * Some of these declarations are new in C99.  To access them in C++
N * you can use -D__USE_C99_MATH (or -D__USE_C99_ALL).
N */
N#ifndef __USE_C99_MATH
N  #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X  #if 0L || (0L && 199901L <= __STDC_VERSION__)
S    #define __USE_C99_MATH 1
N  #endif
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#ifdef __TARGET_ARCH_AARCH64
S# define _ARMABI_SOFTFP __declspec(__nothrow)
N#else
N# define _ARMABI_SOFTFP __declspec(__nothrow) __attribute__((__pcs__("aapcs")))
N# define __HAVE_LONGDOUBLE 1
N#endif
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#ifdef __FP_FENV_EXCEPTIONS
S# define _ARMABI_FPEXCEPT _ARMABI
N#else
N# define _ARMABI_FPEXCEPT _ARMABI __attribute__((const))
N#endif
N
N#ifdef __cplusplus
N#define _ARMABI_INLINE inline
N#define _ARMABI_INLINE_DEF inline
N#elif defined __GNUC__ || defined _USE_STATIC_INLINE
S#define _ARMABI_INLINE static __inline
S#define _ARMABI_INLINE_DEF static __inline
S#elif (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF static inline
S#else
S#define _ARMABI_INLINE __inline
S#define _ARMABI_INLINE_DEF __inline
N#endif
N
N#ifdef __TARGET_ARCH_AARCH64
S#  define _SOFTFP
N#else
N#  define _SOFTFP __attribute__((__pcs__("aapcs")))
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain the nans function, as well as the
N    * FP_NANS and FP_NANQ classification macros.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
N/*
N * Macros for our inline functions down below.
N * unsigned& __FLT(float x) - returns the bit pattern of x
N * unsigned& __HI(double x) - returns the bit pattern of the high part of x
N *                            (high part has exponent & sign bit in it)
N * unsigned& __LO(double x) - returns the bit pattern of the low part of x
N *
N * We can assign to __FLT, __HI, and __LO and the appropriate bits get set in
N * the floating point variable used.
N *
N * __HI & __LO are affected by the endianness and the target FPU.
N */
N#define __FLT(x) (*(unsigned *)&(x))
N#if defined(__ARM_BIG_ENDIAN) || defined(__BIG_ENDIAN)
X#if 0L || 0L
S#  define __LO(x) (*(1 + (unsigned *)&(x)))
S#  define __HI(x) (*(unsigned *)&(x))
N#else /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N#  define __HI(x) (*(1 + (unsigned *)&(x)))
N#  define __LO(x) (*(unsigned *)&(x))
N#endif /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N
N#   ifndef __MATH_DECLS
N#   define __MATH_DECLS
N
N
N/*
N * A set of functions that we don't actually want to put in the standard
N * namespace ever.  These are all called by the C99 macros.  As they're
N * not specified by any standard they can't belong in ::std::.  The
N * macro #defines are below amongst the standard function declarations.
N * We only include these if we actually need them later on
N */
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N#   ifdef __cplusplus
N      extern "C" {
N#   endif /* __cplusplus */
N
Nextern _SOFTFP unsigned __ARM_dcmp4(double /*x*/, double /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_dcmp4(double  , double  );
Nextern _SOFTFP unsigned __ARM_fcmp4(float /*x*/, float /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_fcmp4(float  , float  );
N    /*
N     * Compare x and y and return the CPSR in r0.  These means we can test for
N     * result types with bit pattern matching.
N     *
N     * These are a copy of the declarations in rt_fp.h keep in sync.
N     */
N
Nextern _ARMABI_SOFTFP int __ARM_fpclassifyf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassifyf(float  );
Nextern _ARMABI_SOFTFP int __ARM_fpclassify(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassify(double  );
N    /* Classify x into NaN, infinite, normal, subnormal, zero */
N    /* Used by fpclassify macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinitef(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinitef(float __x)
N{
N    return ((__FLT(__x) >> 23) & 0xff) != 0xff;
X    return (((*(unsigned *)&(__x)) >> 23) & 0xff) != 0xff;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinite(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinite(double __x)
N{
N    return ((__HI(__x) >> 20) & 0x7ff) != 0x7ff;
X    return (((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff) != 0x7ff;
N}
N    /* Return 1 if __x is finite, 0 otherwise */
N    /* Used by isfinite macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinff(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinff(float __x)
N{
N    return (__FLT(__x) << 1) == 0xff000000;
X    return ((*(unsigned *)&(__x)) << 1) == 0xff000000;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinf(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinf(double __x)
N{
N    return ((__HI(__x) << 1) == 0xffe00000) && (__LO(__x) == 0);
X    return (((*(1 + (unsigned *)&(__x))) << 1) == 0xffe00000) && ((*(unsigned *)&(__x)) == 0);
N}
N    /* Return 1 if __x is infinite, 0 otherwise */
N    /* Used by isinf macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreaterf(float __x, float __y)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreaterf(float __x, float __y)
N{
N    unsigned __f = __ARM_fcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreater(double __x, double __y)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreater(double __x, double __y)
N{
N    unsigned __f = __ARM_dcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N    /*
N     * Compare __x and __y and return 1 if __x < __y or __x > __y, 0 otherwise
N     * Used by islessgreater macro
N     */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnanf(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnanf(float __x)
N{
N    return (0x7f800000 - (__FLT(__x) & 0x7fffffff)) >> 31;
X    return (0x7f800000 - ((*(unsigned *)&(__x)) & 0x7fffffff)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnan(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnan(double __x)
N{
N    unsigned __xf = __HI(__x) | ((__LO(__x) == 0) ? 0 : 1);
X    unsigned __xf = (*(1 + (unsigned *)&(__x))) | (((*(unsigned *)&(__x)) == 0) ? 0 : 1);
N    return (0x7ff00000 - (__xf & 0x7fffffff)) >> 31;
N}
N    /* Return 1 if __x is a NaN, 0 otherwise */
N    /* Used by isnan macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormalf(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormalf(float __x)
N{
N    unsigned __xe = (__FLT(__x) >> 23) & 0xff;
X    unsigned __xe = ((*(unsigned *)&(__x)) >> 23) & 0xff;
N    return (__xe != 0xff) && (__xe != 0);
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormal(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormal(double __x)
N{
N    unsigned __xe = (__HI(__x) >> 20) & 0x7ff;
X    unsigned __xe = ((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff;
N    return (__xe != 0x7ff) && (__xe != 0);
N}
N    /* Return 1 if __x is a normalised number, 0 otherwise */
N    /* used by isnormal macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbitf(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbitf(float __x)
N{
N    return __FLT(__x) >> 31;
X    return (*(unsigned *)&(__x)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbit(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbit(double __x)
N{
N    return __HI(__x) >> 31;
X    return (*(1 + (unsigned *)&(__x))) >> 31;
N}
N    /* Return signbit of __x */
N    /* Used by signbit macro */
N
N#   ifdef __cplusplus
N      } /* extern "C" */
N#   endif /* __cplusplus */
N#endif /* Strict ANSI */
N
N#   undef __CLIBNS
N
N#   ifdef __cplusplus
N      namespace std {
N#       define __CLIBNS ::std::
N        extern "C" {
N#   else
S#       define __CLIBNS
N#   endif  /* __cplusplus */
N
N
N#ifndef __has_builtin
N  #define __has_builtin(x) 0
N#endif
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N  /* C99 additions */
N  typedef float float_t;
N  typedef double double_t;
N#if __has_builtin(__builtin_inf)
X#if 0
S#   define HUGE_VALF __builtin_inff()
S#   define HUGE_VALL __builtin_infl()
S#   define INFINITY __builtin_inff()
S#   define NAN __builtin_nanf("")
N# else
N#   define HUGE_VALF ((float)__INFINITY__)
N#   define HUGE_VALL ((long double)__INFINITY__)
N#   define INFINITY ((float)__INFINITY__)
N#   define NAN (__ESCAPE__(0f_7FC00000))
N#endif
N
N#   define MATH_ERRNO 1
N#   define MATH_ERREXCEPT 2
Nextern const int math_errhandling;
N#endif
N#if __has_builtin(__builtin_inf)
X#if 0
S# define HUGE_VAL __builtin_inf()
N#else
N# define HUGE_VAL ((double)__INFINITY__)
N#endif
N
Nextern _ARMABI double acos(double /*x*/);
Xextern __declspec(__nothrow) double acos(double  );
N   /* computes the principal value of the arc cosine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* Returns: the arc cosine in the range 0 to Pi. */
Nextern _ARMABI double asin(double /*x*/);
Xextern __declspec(__nothrow) double asin(double  );
N   /* computes the principal value of the arc sine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* and -HUGE_VAL is returned. */
N   /* Returns: the arc sine in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI_PURE double atan(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double atan(double  );
N   /* computes the principal value of the arc tangent of x */
N   /* Returns: the arc tangent in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI double atan2(double /*y*/, double /*x*/);
Xextern __declspec(__nothrow) double atan2(double  , double  );
N   /* computes the principal value of the arc tangent of y/x, using the */
N   /* signs of both arguments to determine the quadrant of the return value */
N   /* a domain error occurs if both args are zero, and -HUGE_VAL returned. */
N   /* Returns: the arc tangent of y/x, in the range -Pi to Pi. */
N
Nextern _ARMABI double cos(double /*x*/);
Xextern __declspec(__nothrow) double cos(double  );
N   /* computes the cosine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the cosine value. */
Nextern _ARMABI double sin(double /*x*/);
Xextern __declspec(__nothrow) double sin(double  );
N   /* computes the sine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the sine value. */
N
Nextern void __use_accurate_range_reduction(void);
N   /* reference this to select the larger, slower, but more accurate */
N   /* range reduction in sin, cos and tan */
N
Nextern _ARMABI double tan(double /*x*/);
Xextern __declspec(__nothrow) double tan(double  );
N   /* computes the tangent of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance */
N   /* Returns: the tangent value. */
N   /*          if range error; returns HUGE_VAL. */
N
Nextern _ARMABI double cosh(double /*x*/);
Xextern __declspec(__nothrow) double cosh(double  );
N   /* computes the hyperbolic cosine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic cosine value. */
N   /*          if range error; returns HUGE_VAL. */
Nextern _ARMABI double sinh(double /*x*/);
Xextern __declspec(__nothrow) double sinh(double  );
N   /* computes the hyperbolic sine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic sine value. */
N   /*          if range error; returns -HUGE_VAL or HUGE_VAL depending */
N   /*          on the sign of the argument */
N
Nextern _ARMABI_PURE double tanh(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double tanh(double  );
N   /* computes the hyperbolic tangent of x. */
N   /* Returns: the hyperbolic tangent value. */
N
Nextern _ARMABI double exp(double /*x*/);
Xextern __declspec(__nothrow) double exp(double  );
N   /* computes the exponential function of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the exponential value. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
N
Nextern _ARMABI double frexp(double /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double frexp(double  , int *  ) __attribute__((__nonnull__(2)));
N   /* breaks a floating-point number into a normalised fraction and an */
N   /* integral power of 2. It stores the integer in the int object pointed */
N   /* to by exp. */
N   /* Returns: the value x, such that x is a double with magnitude in the */
N   /* interval 0.5 to 1.0 or zero, and value equals x times 2 raised to the */
N   /* power *exp. If value is zero, both parts of the result are zero. */
N
Nextern _ARMABI double ldexp(double /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) double ldexp(double  , int  );
N   /* multiplies a floating-point number by an integral power of 2. */
N   /* A range error may occur. */
N   /* Returns: the value of x times 2 raised to the power of exp. */
N   /*          if range error; HUGE_VAL is returned. */
Nextern _ARMABI double log(double /*x*/);
Xextern __declspec(__nothrow) double log(double  );
N   /* computes the natural logarithm of x. A domain error occurs if the */
N   /* argument is negative, and -HUGE_VAL is returned. A range error occurs */
N   /* if the argument is zero. */
N   /* Returns: the natural logarithm. */
N   /*          if range error; -HUGE_VAL is returned. */
Nextern _ARMABI double log10(double /*x*/);
Xextern __declspec(__nothrow) double log10(double  );
N   /* computes the base-ten logarithm of x. A domain error occurs if the */
N   /* argument is negative. A range error occurs if the argument is zero. */
N   /* Returns: the base-ten logarithm. */
Nextern _ARMABI double modf(double /*value*/, double * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double modf(double  , double *  ) __attribute__((__nonnull__(2)));
N   /* breaks the argument value into integral and fraction parts, each of */
N   /* which has the same sign as the argument. It stores the integral part */
N   /* as a double in the object pointed to by iptr. */
N   /* Returns: the signed fractional part of value. */
N
Nextern _ARMABI double pow(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double pow(double  , double  );
N   /* computes x raised to the power of y. A domain error occurs if x is */
N   /* zero and y is less than or equal to zero, or if x is negative and y */
N   /* is not an integer, and -HUGE_VAL returned. A range error may occur. */
N   /* Returns: the value of x raised to the power of y. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
Nextern _ARMABI double sqrt(double /*x*/);
Xextern __declspec(__nothrow) double sqrt(double  );
N   /* computes the non-negative square root of x. A domain error occurs */
N   /* if the argument is negative, and -HUGE_VAL returned. */
N   /* Returns: the value of the square root. */
N
N#if defined(__TARGET_FPU_VFP_DOUBLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !0L
S    _ARMABI_INLINE double _sqrt(double __x) { return __sqrt(__x); }
N#else
N    _ARMABI_INLINE double _sqrt(double __x) { return sqrt(__x); }
X    inline double _sqrt(double __x) { return sqrt(__x); }
N#endif
N#if defined(__TARGET_FPU_VFP_SINGLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 1L && !0L
N    _ARMABI_INLINE float _sqrtf(float __x) { return __sqrtf(__x); }
X    inline float _sqrtf(float __x) { return __sqrtf(__x); }
N#else
S    _ARMABI_INLINE float _sqrtf(float __x) { return (float)sqrt(__x); }
N#endif
N    /* With VFP, _sqrt and _sqrtf should expand inline as the native VFP square root
N     * instructions. They will not behave like the C sqrt() function, because
N     * they will report unusual values as IEEE exceptions (in fpmodes which
N     * support IEEE exceptions) rather than in errno. These function names
N     * are not specified in any standard. */
N
Nextern _ARMABI_PURE double ceil(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double ceil(double  );
N   /* computes the smallest integer not less than x. */
N   /* Returns: the smallest integer not less than x, expressed as a double. */
Nextern _ARMABI_PURE double fabs(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fabs(double  );
N   /* computes the absolute value of the floating-point number x. */
N   /* Returns: the absolute value of x. */
N
Nextern _ARMABI_PURE double floor(double /*d*/);
Xextern __declspec(__nothrow) __attribute__((const)) double floor(double  );
N   /* computes the largest integer not greater than x. */
N   /* Returns: the largest integer not greater than x, expressed as a double */
N
Nextern _ARMABI double fmod(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fmod(double  , double  );
N   /* computes the floating-point remainder of x/y. */
N   /* Returns: the value x - i * y, for some integer i such that, if y is */
N   /*          nonzero, the result has the same sign as x and magnitude */
N   /*          less than the magnitude of y. If y is zero, a domain error */
N   /*          occurs and -HUGE_VAL is returned. */
N
N    /* Additional Mathlib functions not defined by the ANSI standard.
N     * Not guaranteed, and not necessarily very well tested.
N     * C99 requires the user to include <math.h> to use these functions
N     * declaring them "by hand" is not sufficient
N     *
N     * The above statement is not completely true now.  Some of the above
N     * C99 functionality has been added as per the Standard, and (where
N     * necessary) old Mathlib functionality withdrawn/changed.  Before
N     * including this header #define __ENABLE_MATHLIB_LEGACY if you want to
N     * re-enable the legacy functionality.
N     */
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N
Nextern _ARMABI double acosh(double /*x*/);
Xextern __declspec(__nothrow) double acosh(double  );
N    /*
N     * Inverse cosh. EDOM if argument < 1.0
N     */
Nextern _ARMABI double asinh(double /*x*/);
Xextern __declspec(__nothrow) double asinh(double  );
N    /*
N     * Inverse sinh.
N     */
Nextern _ARMABI double atanh(double /*x*/);
Xextern __declspec(__nothrow) double atanh(double  );
N    /*
N     * Inverse tanh. EDOM if |argument| > 1.0
N     */
Nextern _ARMABI double cbrt(double /*x*/);
Xextern __declspec(__nothrow) double cbrt(double  );
N    /*
N     * Cube root.
N     */
N_ARMABI_INLINE _ARMABI_PURE double copysign(double __x, double __y)
Xinline __declspec(__nothrow) __attribute__((const)) double copysign(double __x, double __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __HI(__x) = (__HI(__x) & 0x7fffffff) | (__HI(__y) & 0x80000000);
X    (*(1 + (unsigned *)&(__x))) = ((*(1 + (unsigned *)&(__x))) & 0x7fffffff) | ((*(1 + (unsigned *)&(__y))) & 0x80000000);
N    return __x;
N}
N_ARMABI_INLINE _ARMABI_PURE float copysignf(float __x, float __y)
Xinline __declspec(__nothrow) __attribute__((const)) float copysignf(float __x, float __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __FLT(__x) = (__FLT(__x) & 0x7fffffff) | (__FLT(__y) & 0x80000000);
X    (*(unsigned *)&(__x)) = ((*(unsigned *)&(__x)) & 0x7fffffff) | ((*(unsigned *)&(__y)) & 0x80000000);
N    return __x;
N}
Nextern _ARMABI double erf(double /*x*/);
Xextern __declspec(__nothrow) double erf(double  );
N    /*
N     * Error function. (2/sqrt(pi)) * integral from 0 to x of exp(-t*t) dt.
N     */
Nextern _ARMABI double erfc(double /*x*/);
Xextern __declspec(__nothrow) double erfc(double  );
N    /*
N     * 1-erf(x). (More accurate than just coding 1-erf(x), for large x.)
N     */
Nextern _ARMABI double expm1(double /*x*/);
Xextern __declspec(__nothrow) double expm1(double  );
N    /*
N     * exp(x)-1. (More accurate than just coding exp(x)-1, for small x.)
N     */
N#define fpclassify(x) \
N    ((sizeof(x) == sizeof(float)) ? \
N        __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
X#define fpclassify(x)     ((sizeof(x) == sizeof(float)) ?         __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
N    /*
N     * Classify a floating point number into one of the following values:
N     */
N#define FP_ZERO         (0)
N#define FP_SUBNORMAL    (4)
N#define FP_NORMAL       (5)
N#define FP_INFINITE     (3)
N#define FP_NAN          (7)
N
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
S/* 
S * Note that we'll never classify a number as FP_NAN, as all NaNs will 
S * be either FP_NANQ or FP_NANS
S */
S#  define FP_NANQ       (8)
S#  define FP_NANS       (9)
N#endif
N
N
Nextern _ARMABI double hypot(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double hypot(double  , double  );
N    /*
N     * sqrt(x*x+y*y), ie the length of the vector (x,y) or the
N     * hypotenuse of a right triangle whose other two sides are x
N     * and y. Won't overflow unless the _answer_ is too big, even
N     * if the intermediate x*x+y*y is too big.
N     */
Nextern _ARMABI int ilogb(double /*x*/);
Xextern __declspec(__nothrow) int ilogb(double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
Nextern _ARMABI int ilogbf(float /*x*/);
Xextern __declspec(__nothrow) int ilogbf(float  );
N    /*
N     * Like ilogb but takes a float
N     */
Nextern _ARMABI int ilogbl(long double /*x*/);
Xextern __declspec(__nothrow) int ilogbl(long double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
N#define FP_ILOGB0   (-0x7fffffff) /* ilogb(0) == -INT_MAX */
N#define FP_ILOGBNAN ( 0x80000000) /* ilogb(NAN) == INT_MIN */
N
N#define isfinite(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isfinitef(x) \
N        : __ARM_isfinite(x))
X#define isfinite(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isfinitef(x)         : __ARM_isfinite(x))
N    /*
N     * Returns true if x is a finite number, size independent.
N     */
N
N#define isgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
X#define isgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
N    /*
N     * Returns true if x > y, throws no exceptions except on Signaling NaNs
N     *
N     * We want the C not set but the Z bit clear, V must be clear
N     */
N
N#define isgreaterequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
X#define isgreaterequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
N    /*
N     * Returns true if x >= y, throws no exceptions except on Signaling NaNs
N     *
N     * We just need to see if the C bit is set or not and ensure V clear
N     */
N
N#define isinf(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isinff(x) \
N        : __ARM_isinf(x))
X#define isinf(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isinff(x)         : __ARM_isinf(x))
N    /*
N     * Returns true if x is an infinity, size independent.
N     */
N
N#define isless(x, y)  \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
X#define isless(x, y)      (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
N    /*
N     * Returns true if x < y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than if N is set, V clear
N     */
N
N#define islessequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0) \
N        : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
X#define islessequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0)         : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
N    /*
N     * Returns true if x <= y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than or equal if one of N or Z is set, V clear
N     */
N
N#define islessgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? __ARM_islessgreaterf((x), (y)) \
N        : __ARM_islessgreater((x), (y)))
X#define islessgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? __ARM_islessgreaterf((x), (y))         : __ARM_islessgreater((x), (y)))
N    /*
N     * Returns true if x <> y, throws no exceptions except on Signaling NaNs
N     * Unfortunately this test is too complicated to do in a macro without
N     * evaluating x & y twice.  Shame really...
N     */
N
N#define isnan(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnanf(x) \
N        : __ARM_isnan(x))
X#define isnan(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnanf(x)         : __ARM_isnan(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isnormal(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnormalf(x) \
N        : __ARM_isnormal(x))
X#define isnormal(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnormalf(x)         : __ARM_isnormal(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isunordered(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
X#define isunordered(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000)         : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
N    /*
N     * Returns true if x ? y, throws no exceptions except on Signaling NaNs
N     * Unordered occurs if and only if the V bit is set
N     */
N
Nextern _ARMABI double lgamma (double /*x*/);
Xextern __declspec(__nothrow) double lgamma (double  );
N    /*
N     * The log of the absolute value of the gamma function of x. The sign
N     * of the gamma function of x is returned in the global `signgam'.
N     */
Nextern _ARMABI double log1p(double /*x*/);
Xextern __declspec(__nothrow) double log1p(double  );
N    /*
N     * log(1+x). (More accurate than just coding log(1+x), for small x.)
N     */
Nextern _ARMABI double logb(double /*x*/);
Xextern __declspec(__nothrow) double logb(double  );
N    /*
N     * Like ilogb but returns a double.
N     */
Nextern _ARMABI float logbf(float /*x*/);
Xextern __declspec(__nothrow) float logbf(float  );
N    /*
N     * Like logb but takes and returns float
N     */
Nextern _ARMABI long double logbl(long double /*x*/);
Xextern __declspec(__nothrow) long double logbl(long double  );
N    /*
N     * Like logb but takes and returns long double
N     */
Nextern _ARMABI double nextafter(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double nextafter(double  , double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nextafterf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float nextafterf(float  , float  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nextafterl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nextafterl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double nexttoward(double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) double nexttoward(double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nexttowardf(float /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) float nexttowardf(float  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nexttowardl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nexttowardl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double remainder(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double remainder(double  , double  );
N    /*
N     * Returns the remainder of x by y, in the IEEE 754 sense.
N     */
Nextern _ARMABI_FPEXCEPT double rint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double rint(double  );
N    /*
N     * Rounds x to an integer, in the IEEE 754 sense.
N     */
Nextern _ARMABI double scalbln(double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) double scalbln(double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalblnf(float /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) float scalblnf(float  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalblnl(long double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) long double scalblnl(long double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI double scalbn(double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) double scalbn(double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalbnf(float /*x*/, int /*n*/);
Xextern __declspec(__nothrow) float scalbnf(float  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalbnl(long double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) long double scalbnl(long double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
N#define signbit(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_signbitf(x) \
N        : __ARM_signbit(x))
X#define signbit(x)     ((sizeof(x) == sizeof(float))         ? __ARM_signbitf(x)         : __ARM_signbit(x))
N    /*
N     * Returns the signbit of x, size independent macro
N     */
N#endif
N
N/* C99 float versions of functions.  math.h has always reserved these
N   identifiers for this purpose (7.13.4). */
Nextern _ARMABI_PURE float _fabsf(float); /* old ARM name */
Xextern __declspec(__nothrow) __attribute__((const)) float _fabsf(float);  
N_ARMABI_INLINE _ARMABI_PURE float fabsf(float __f) { return _fabsf(__f); }
Xinline __declspec(__nothrow) __attribute__((const)) float fabsf(float __f) { return _fabsf(__f); }
Nextern _ARMABI float sinf(float /*x*/);
Xextern __declspec(__nothrow) float sinf(float  );
Nextern _ARMABI float cosf(float /*x*/);
Xextern __declspec(__nothrow) float cosf(float  );
Nextern _ARMABI float tanf(float /*x*/);
Xextern __declspec(__nothrow) float tanf(float  );
Nextern _ARMABI float acosf(float /*x*/);
Xextern __declspec(__nothrow) float acosf(float  );
Nextern _ARMABI float asinf(float /*x*/);
Xextern __declspec(__nothrow) float asinf(float  );
Nextern _ARMABI float atanf(float /*x*/);
Xextern __declspec(__nothrow) float atanf(float  );
Nextern _ARMABI float atan2f(float /*y*/, float /*x*/);
Xextern __declspec(__nothrow) float atan2f(float  , float  );
Nextern _ARMABI float sinhf(float /*x*/);
Xextern __declspec(__nothrow) float sinhf(float  );
Nextern _ARMABI float coshf(float /*x*/);
Xextern __declspec(__nothrow) float coshf(float  );
Nextern _ARMABI float tanhf(float /*x*/);
Xextern __declspec(__nothrow) float tanhf(float  );
Nextern _ARMABI float expf(float /*x*/);
Xextern __declspec(__nothrow) float expf(float  );
Nextern _ARMABI float logf(float /*x*/);
Xextern __declspec(__nothrow) float logf(float  );
Nextern _ARMABI float log10f(float /*x*/);
Xextern __declspec(__nothrow) float log10f(float  );
Nextern _ARMABI float powf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float powf(float  , float  );
Nextern _ARMABI float sqrtf(float /*x*/);
Xextern __declspec(__nothrow) float sqrtf(float  );
Nextern _ARMABI float ldexpf(float /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) float ldexpf(float  , int  );
Nextern _ARMABI float frexpf(float /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float frexpf(float  , int *  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI_PURE float ceilf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float ceilf(float  );
Nextern _ARMABI_PURE float floorf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float floorf(float  );
Nextern _ARMABI float fmodf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fmodf(float  , float  );
Nextern _ARMABI float modff(float /*value*/, float * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float modff(float  , float *  ) __attribute__((__nonnull__(2)));
N
N/* C99 long double versions of functions. */
N/* (also need to have 'using' declarations below) */
N#define _ARMDEFLD1(f) \
N    _ARMABI long double f##l(long double /*x*/)
X#define _ARMDEFLD1(f)     _ARMABI long double f##l(long double  )
N
N#define _ARMDEFLD1P(f, T) \
N    _ARMABI long double f##l(long double /*x*/, T /*p*/)
X#define _ARMDEFLD1P(f, T)     _ARMABI long double f##l(long double  , T  )
N
N#define _ARMDEFLD2(f) \
N    _ARMABI long double f##l(long double /*x*/, long double /*y*/)
X#define _ARMDEFLD2(f)     _ARMABI long double f##l(long double  , long double  )
N
N/*
N * Long double versions of C89 functions can be defined
N * unconditionally, because C89 reserved these names in "future
N * library directions".
N */
N_ARMDEFLD1(acos);
X__declspec(__nothrow) long double acosl(long double );
N_ARMDEFLD1(asin);
X__declspec(__nothrow) long double asinl(long double );
N_ARMDEFLD1(atan);
X__declspec(__nothrow) long double atanl(long double );
N_ARMDEFLD2(atan2);
X__declspec(__nothrow) long double atan2l(long double , long double );
N_ARMDEFLD1(ceil);
X__declspec(__nothrow) long double ceill(long double );
N_ARMDEFLD1(cos);
X__declspec(__nothrow) long double cosl(long double );
N_ARMDEFLD1(cosh);
X__declspec(__nothrow) long double coshl(long double );
N_ARMDEFLD1(exp);
X__declspec(__nothrow) long double expl(long double );
N_ARMDEFLD1(fabs);
X__declspec(__nothrow) long double fabsl(long double );
N_ARMDEFLD1(floor);
X__declspec(__nothrow) long double floorl(long double );
N_ARMDEFLD2(fmod);
X__declspec(__nothrow) long double fmodl(long double , long double );
N_ARMDEFLD1P(frexp, int*) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double frexpl(long double , int* ) __attribute__((__nonnull__(2)));
N_ARMDEFLD1P(ldexp, int);
X__declspec(__nothrow) long double ldexpl(long double , int );
N_ARMDEFLD1(log);
X__declspec(__nothrow) long double logl(long double );
N_ARMDEFLD1(log10);
X__declspec(__nothrow) long double log10l(long double );
N_ARMABI long double modfl(long double /*x*/, long double * /*p*/) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double modfl(long double  , long double *  ) __attribute__((__nonnull__(2)));
N_ARMDEFLD2(pow);
X__declspec(__nothrow) long double powl(long double , long double );
N_ARMDEFLD1(sin);
X__declspec(__nothrow) long double sinl(long double );
N_ARMDEFLD1(sinh);
X__declspec(__nothrow) long double sinhl(long double );
N_ARMDEFLD1(sqrt);
X__declspec(__nothrow) long double sqrtl(long double );
N_ARMDEFLD1(tan);
X__declspec(__nothrow) long double tanl(long double );
N_ARMDEFLD1(tanh);
X__declspec(__nothrow) long double tanhl(long double );
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N
N/*
N * C99 float and long double versions of extra-C89 functions.
N */
Nextern _ARMABI float acoshf(float /*x*/);
Xextern __declspec(__nothrow) float acoshf(float  );
N_ARMDEFLD1(acosh);
X__declspec(__nothrow) long double acoshl(long double );
Nextern _ARMABI float asinhf(float /*x*/);
Xextern __declspec(__nothrow) float asinhf(float  );
N_ARMDEFLD1(asinh);
X__declspec(__nothrow) long double asinhl(long double );
Nextern _ARMABI float atanhf(float /*x*/);
Xextern __declspec(__nothrow) float atanhf(float  );
N_ARMDEFLD1(atanh);
X__declspec(__nothrow) long double atanhl(long double );
N_ARMDEFLD2(copysign);
X__declspec(__nothrow) long double copysignl(long double , long double );
Nextern _ARMABI float cbrtf(float /*x*/);
Xextern __declspec(__nothrow) float cbrtf(float  );
N_ARMDEFLD1(cbrt);
X__declspec(__nothrow) long double cbrtl(long double );
Nextern _ARMABI float erff(float /*x*/);
Xextern __declspec(__nothrow) float erff(float  );
N_ARMDEFLD1(erf);
X__declspec(__nothrow) long double erfl(long double );
Nextern _ARMABI float erfcf(float /*x*/);
Xextern __declspec(__nothrow) float erfcf(float  );
N_ARMDEFLD1(erfc);
X__declspec(__nothrow) long double erfcl(long double );
Nextern _ARMABI float expm1f(float /*x*/);
Xextern __declspec(__nothrow) float expm1f(float  );
N_ARMDEFLD1(expm1);
X__declspec(__nothrow) long double expm1l(long double );
Nextern _ARMABI float log1pf(float /*x*/);
Xextern __declspec(__nothrow) float log1pf(float  );
N_ARMDEFLD1(log1p);
X__declspec(__nothrow) long double log1pl(long double );
Nextern _ARMABI float hypotf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float hypotf(float  , float  );
N_ARMDEFLD2(hypot);
X__declspec(__nothrow) long double hypotl(long double , long double );
Nextern _ARMABI float lgammaf(float /*x*/);
Xextern __declspec(__nothrow) float lgammaf(float  );
N_ARMDEFLD1(lgamma);
X__declspec(__nothrow) long double lgammal(long double );
Nextern _ARMABI float remainderf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float remainderf(float  , float  );
N_ARMDEFLD2(remainder);
X__declspec(__nothrow) long double remainderl(long double , long double );
Nextern _ARMABI float rintf(float /*x*/);
Xextern __declspec(__nothrow) float rintf(float  );
N_ARMDEFLD1(rint);
X__declspec(__nothrow) long double rintl(long double );
N
N#endif
N
N#ifdef __USE_C99_MATH
S/*
S * Functions new in C99.
S */
Sextern _ARMABI double exp2(double /*x*/); /* * 2.^x. */
Sextern _ARMABI float exp2f(float /*x*/);
S_ARMDEFLD1(exp2);
Sextern _ARMABI double fdim(double /*x*/, double /*y*/);
Sextern _ARMABI float fdimf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fdim);
S#ifdef __FP_FAST_FMA
S#define FP_FAST_FMA
S#endif
S#ifdef __FP_FAST_FMAF
S#define FP_FAST_FMAF
S#endif
S#ifdef __FP_FAST_FMAL
S#define FP_FAST_FMAL
S#endif
Sextern _ARMABI double fma(double /*x*/, double /*y*/, double /*z*/);
Sextern _ARMABI float fmaf(float /*x*/, float /*y*/, float /*z*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z) \
S    { return (long double)fma((double)__x, (double)__y, (double)__z); }
X_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z)     { return (long double)fma((double)__x, (double)__y, (double)__z); }
S#endif
Sextern _ARMABI_FPEXCEPT double fmax(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fmaxf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmax);
Sextern _ARMABI_FPEXCEPT double fmin(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fminf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmin);
Sextern _ARMABI double log2(double /*x*/); /* * log base 2 of x. */
Sextern _ARMABI float log2f(float /*x*/);
S_ARMDEFLD1(log2);
Sextern _ARMABI long lrint(double /*x*/);
Sextern _ARMABI long lrintf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI long lrintl(long double __x) \
S    { return lrint((double)__x); }
X_ARMABI_INLINE _ARMABI long lrintl(long double __x)     { return lrint((double)__x); }
S#endif
Sextern _ARMABI __LONGLONG llrint(double /*x*/);
Sextern _ARMABI __LONGLONG llrintf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x) \
S    { return llrint((double)__x); }
X_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x)     { return llrint((double)__x); }
S#endif
Sextern _ARMABI long lround(double /*x*/);
Sextern _ARMABI long lroundf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI long lroundl(long double __x) \
S    { return lround((double)__x); }
X_ARMABI_INLINE _ARMABI long lroundl(long double __x)     { return lround((double)__x); }
S#endif
Sextern _ARMABI __LONGLONG llround(double /*x*/);
Sextern _ARMABI __LONGLONG llroundf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x) \
S    { return llround((double)__x); }
X_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x)     { return llround((double)__x); }
S#endif
Sextern _ARMABI_PURE double nan(const char */*tagp*/);
Sextern _ARMABI_PURE float nanf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t) \
S    { return (long double)nan(__t); }
X_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t)     { return (long double)nan(__t); }
S#endif
S#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
Sextern _ARMABI_PURE double nans(const char */*tagp*/);
Sextern _ARMABI_PURE float nansf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t) \
S    { return (long double)nans(__t); }
X_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t)     { return (long double)nans(__t); }
S#endif
S#endif 
Sextern _ARMABI_FPEXCEPT double nearbyint(double /*x*/);
Sextern _ARMABI_FPEXCEPT float nearbyintf(float /*x*/);
S_ARMDEFLD1(nearbyint);
Sextern  double remquo(double /*x*/, double /*y*/, int */*quo*/);
Sextern  float remquof(float /*x*/, float /*y*/, int */*quo*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q) \
S    { return (long double)remquo((double)__x, (double)__y, __q); }
X_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q)     { return (long double)remquo((double)__x, (double)__y, __q); }
S#endif
Sextern _ARMABI_FPEXCEPT double round(double /*x*/);
Sextern _ARMABI_FPEXCEPT float roundf(float /*x*/);
S_ARMDEFLD1(round);
Sextern _ARMABI double tgamma(double /*x*/); /* * The gamma function of x. */
Sextern _ARMABI float tgammaf(float /*x*/);
S_ARMDEFLD1(tgamma);
Sextern _ARMABI_FPEXCEPT double trunc(double /*x*/);
Sextern _ARMABI_FPEXCEPT float truncf(float /*x*/);
S_ARMDEFLD1(trunc);
N#endif
N
N#undef _ARMDEFLD1
N#undef _ARMDEFLD1P
N#undef _ARMDEFLD2
N
N#ifdef __cplusplus
N  extern "C++" {
N    inline float abs(float __x)   { return fabsf(__x); }
N    inline float acos(float __x)  { return acosf(__x); }
N    inline float asin(float __x)  { return asinf(__x); }
N    inline float atan(float __x)  { return atanf(__x); }
N    inline float atan2(float __y, float __x)    { return atan2f(__y,__x); }
N    inline float ceil(float __x)  { return ceilf(__x); }
N    inline float cos(float __x)   { return cosf(__x); }
N    inline float cosh(float __x)  { return coshf(__x); }
N    inline float exp(float __x)   { return expf(__x); }
N    inline float fabs(float __x)  { return fabsf(__x); }
N    inline float floor(float __x) { return floorf(__x); }
N    inline float fmod(float __x, float __y)     { return fmodf(__x, __y); }
N    float frexp(float __x, int* __exp) __attribute__((__nonnull__(2)));
N    inline float frexp(float __x, int* __exp)   { return frexpf(__x, __exp); }
N    inline float ldexp(float __x, int __exp)    { return ldexpf(__x, __exp);}
N    inline float log(float __x)   { return logf(__x); }
N    inline float log10(float __x) { return log10f(__x); }
N    float modf(float __x, float* __iptr) __attribute__((__nonnull__(2)));
N    inline float modf(float __x, float* __iptr) { return modff(__x, __iptr); }
N    inline float pow(float __x, float __y)      { return powf(__x,__y); }
N    inline float pow(float __x, int __y)     { return powf(__x, (float)__y); }
N    inline float sin(float __x)   { return sinf(__x); }
N    inline float sinh(float __x)  { return sinhf(__x); }
N    inline float sqrt(float __x)  { return sqrtf(__x); }
N    inline float _sqrt(float __x) { return _sqrtf(__x); }
N    inline float tan(float __x)   { return tanf(__x); }
N    inline float tanh(float __x)  { return tanhf(__x); }
N
N    inline double abs(double __x) { return fabs(__x); }
N    inline double pow(double __x, int __y)
N                { return pow(__x, (double) __y); }
N
N#ifdef __HAVE_LONGDOUBLE
N    inline long double abs(long double __x)
N                { return (long double)fabsl(__x); }
N    inline long double acos(long double __x)
N                { return (long double)acosl(__x); }
N    inline long double asin(long double __x)
N                { return (long double)asinl(__x); }
N    inline long double atan(long double __x)
N                { return (long double)atanl(__x); }
N    inline long double atan2(long double __y, long double __x)
N                { return (long double)atan2l(__y, __x); }
N    inline long double ceil(long double __x)
N                { return (long double)ceill( __x); }
N    inline long double cos(long double __x)
N                { return (long double)cosl(__x); }
N    inline long double cosh(long double __x)
N                { return (long double)coshl(__x); }
N    inline long double exp(long double __x)
N                { return (long double)expl(__x); }
N    inline long double fabs(long double __x)
N                { return (long double)fabsl(__x); }
N    inline long double floor(long double __x)
N                { return (long double)floorl(__x); }
N    inline long double fmod(long double __x, long double __y)
N                { return (long double)fmodl(__x, __y); }
N    long double frexp(long double __x, int* __p) __attribute__((__nonnull__(2)));
N    inline long double frexp(long double __x, int* __p)
N                { return (long double)frexpl(__x, __p); }
N    inline long double ldexp(long double __x, int __exp)
N                { return (long double)ldexpl(__x, __exp); }
N    inline long double log(long double __x)
N                { return (long double)logl(__x); }
N    inline long double log10(long double __x)
N                { return (long double)log10l(__x); }
N    long double modf(long double __x, long double* __p) __attribute__((__nonnull__(2)));
N    inline long double modf(long double __x, long double* __p)
N                { return (long double)modfl(__x, __p); }
N    inline long double pow(long double __x, long double __y)
N                { return (long double)powl(__x, __y); }
N    inline long double pow(long double __x, int __y)
N                { return (long double)powl(__x, __y); }
N    inline long double sin(long double __x)
N                { return (long double)sinl(__x); }
N    inline long double sinh(long double __x)
N                { return (long double)sinhl(__x); }
N    inline long double sqrt(long double __x)
N                { return (long double)sqrtl(__x); }
N    inline long double _sqrt(long double __x)
N                { return (long double)_sqrt((double) __x); }
N    inline long double tan(long double __x)
N                { return (long double)tanl(__x); }
N    inline long double tanh(long double __x)
N                { return (long double)tanhl(__x); }
N#endif
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N    inline float acosh(float __x) { return acoshf(__x); }
N    inline float asinh(float __x) { return asinhf(__x); }
N    inline float atanh(float __x) { return atanhf(__x); }
N    inline float cbrt(float __x) { return cbrtf(__x); }
N    inline float erf(float __x) { return erff(__x); }
N    inline float erfc(float __x) { return erfcf(__x); }
N    inline float expm1(float __x) { return expm1f(__x); }
N    inline float log1p(float __x) { return log1pf(__x); }
N    inline float hypot(float __x, float __y) { return hypotf(__x, __y); }
N    inline float lgamma(float __x) { return lgammaf(__x); }
N    inline float remainder(float __x, float __y) { return remainderf(__x, __y); }
N    inline float rint(float __x) { return rintf(__x); }
N#endif
N
N#ifdef __USE_C99_MATH
S    inline float exp2(float __x) { return exp2f(__x); }
S    inline float fdim(float __x, float __y) { return fdimf(__x, __y); }
S    inline float fma(float __x, float __y, float __z) { return fmaf(__x, __y, __z); }
S    inline float fmax(float __x, float __y) { return fmaxf(__x, __y); }
S    inline float fmin(float __x, float __y) { return fminf(__x, __y); }
S    inline float log2(float __x) { return log2f(__x); }
S    inline _ARMABI long lrint(float __x) { return lrintf(__x); }
S    inline _ARMABI __LONGLONG llrint(float __x) { return llrintf(__x); }
S    inline _ARMABI long lround(float __x) { return lroundf(__x); }
S    inline _ARMABI __LONGLONG llround(float __x) { return llroundf(__x); }
S    inline _ARMABI_FPEXCEPT float nearbyint(float __x) { return nearbyintf(__x); }
S    inline float remquo(float __x, float __y, int *__q) { return remquof(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT float round(float __x) { return roundf(__x); }
S    inline float tgamma(float __x) { return tgammaf(__x); }
S    inline _ARMABI_FPEXCEPT float trunc(float __x) { return truncf(__x); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double acosh(long double __x) { return acoshl(__x); }
S    inline long double asinh(long double __x) { return asinhl(__x); }
S    inline long double atanh(long double __x) { return atanhl(__x); }
S    inline long double cbrt(long double __x) { return cbrtl(__x); }
S    inline long double erf(long double __x) { return erfl(__x); }
S    inline long double erfc(long double __x) { return erfcl(__x); }
S    inline long double expm1(long double __x) { return expm1l(__x); }
S    inline long double log1p(long double __x) { return log1pl(__x); }
S    inline long double hypot(long double __x, long double __y) { return hypotl(__x, __y); }
S    inline long double lgamma(long double __x) { return lgammal(__x); }
S    inline long double remainder(long double __x, long double __y) { return remainderl(__x, __y); }
S    inline long double rint(long double __x) { return rintl(__x); }
S    inline long double exp2(long double __x) { return exp2l(__x); }
S    inline long double fdim(long double __x, long double __y) { return fdiml(__x, __y); }
S    inline long double fma(long double __x, long double __y, long double __z) { return fmal(__x, __y, __z); }
S    inline long double fmax(long double __x, long double __y) { return fmaxl(__x, __y); }
S    inline long double fmin(long double __x, long double __y) { return fminl(__x, __y); }
S    inline long double log2(long double __x) { return log2l(__x); }
S    inline _ARMABI long lrint(long double __x) { return lrintl(__x); }
S    inline _ARMABI __LONGLONG llrint(long double __x) { return llrintl(__x); }
S    inline _ARMABI long lround(long double __x) { return lroundl(__x); }
S    inline _ARMABI __LONGLONG llround(long double __x) { return llroundl(__x); }
S    inline _ARMABI_FPEXCEPT long double nearbyint(long double __x) { return nearbyintl(__x); }
S    inline long double remquo(long double __x, long double __y, int *__q) { return remquol(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT long double round(long double __x) { return roundl(__x); }
S    inline long double tgamma(long double __x) { return tgammal(__x); }
S    inline _ARMABI_FPEXCEPT long double trunc(long double __x) { return truncl(__x); }
S#endif
N#endif
N
N  }
N#endif
N
N    #ifdef __cplusplus
N        }  /* extern "C" */
N      }  /* namespace std */
N    #endif
N  #endif /* __MATH_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__MATH_NO_EXPORTS)
X  #if 1L && !1L
S    using ::std::__use_accurate_range_reduction;
S    using ::std::abs;
S    using ::std::acos;
S    using ::std::asin;
S    using ::std::atan2;
S    using ::std::atan;
S    using ::std::ceil;
S    using ::std::cos;
S    using ::std::cosh;
S    using ::std::exp;
S    using ::std::fabs;
S    using ::std::floor;
S    using ::std::fmod;
S    using ::std::frexp;
S    using ::std::ldexp;
S    using ::std::log10;
S    using ::std::log;
S    using ::std::modf;
S    using ::std::pow;
S    using ::std::sin;
S    using ::std::sinh;
S    using ::std::sqrt;
S    using ::std::_sqrt;
S    using ::std::_sqrtf;
S    using ::std::tan;
S    using ::std::tanh;
S    using ::std::_fabsf;
S    /* C99 float and long double versions in already-C89-reserved namespace */
S    using ::std::acosf;
S    using ::std::acosl;
S    using ::std::asinf;
S    using ::std::asinl;
S    using ::std::atan2f;
S    using ::std::atan2l;
S    using ::std::atanf;
S    using ::std::atanl;
S    using ::std::ceilf;
S    using ::std::ceill;
S    using ::std::cosf;
S    using ::std::coshf;
S    using ::std::coshl;
S    using ::std::cosl;
S    using ::std::expf;
S    using ::std::expl;
S    using ::std::fabsf;
S    using ::std::fabsl;
S    using ::std::floorf;
S    using ::std::floorl;
S    using ::std::fmodf;
S    using ::std::fmodl;
S    using ::std::frexpf;
S    using ::std::frexpl;
S    using ::std::ldexpf;
S    using ::std::ldexpl;
S    using ::std::log10f;
S    using ::std::log10l;
S    using ::std::logf;
S    using ::std::logl;
S    using ::std::modff;
S    using ::std::modfl;
S    using ::std::powf;
S    using ::std::powl;
S    using ::std::sinf;
S    using ::std::sinhf;
S    using ::std::sinhl;
S    using ::std::sinl;
S    using ::std::sqrtf;
S    using ::std::sqrtl;
S    using ::std::tanf;
S    using ::std::tanhf;
S    using ::std::tanhl;
S    using ::std::tanl;
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which for historical reasons appear in non-strict mode */
S      using ::std::acosh;
S      using ::std::asinh;
S      using ::std::atanh;
S      using ::std::cbrt;
S      using ::std::copysign;
S      using ::std::copysignf;
S      using ::std::erf;
S      using ::std::erfc;
S      using ::std::expm1;
S      using ::std::hypot;
S      using ::std::ilogb;
S      using ::std::ilogbf;
S      using ::std::ilogbl;
S      using ::std::lgamma;
S      using ::std::log1p;
S      using ::std::logb;
S      using ::std::logbf;
S      using ::std::logbl;
S      using ::std::nextafter;
S      using ::std::nextafterf;
S      using ::std::nextafterl;
S      using ::std::nexttoward;
S      using ::std::nexttowardf;
S      using ::std::nexttowardl;
S      using ::std::remainder;
S      using ::std::rint;
S      using ::std::scalbln;
S      using ::std::scalblnf;
S      using ::std::scalblnl;
S      using ::std::scalbn;
S      using ::std::scalbnf;
S      using ::std::scalbnl;
S      using ::std::math_errhandling;
S      using ::std::acoshf;
S      using ::std::acoshl;
S      using ::std::asinhf;
S      using ::std::asinhl;
S      using ::std::atanhf;
S      using ::std::atanhl;
S      using ::std::copysignl;
S      using ::std::cbrtf;
S      using ::std::cbrtl;
S      using ::std::erff;
S      using ::std::erfl;
S      using ::std::erfcf;
S      using ::std::erfcl;
S      using ::std::expm1f;
S      using ::std::expm1l;
S      using ::std::log1pf;
S      using ::std::log1pl;
S      using ::std::hypotf;
S      using ::std::hypotl;
S      using ::std::lgammaf;
S      using ::std::lgammal;
S      using ::std::remainderf;
S      using ::std::remainderl;
S      using ::std::rintf;
S      using ::std::rintl;
S    #endif
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which appear in C99 or non-strict mode */
S      using ::std::float_t;
S      using ::std::double_t;
S    #endif
S    #ifdef __USE_C99_MATH
S      /* Functions new in C99. */
S      using ::std::exp2;
S      using ::std::exp2f;
S      using ::std::exp2l;
S      using ::std::fdim;
S      using ::std::fdimf;
S      using ::std::fdiml;
S      using ::std::fma;
S      using ::std::fmaf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::fmal;
S#endif
S      using ::std::fmax;
S      using ::std::fmaxf;
S      using ::std::fmaxl;
S      using ::std::fmin;
S      using ::std::fminf;
S      using ::std::fminl;
S      using ::std::log2;
S      using ::std::log2f;
S      using ::std::log2l;
S      using ::std::lrint;
S      using ::std::lrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lrintl;
S#endif
S      using ::std::llrint;
S      using ::std::llrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llrintl;
S#endif
S      using ::std::lround;
S      using ::std::lroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lroundl;
S#endif
S      using ::std::llround;
S      using ::std::llroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llroundl;
S#endif
S      using ::std::nan;
S      using ::std::nanf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::nanl;
S#endif
S      using ::std::nearbyint;
S      using ::std::nearbyintf;
S      using ::std::nearbyintl;
S      using ::std::remquo;
S      using ::std::remquof;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::remquol;
S#endif
S      using ::std::round;
S      using ::std::roundf;
S      using ::std::roundl;
S      using ::std::tgamma;
S      using ::std::tgammaf;
S      using ::std::tgammal;
S      using ::std::trunc;
S      using ::std::truncf;
S      using ::std::truncl;
S    #endif
N  #endif
N
N#undef __LONGLONG
N
N#endif /* __math_h */
N
N/* end of math.h */
L 18 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cmath" 2
N  #undef __MATH_NO_EXPORTS 
N
N  #undef __math_h  // later inclusion of math.h must do using std::*
N  #ifdef __EDG_IMPLICIT_USING_STD
S    /* Implicitly include a using directive for the STD namespace when this
S       preprocessing flag is TRUE. */
S       using namespace ::std;
N  #endif /* ifdef __EDG_IMPLICIT_USING_STD */
N
N#endif /* __cmath */
N
N/* end of cmath */
N
L 47 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_math.h" 2
N
N#undef exception
N
N// MSVC provides its own complex macro
N#ifdef _MSC_VER
S#  ifdef complex
S#    undef complex
S#  endif
N#endif
N
N
N#endif   // _RWSTD_MATH_H_INCLUDED
N
L 37 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\limits" 2
N
N#include _RWSTD_CFLOAT
X#include <cfloat>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cfloat" 1
N/*
N * C++ header for C header float.h
N * Copyright 1997 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision: 177844 $
N * Checkin $Date: 2012-11-21 11:51:12 +0000 (Wed, 21 Nov 2012) $
N * Revising $Author: pwright $
N */
N
N#ifndef __cfloat
N#define __cfloat
N#define __ARMCLIB_VERSION 5050106
N
N  #define __FLOAT_NO_EXPORTS 1
N  #include <float.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\float.h" 1
N/* float.h: ANSI 'C' (X3J11 Oct 88) library header, section 2.2.4.2 */
N/* Copyright (C) Codemist Ltd, 1988                             */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.01 */
N
N/*
N * RCS $Revision: 177844 $
N * Checkin $Date: 2012-11-21 11:51:12 +0000 (Wed, 21 Nov 2012) $
N * Revising $Author: drodgman $
N */
N
N#ifndef __float_h
N#define __float_h
N#define __ARMCLIB_VERSION 5050106
N
N  #ifndef __FLOAT_DECLS
N  #define __FLOAT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
N      namespace std {
N      #define __CLIBNS std::
N        extern "C" {
N    #else
S      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/* IEEE version: the following values are taken from the above ANSI draft.  */
N/* The ACORN FPE (v17) is known not to precisely implement IEEE arithmetic. */
N
N#define FLT_RADIX     2
N    /* radix of exponent representation */
N#ifdef __FP_FENV_ROUNDING
Sextern unsigned __ieee_status(unsigned,unsigned); /* from fenv.h */
S#define FLT_ROUNDS ((1+(__CLIBNS __ieee_status(0, 0)>>22))&3)
N#else
N#define FLT_ROUNDS    1
N#endif
N    /*
N     * The rounding mode for floating-point addition is characterised by the
N     * value of FLT_ROUNDS:
N     *  -1 : indeterminable.
N     *   0 : towards zero.
N     *   1 : to nearest.
N     *   2 : towards positive infinity.
N     *   3 : towards negative infinity.
N     *   ? : any other is implementation-defined.
N     */
N
N#define FLT_MANT_DIG        24
N#define DBL_MANT_DIG        53
N#define LDBL_MANT_DIG       53
N    /* number of base-FLT_RADIX digits in the floating point mantissa */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (0L && 199901L <= __STDC_VERSION__)
N#define DECIMAL_DIG 17
N    /* number of decimal digits that the widest floating point type
N       can be rounded to and back again without changing the value */
N#ifdef __FP_FAST
S#  define FLT_EVAL_METHOD (-1)
N#else
N#  define FLT_EVAL_METHOD 0
N#endif
N    /*
N     * The use of evaluation formats is characterized by the value of
N     * FLT_EVAL_METHOD:
N     *  -1 : indeterminable.
N     *   0 : evaluate all operations and constants just to the range
N     *       and precision of the type.
N     *   1 : evaluate operations and constants of type float and
N     *       double to the range and precision of the double type,
N     *       evaluate long double operations and constants to the
N     *       range and precision of the long double type.
N     *   2 : evaluate all opertations and constants to the range and
N     *       precision of the long double type.
N     */
N#endif
N
N/* The values that follow are not achieved under Acorn's FPE version 17  */
N/* but they should be correct in due course!                             */
N
N#define FLT_DIG      6
N#define DBL_DIG      15
N#define LDBL_DIG     15
N    /* number of decimal digits of precision */
N
N#define FLT_MIN_EXP  (-125)
N#define DBL_MIN_EXP  (-1021)
N#define LDBL_MIN_EXP (-1021)
N    /* minimum negative integer such that FLT_RADIX raised to that power */
N    /* minus 1 is a normalised floating-point number. */
N
N#define FLT_MIN_10_EXP  (-37)
N#define DBL_MIN_10_EXP  (-307)
N#define LDBL_MIN_10_EXP (-307)
N    /* minimum negative integer such that 10 raised to that power is in the */
N    /* range of normalised floating-point numbers. */
N
N#define FLT_MAX_EXP  128
N#define DBL_MAX_EXP  1024
N#define LDBL_MAX_EXP 1024
N    /* maximum integer such that FLT_RADIX raised to that power minus 1 is a */
N#define FLT_MAX_10_EXP  38
N#define DBL_MAX_10_EXP  308
N#define LDBL_MAX_10_EXP 308
N    /* maximum integer such that 10 raised to that power is in the range of */
N    /* representable finite floating-point numbers. */
N
N#define FLT_MAX  3.40282347e+38F
N#define DBL_MAX  1.79769313486231571e+308
N#define LDBL_MAX 1.79769313486231571e+308L
N    /* maximum representable finite floating-point number. */
N
N#define FLT_EPSILON         1.19209290e-7F
N#define DBL_EPSILON         2.2204460492503131e-16
N#define LDBL_EPSILON        2.2204460492503131e-16L
N    /* minimum positive floating point number x such that 1.0 + x != 1.0 */
N
N#define FLT_MIN  1.175494351e-38F
N#define DBL_MIN  2.22507385850720138e-308
N#define LDBL_MIN 2.22507385850720138e-308L
N    /* minimum normalised positive floating-point number. */
N
N/*
N * The Microsoft <float.h> extensions.
N */
N#ifdef __cplusplus
Nextern "C" {
N#endif
Nunsigned _controlfp(unsigned, unsigned);
Nunsigned _clearfp(void);
Nunsigned _statusfp(void);
N#ifdef __cplusplus
N}
N#endif
N
N
N/*
N * Because the _EM_ constants are shared between _controlfp (masks)
N * and _statusfp (sticky bits), we adopt the convention that
N * _controlfp will shift its arguments left by 8 bits before using
N * them.
N */
N
N#define _MCW_EM         0x001F
N#define _EM_INVALID     0x0001
N#define _EM_ZERODIVIDE  0x0002
N#define _EM_OVERFLOW    0x0004
N#define _EM_UNDERFLOW   0x0008
N#define _EM_INEXACT     0x0010
N
N#define _MCW_RC         0xC000
N#define _RC_CHOP        0xC000
N#define _RC_UP          0x4000
N#define _RC_DOWN        0x8000
N#define _RC_NEAR        0x0000
N
N/*
N * _FPE_ constants passed as the hidden second argument to SIGFPE
N * handlers.
N */
N#define _FPE_INVALID     0x04000000
N#define _FPE_ZERODIVIDE  0x08000000
N#define _FPE_OVERFLOW    0x10000000
N#define _FPE_UNDERFLOW   0x20000000
N#define _FPE_INEXACT     0x40000000
N
N
N    #ifdef __cplusplus
N        }  /* extern "C" */
N      }  /* namespace std */
N    #endif
N  #endif /* __FLOAT_DECLS */
N
N  #if defined(__cplusplus) && !defined(__FLOAT_NO_EXPORTS)
X  #if 1L && !1L
S    using ::std::_controlfp;
S    using ::std::_clearfp;
S    using ::std::_statusfp;
N  #endif
N
N#endif /* __float_h */
N
N/* end of float.h */
N
L 18 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cfloat" 2
N  #undef __FLOAT_NO_EXPORTS
N
N  #undef __float_h  // later inclusion of float.h must do using std::*
N  #ifdef __EDG_IMPLICIT_USING_STD
S    /* Implicitly include a using directive for the STD namespace when this
S       preprocessing flag is TRUE. */
S       using namespace ::std;
N  #endif /* ifdef __EDG_IMPLICIT_USING_STD */
N  
N#endif
N
L 39 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\limits" 2
N#include _RWSTD_CLIMITS
X#include <climits>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\climits" 1
N/*
N * C++ header for C header limits.h
N * Copyright 1997 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision: 177844 $
N * Checkin $Date: 2012-11-21 11:51:12 +0000 (Wed, 21 Nov 2012) $
N * Revising $Author: pwright $
N */
N
N#ifndef __climits
N#define __climits
N#define __ARMCLIB_VERSION 5050106
N
N#include <limits.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\limits.h" 1
N/* limits.h: ANSI 'C' (X3J11 Oct 88) library header, section 2.2.4.2 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991-1997 ARM Limited. All rights reserved         */
N
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: drodgman $
N */
N
N#ifndef __limits_h
N#define __limits_h
N#define __ARMCLIB_VERSION 5050106
N
N#define CHAR_BIT 8
N    /* max number of bits for smallest object that is not a bit-field (byte) */
N#define SCHAR_MIN (-128)
N    /* mimimum value for an object of type signed char */
N#define SCHAR_MAX 127
N    /* maximum value for an object of type signed char */
N#define UCHAR_MAX 255
N    /* maximum value for an object of type unsigned char */
N#ifdef __FEATURE_SIGNED_CHAR
S  #define CHAR_MIN (-128)
S      /* minimum value for an object of type char */
S  #define CHAR_MAX 127
S      /* maximum value for an object of type char */
N#else
N  #define CHAR_MIN 0
N      /* minimum value for an object of type char */
N  #define CHAR_MAX 255
N      /* maximum value for an object of type char */
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
Sextern const int __aeabi_MB_LEN_MAX;
S#define MB_LEN_MAX (__aeabi_MB_LEN_MAX)
N#else
N#define MB_LEN_MAX 6
N#endif
N    /* maximum number of bytes in a multibyte character, */
N    /* for any supported locale */
N
N#define SHRT_MIN  (-0x8000)
N    /* minimum value for an object of type short int */
N#define SHRT_MAX  0x7fff
N    /* maximum value for an object of type short int */
N#define USHRT_MAX 65535
N    /* maximum value for an object of type unsigned short int */
N#define INT_MIN   (~0x7fffffff)  /* -2147483648 and 0x80000000 are unsigned */
N    /* minimum value for an object of type int */
N#define INT_MAX   0x7fffffff
N    /* maximum value for an object of type int */
N#define UINT_MAX  0xffffffffU
N    /* maximum value for an object of type unsigned int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define LONG_MIN  (~0x7fffffffffffffffL)
N#else
N  #define LONG_MIN  (~0x7fffffffL)
N#endif
N    /* minimum value for an object of type long int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define LONG_MAX  0x7fffffffffffffffL
N#else
N  #define LONG_MAX  0x7fffffffL
N#endif
N    /* maximum value for an object of type long int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define ULONG_MAX 0xffffffffffffffffUL
N#else
N  #define ULONG_MAX 0xffffffffUL
N#endif
N    /* maximum value for an object of type unsigned long int */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (0L && 199901L <= __STDC_VERSION__)
N  #define LLONG_MIN  (~0x7fffffffffffffffLL)
N      /* minimum value for an object of type long long int */
N  #define LLONG_MAX    0x7fffffffffffffffLL
N      /* maximum value for an object of type long long int */
N  #define ULLONG_MAX   0xffffffffffffffffULL
N      /* maximum value for an object of type unsigned long int */
N#endif
N
N#endif
N
N/* end of limits.h */
N
L 17 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\climits" 2
N
N#endif
N
L 40 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\limits" 2
N#include _RWSTD_IEEEFP
X#include <rw/_defs.h>
N
N
N/**************************************************************************
N *
N * Assumptions made in this implementation:
N *
N *   1) numeric_limits<T>::digits is 1 for bool and is computed as
N *      (CHAR_BIT * sizeof (T) - numeric_limits<T>::is_signed for
N *      all native integral T
N *
N *   2) numeric_limits<T>::radix is the same (2 by default) for all
N *      specializations of native integral T
N *
N *   3) numeric_limits<T>::is_modulo is true if numeric_limits<T>::max()
N *      + 1 == numeric_limits<T>::min for all specializations
N *      of native integral T
N *
N *   4) numeric_limts<T>::traps == false for all native integral T
N *
N *   5) OEM vendors are expected to provide correct values where supplied
N *      values (VENDOR) differ from those defined by the implementation
N *
N **************************************************************************/
N
N#define _RWSTD_HAS_INFINITY true  // VENDOR
N#define _RWSTD_HAS_QUIET_NAN true // VENDOR
N
N#ifdef __FP_IEEE
S  #define _RWSTD_IS_IEC559 true // VENDOR
S  #define _RWSTD_HAS_DENORM_LOSS true // VENDOR
S  #define _RWSTD_HAS_DENORM      denorm_present // VENDOR
S  #define _RWSTD_FLT_DENORM_MIN  1.4012984643248171e-45F   // VENDOR
S  #define _RWSTD_DBL_DENORM_MIN  4.9406564584124654e-324   // VENDOR
S  #define _RWSTD_LDBL_DENORM_MIN 4.9406564584124654e-324L  // VENDOR
N#else
N  #define _RWSTD_IS_IEC559 false // VENDOR
N  #define _RWSTD_HAS_DENORM_LOSS false // VENDOR
N  #define _RWSTD_HAS_DENORM      denorm_absent // VENDOR
N  #define _RWSTD_FLT_DENORM_MIN  FLT_MIN   // VENDOR
N  #define _RWSTD_DBL_DENORM_MIN  DBL_MIN    // VENDOR
N  #define _RWSTD_LDBL_DENORM_MIN LDBL_MIN  // VENDOR
N#endif
N
N#ifdef __FP_FENV_ROUNDING
S  /* We only include the relevant parts of fenv.h to avoid polluting the user's
S   * namespace.
S  #include <fenv.h>
S  */
S  extern "C" unsigned __ieee_status(unsigned, unsigned);
S  #define __FE_IEEE_ROUND_MASK         (0x00C00000)
S  #define __FE_IEEE_ROUND_TONEAREST    (0x00000000)
S  /* end of <fenv.h> */
S  // rounding can be changed at runtime
S  #define _RWSTD_ROUND_TONEAREST ((__ieee_status(0,0) & __FE_IEEE_ROUND_MASK) == __FE_IEEE_ROUND_TONEAREST)
S  #define _RWSTD_FLT_ROUND_ERROR  (_RWSTD_ROUND_TONEAREST ? 0.5F : 1.0F)
S  #define _RWSTD_DBL_ROUND_ERROR  (_RWSTD_ROUND_TONEAREST ? 0.5  : 1.0)
S  #define _RWSTD_LDBL_ROUND_ERROR (_RWSTD_ROUND_TONEAREST ? 0.5L : 1.0L)
N#else
N  // rounding is fixed to round to nearest
N  #define _RWSTD_FLT_ROUND_ERROR  0.5F
N  #define _RWSTD_DBL_ROUND_ERROR  0.5
N  #define _RWSTD_LDBL_ROUND_ERROR 0.5L
N#endif
N
N// signalling NAN
N#define _RWSTD_HAS_SIG_NAN true // VENDOR
N
N#undef _RWSTD_STATIC_INIT
N#undef _RWSTD_STATIC_DEF
N
N
N#ifndef _RWSTD_NO_STATIC_CONST_MEMBER_INIT
N#  ifndef _RWSTD_DEFINE_EXPORTS
N#    define _RWSTD_STATIC_INIT(name, value)   name = (value)
N#  else
S#    define _RWSTD_STATIC_INIT(name, value)   name
N#  endif
N#else
S#  ifndef _RWSTD_DEFINE_EXPORTS
S#    define _RWSTD_STATIC_INIT(name, value)   name
S#  else
S#    define _RWSTD_STATIC_INIT(name, value)   name = (value)
S#  endif
N#endif   // _RWSTD_NO_STATIC_CONST_MEMBER_INIT
N
N
N#undef _RWSTD_CLASS_BEGIN
N#undef _RWSTD_CLASS_END
N#undef _RWSTD_TYPEDEF
N#undef _RWSTD_STATIC
N#undef _RWSTD_STATIC_ROUNDS
N#undef _RWSTD_STATIC_FUN
N
N
N#ifndef _RWSTD_DEFINE_EXPORTS
N
N// declarations - expanded in every translation unit
N// that #includes <limits>
N
N#  define _RWSTD_CLASS_BEGIN(name) name { public: 
N#  define _RWSTD_CLASS_END              };
N#  define _RWSTD_TYPEDEF(def)           typedef def;
N#  define _RWSTD_STATIC(ignore, type, name, value)            \
N          static const type            \
N              _RWSTD_STATIC_INIT (name, value)
X#  define _RWSTD_STATIC(ignore, type, name, value)                      static const type                          _RWSTD_STATIC_INIT (name, value)
N
N#  ifndef _RWSTD_NO_CONST_FLT_ROUNDS
S#    define _RWSTD_STATIC_ROUNDS(ignore, type, name, value)   \
S            _RWSTD_STATIC (ignore, type, name,                \
S                           _RWSTD_STATIC_CAST (float_round_style, value))
X#    define _RWSTD_STATIC_ROUNDS(ignore, type, name, value)               _RWSTD_STATIC (ignore, type, name,                                           _RWSTD_STATIC_CAST (float_round_style, value))
N#  else
N#    define _RWSTD_STATIC_ROUNDS(ign1, type, name, ign2)      \
N            static const type _RWSTD_EXPORT name
X#    define _RWSTD_STATIC_ROUNDS(ign1, type, name, ign2)                  static const type _RWSTD_EXPORT name
N#  endif   // _RWSTD_NO_CONST_FLT_ROUNDS
N
N#  define _RWSTD_STATIC_FUN(type, name, value)                \
N          static type name () _THROWS (()) { return value; }
X#  define _RWSTD_STATIC_FUN(type, name, value)                          static type name () _THROWS (()) { return value; }
N
N#else   // defined (_RWSTD_DEFINE_EXPORTS)
S
S// definitions - expanded in a single translation unit that defines
S// static const data members outside of each numeric_limits<> specialization
S
S#  define _RWSTD_CLASS_BEGIN(ignore)
S#  define _RWSTD_CLASS_END
S#  define _RWSTD_TYPEDEF(ignore)
S#  define _RWSTD_STATIC(limtype, type, name, value)           \
S          const type _RWSTD_STATIC_INIT (numeric_limits<limtype>::name, value)
X#  define _RWSTD_STATIC(limtype, type, name, value)                     const type _RWSTD_STATIC_INIT (numeric_limits<limtype>::name, value)
S
S#  ifndef _RWSTD_NO_CONST_FLT_ROUNDS
S#    define _RWSTD_STATIC_ROUNDS(limtype, type, name, value)  \
S            _RWSTD_STATIC (limtype, type, name,               \
S                           _RWSTD_STATIC_CAST (float_round_style, value))
X#    define _RWSTD_STATIC_ROUNDS(limtype, type, name, value)              _RWSTD_STATIC (limtype, type, name,                                          _RWSTD_STATIC_CAST (float_round_style, value))
S#  else
S#    define _RWSTD_STATIC_ROUNDS(limtype, type, name, value)  \
S            const type numeric_limits<limtype>::name =        \
S                           _RWSTD_STATIC_CAST (float_round_style, value)
X#    define _RWSTD_STATIC_ROUNDS(limtype, type, name, value)              const type numeric_limits<limtype>::name =                                   _RWSTD_STATIC_CAST (float_round_style, value)
S#  endif   // _RWSTD_NO_CONST_FLT_ROUNDS
S
S#  define _RWSTD_STATIC_FUN(ign1, ign2, ign3)
S#  define _RWSTD_STATIC_FUN_HEXFLOAT(ign1, ign2, ign3)
S#  define _RWSTD_STATIC_FUN_HEXDOUBLE(ign1, ign2, ign3, ign4)
S
N#endif   // _RWSTD_DEFINE_EXPORTS
N
N
N// 18.2.1.2, p6 - 7
N#define _RWSTD_DIGITS(type, min, max) \
N        (1 == (max) ? 1 : (CHAR_BIT * sizeof (type) - ((min) != 0)))
X#define _RWSTD_DIGITS(type, min, max)         (1 == (max) ? 1 : (CHAR_BIT * sizeof (type) - ((min) != 0)))
N
N// 18.2.1.2, p9
N#define _RWSTD_DIGITS10(digits)   (((digits) * 301) / 1000)
N
N
N#undef max
N#undef min
N
N
N#undef _RWSTD_LIMITS_BODY
N
N#define _RWSTD_LIMITS_BODY(type, conv_type, cpfx)                           \
N    _RWSTD_STATIC (type, bool, is_specialized, true);                       \
N                                                                            \
N    _RWSTD_STATIC_FUN (type, min, cpfx##_MIN)                               \
N    _RWSTD_STATIC_FUN (type, max, cpfx##_MAX)                               \
N                                                                            \
N    _RWSTD_STATIC (type, bool, is_signed,  cpfx##_MIN != 0);                \
N    _RWSTD_STATIC (type, bool, is_integer, true);                           \
N    _RWSTD_STATIC (type, bool, is_exact,   true);                           \
N                                                                            \
N    _RWSTD_STATIC (type, int, digits,                                       \
N                   _RWSTD_DIGITS (type, cpfx##_MIN, cpfx##_MAX));           \
N                                                                            \
N    /* spelled out to work around a bug in IBM xlC 5.0 */                   \
N    _RWSTD_STATIC (type, int, digits10,                                     \
N                   _RWSTD_DIGITS10 (_RWSTD_DIGITS (type, cpfx##_MIN,        \
N                                                         cpfx##_MAX)));     \
N                                                                            \
N    _RWSTD_STATIC (type, int, radix, 2);   /* VENDOR */                     \
N                                                                            \
N    _RWSTD_STATIC_FUN (type, epsilon,     0)                                \
N    _RWSTD_STATIC_FUN (type, round_error, 0)                                \
N                                                                            \
N    _RWSTD_STATIC (type, int, min_exponent,   0);                           \
N    _RWSTD_STATIC (type, int, min_exponent10, 0);                           \
N    _RWSTD_STATIC (type, int, max_exponent,   0);                           \
N    _RWSTD_STATIC (type, int, max_exponent10, 0);                           \
N                                                                            \
N    _RWSTD_STATIC (type, bool, has_infinity,             false);            \
N    _RWSTD_STATIC (type, bool, has_quiet_NaN,            false);            \
N    _RWSTD_STATIC (type, bool, has_signaling_NaN,        false);            \
N    _RWSTD_STATIC (type, float_denorm_style, has_denorm, denorm_absent);    \
N    _RWSTD_STATIC (type, bool, has_denorm_loss,          false);            \
N                                                                            \
N    _RWSTD_STATIC_FUN (type, infinity,      0)                              \
N    _RWSTD_STATIC_FUN (type, quiet_NaN,     0)                              \
N    _RWSTD_STATIC_FUN (type, signaling_NaN, 0)                              \
N    _RWSTD_STATIC_FUN (type, denorm_min,    0)                              \
N                                                                            \
N    _RWSTD_STATIC (type, bool, is_iec559,  false);                          \
N    _RWSTD_STATIC (type, bool, is_bounded, true);                           \
N    _RWSTD_STATIC (type, bool, is_modulo,  1 != cpfx##_MAX);                \
N                                                                            \
N    _RWSTD_STATIC (type, bool, traps,           false);                     \
N    _RWSTD_STATIC (type, bool, tinyness_before, false);                     \
N    _RWSTD_STATIC (type, float_round_style, round_style, round_toward_zero);\
N                                                                            \
N    /* extension: type converts to without loss of data */                  \
N    _RWSTD_TYPEDEF (conv_type _C_convertible)
X#define _RWSTD_LIMITS_BODY(type, conv_type, cpfx)                               _RWSTD_STATIC (type, bool, is_specialized, true);                                                                                                       _RWSTD_STATIC_FUN (type, min, cpfx##_MIN)                                   _RWSTD_STATIC_FUN (type, max, cpfx##_MAX)                                                                                                               _RWSTD_STATIC (type, bool, is_signed,  cpfx##_MIN != 0);                    _RWSTD_STATIC (type, bool, is_integer, true);                               _RWSTD_STATIC (type, bool, is_exact,   true);                                                                                                           _RWSTD_STATIC (type, int, digits,                                                          _RWSTD_DIGITS (type, cpfx##_MIN, cpfx##_MAX));                                                                                                                   _RWSTD_STATIC (type, int, digits10,                                                        _RWSTD_DIGITS10 (_RWSTD_DIGITS (type, cpfx##_MIN,                                                                 cpfx##_MAX)));                                                                                     _RWSTD_STATIC (type, int, radix, 2);                                                                                                         _RWSTD_STATIC_FUN (type, epsilon,     0)                                    _RWSTD_STATIC_FUN (type, round_error, 0)                                                                                                                _RWSTD_STATIC (type, int, min_exponent,   0);                               _RWSTD_STATIC (type, int, min_exponent10, 0);                               _RWSTD_STATIC (type, int, max_exponent,   0);                               _RWSTD_STATIC (type, int, max_exponent10, 0);                                                                                                           _RWSTD_STATIC (type, bool, has_infinity,             false);                _RWSTD_STATIC (type, bool, has_quiet_NaN,            false);                _RWSTD_STATIC (type, bool, has_signaling_NaN,        false);                _RWSTD_STATIC (type, float_denorm_style, has_denorm, denorm_absent);        _RWSTD_STATIC (type, bool, has_denorm_loss,          false);                                                                                            _RWSTD_STATIC_FUN (type, infinity,      0)                                  _RWSTD_STATIC_FUN (type, quiet_NaN,     0)                                  _RWSTD_STATIC_FUN (type, signaling_NaN, 0)                                  _RWSTD_STATIC_FUN (type, denorm_min,    0)                                                                                                              _RWSTD_STATIC (type, bool, is_iec559,  false);                              _RWSTD_STATIC (type, bool, is_bounded, true);                               _RWSTD_STATIC (type, bool, is_modulo,  1 != cpfx##_MAX);                                                                                                _RWSTD_STATIC (type, bool, traps,           false);                         _RWSTD_STATIC (type, bool, tinyness_before, false);                         _RWSTD_STATIC (type, float_round_style, round_style, round_toward_zero);                                                                                                       _RWSTD_TYPEDEF (conv_type _C_convertible)
N
N
N#undef _RWSTD_SPECIALIZE_LIMITS
N
N#define _RWSTD_SPECIALIZE_LIMITS(type, conv_type, cpfx)      \
N_RWSTD_CLASS_BEGIN (_RWSTD_SPECIALIZED_CLASS                 \
N                    class _RWSTD_EXPORT numeric_limits<type>) \
N    _RWSTD_LIMITS_BODY (type, conv_type, cpfx)               \
N_RWSTD_CLASS_END
X#define _RWSTD_SPECIALIZE_LIMITS(type, conv_type, cpfx)      _RWSTD_CLASS_BEGIN (_RWSTD_SPECIALIZED_CLASS                                     class _RWSTD_EXPORT numeric_limits<type>)     _RWSTD_LIMITS_BODY (type, conv_type, cpfx)               _RWSTD_CLASS_END
N
N
N#ifndef _RWSTD_LIMITS_TEMPLATE_DEFINED
N#define _RWSTD_LIMITS_TEMPLATE_DEFINED
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
Nenum float_round_style
N{
N    round_indeterminate       = -1,
N    round_toward_zero         =  0,
N    round_to_nearest          =  1,
N    round_toward_infinity     =  2,
N    round_toward_neg_infinity =  3
N};
N
Nenum float_denorm_style
N{
N    denorm_indeterminate = -1,
N    denorm_absent        =  0,
N    denorm_present       =  1
N};
N
Ntemplate <class _TypeT>
Nclass numeric_limits
N{
Npublic:
N    // static consts below must be initialized in class so that
N    // they can be used where const expressions are required (such
N    // as in template parameters)
N
N    _RWSTD_STATIC_CONST (bool, is_specialized = false);
X    static const bool is_specialized = false;
N
N    static _TypeT min () _THROWS (()) { return 0; }
X    static _TypeT min ()  { return 0; }
N    static _TypeT max () _THROWS (()) { return 0; }
X    static _TypeT max ()  { return 0; }
N
N    _RWSTD_STATIC_CONST (int, digits   = 0);
X    static const int digits = 0;
N    _RWSTD_STATIC_CONST (int, digits10 = 0);
X    static const int digits10 = 0;
N
N    _RWSTD_STATIC_CONST (bool, is_signed  = false);
X    static const bool is_signed = false;
N    _RWSTD_STATIC_CONST (bool, is_integer = false);
X    static const bool is_integer = false;
N    _RWSTD_STATIC_CONST (bool, is_exact   = false);
X    static const bool is_exact = false;
N
N    _RWSTD_STATIC_CONST (int, radix = 0);
X    static const int radix = 0;
N
N    static _TypeT epsilon () _THROWS (()) { return 0; }
X    static _TypeT epsilon ()  { return 0; }
N    static _TypeT round_error () _THROWS (()) { return 0; }
X    static _TypeT round_error ()  { return 0; }
N
N    _RWSTD_STATIC_CONST (int, min_exponent   = 0);
X    static const int min_exponent = 0;
N    _RWSTD_STATIC_CONST (int, min_exponent10 = 0);
X    static const int min_exponent10 = 0;
N    _RWSTD_STATIC_CONST (int, max_exponent   = 0);
X    static const int max_exponent = 0;
N    _RWSTD_STATIC_CONST (int, max_exponent10 = 0);
X    static const int max_exponent10 = 0;
N
N    _RWSTD_STATIC_CONST (bool, has_infinity             = false);
X    static const bool has_infinity = false;
N    _RWSTD_STATIC_CONST (bool, has_quiet_NaN            = false);
X    static const bool has_quiet_NaN = false;
N    _RWSTD_STATIC_CONST (bool, has_signaling_NaN        = false);
X    static const bool has_signaling_NaN = false;
N    _RWSTD_STATIC_CONST (float_denorm_style, has_denorm = denorm_absent);
X    static const float_denorm_style has_denorm = denorm_absent;
N    _RWSTD_STATIC_CONST (bool, has_denorm_loss          = false);
X    static const bool has_denorm_loss = false;
N
N    static _TypeT infinity () _THROWS (()) { return 0; }
X    static _TypeT infinity ()  { return 0; }
N    static _TypeT quiet_NaN () _THROWS (()) { return 0; }
X    static _TypeT quiet_NaN ()  { return 0; }
N    static _TypeT signaling_NaN () _THROWS (()) { return 0; }
X    static _TypeT signaling_NaN ()  { return 0; }
N    static _TypeT denorm_min () _THROWS (()) { return 0; }
X    static _TypeT denorm_min ()  { return 0; }
N
N    _RWSTD_STATIC_CONST (bool, is_iec559        = false);
X    static const bool is_iec559 = false;
N    _RWSTD_STATIC_CONST (bool, is_bounded       = false);
X    static const bool is_bounded = false;
N    _RWSTD_STATIC_CONST (bool, is_modulo        = false);
X    static const bool is_modulo = false;
N    _RWSTD_STATIC_CONST (bool, traps            = false);
X    static const bool traps = false;
N    _RWSTD_STATIC_CONST (bool, tinyness_before  = false);
X    static const bool tinyness_before = false;
N    _RWSTD_STATIC_CONST (float_round_style, round_style = round_toward_zero);
X    static const float_round_style round_style = round_toward_zero;
N};
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#endif   // _RWSTD_LIMITS_TEMPLATE_DEFINED
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N_RWSTD_CLASS_BEGIN (_RWSTD_SPECIALIZED_CLASS
N                    class _RWSTD_EXPORT numeric_limits<float>)
Xtemplate< > class numeric_limits<float> { public:
N
N    _RWSTD_STATIC (float, bool, is_specialized, true);
X    static const bool is_specialized = (true);
N
N    _RWSTD_STATIC_FUN (float, min, FLT_MIN)
X    static float min ()  { return 1.175494351e-38F; }
N    _RWSTD_STATIC_FUN (float, max, FLT_MAX)
X    static float max ()  { return 3.40282347e+38F; }
N
N    _RWSTD_STATIC (float, int, digits,   FLT_MANT_DIG);
X    static const int digits = (24);
N    _RWSTD_STATIC (float, int, digits10, FLT_DIG);
X    static const int digits10 = (6);
N
N    _RWSTD_STATIC (float, bool, is_signed,  true);
X    static const bool is_signed = (true);
N    _RWSTD_STATIC (float, bool, is_integer, false);
X    static const bool is_integer = (false);
N    _RWSTD_STATIC (float, bool, is_exact,   false);
X    static const bool is_exact = (false);
N    _RWSTD_STATIC (float, int,  radix,      FLT_RADIX);
X    static const int radix = (2);
N
N    _RWSTD_STATIC_FUN (float, epsilon,     FLT_EPSILON)
X    static float epsilon ()  { return 1.19209290e-7F; }
N    _RWSTD_STATIC_FUN (float, round_error, _RWSTD_FLT_ROUND_ERROR)
X    static float round_error ()  { return 0.5F; }
N
N    _RWSTD_STATIC (float, int, min_exponent,   FLT_MIN_EXP);
X    static const int min_exponent = ((-125));
N    _RWSTD_STATIC (float, int, min_exponent10, FLT_MIN_10_EXP);
X    static const int min_exponent10 = ((-37));
N    _RWSTD_STATIC (float, int, max_exponent,   FLT_MAX_EXP);
X    static const int max_exponent = (128);
N    _RWSTD_STATIC (float, int, max_exponent10, FLT_MAX_10_EXP);
X    static const int max_exponent10 = (38);
N
N    _RWSTD_STATIC (float, bool, has_infinity,      _RWSTD_HAS_INFINITY);
X    static const bool has_infinity = (true);
N    _RWSTD_STATIC (float, bool, has_quiet_NaN,     _RWSTD_HAS_QUIET_NAN);
X    static const bool has_quiet_NaN = (true);
N    _RWSTD_STATIC (float, bool, has_signaling_NaN, _RWSTD_HAS_SIG_NAN);
X    static const bool has_signaling_NaN = (true);
N    _RWSTD_STATIC (float, float_denorm_style, has_denorm,
N                   _RWSTD_HAS_DENORM);
X    static const float_denorm_style has_denorm = (denorm_absent);
N    _RWSTD_STATIC (float, bool, has_denorm_loss, _RWSTD_HAS_DENORM_LOSS);
X    static const bool has_denorm_loss = (false);
N
N#ifndef __has_builtin
S  #define __has_builtin(x) 0
N#endif
N
N#if __has_builtin(__builtin_inf)
X#if 0
S    _RWSTD_STATIC_FUN (float, infinity,      __builtin_inff()) // VENDOR
S    _RWSTD_STATIC_FUN (float, quiet_NaN,     __builtin_nanf("")) // VENDOR
S    _RWSTD_STATIC_FUN (float, signaling_NaN, __builtin_nansf("")) // VENDOR
N#else
N    _RWSTD_STATIC_FUN (float, infinity,      __ESCAPE__(0f_7F800000)) // VENDOR
X    static float infinity ()  { return __ESCAPE__(0f_7F800000); } 
N    _RWSTD_STATIC_FUN (float, quiet_NaN,     __ESCAPE__(0f_7FC00000)) // VENDOR
X    static float quiet_NaN ()  { return __ESCAPE__(0f_7FC00000); } 
N    _RWSTD_STATIC_FUN (float, signaling_NaN, __ESCAPE__(0f_7F800001)) // VENDOR
X    static float signaling_NaN ()  { return __ESCAPE__(0f_7F800001); } 
N#endif
N    _RWSTD_STATIC_FUN (float, denorm_min,    _RWSTD_FLT_DENORM_MIN) // VENDOR
X    static float denorm_min ()  { return 1.175494351e-38F; } 
N
N    _RWSTD_STATIC (float, bool, is_iec559,  _RWSTD_IS_IEC559);    // VENDOR
X    static const bool is_iec559 = (false);    
N    _RWSTD_STATIC (float, bool, is_bounded, true);
X    static const bool is_bounded = (true);
N    _RWSTD_STATIC (float, bool, is_modulo,  false);               // VENDOR
X    static const bool is_modulo = (false);               
N
N    _RWSTD_STATIC (float, bool, traps, true);                    // VENDOR
X    static const bool traps = (true);                    
N    _RWSTD_STATIC (float, bool, tinyness_before, false);          // VENDOR
X    static const bool tinyness_before = (false);          
N
N    _RWSTD_STATIC_ROUNDS (float, float_round_style, round_style, FLT_ROUNDS);
X    static const float_round_style  round_style;
N
N     // extension: type converts to without loss of data
N    _RWSTD_TYPEDEF (double _C_convertible)
X    typedef double _C_convertible;
N
N_RWSTD_CLASS_END   // numeric_limits<float>
X};   
N
N
N_RWSTD_CLASS_BEGIN (_RWSTD_SPECIALIZED_CLASS
N                    class _RWSTD_EXPORT numeric_limits<double>)
Xtemplate< > class numeric_limits<double> { public:
N
N    _RWSTD_STATIC (double, bool, is_specialized, true);
X    static const bool is_specialized = (true);
N
N    _RWSTD_STATIC_FUN (double, min, DBL_MIN)
X    static double min ()  { return 2.22507385850720138e-308; }
N    _RWSTD_STATIC_FUN (double, max, DBL_MAX)
X    static double max ()  { return 1.79769313486231571e+308; }
N
N    _RWSTD_STATIC (double, int, digits,   DBL_MANT_DIG);
X    static const int digits = (53);
N    _RWSTD_STATIC (double, int, digits10, DBL_DIG);
X    static const int digits10 = (15);
N
N    _RWSTD_STATIC (double, bool, is_signed,  true);
X    static const bool is_signed = (true);
N    _RWSTD_STATIC (double, bool, is_integer, false);
X    static const bool is_integer = (false);
N    _RWSTD_STATIC (double, bool, is_exact,   false);
X    static const bool is_exact = (false);
N    _RWSTD_STATIC (double, int,  radix,      FLT_RADIX);
X    static const int radix = (2);
N
N    _RWSTD_STATIC_FUN (double, epsilon,     DBL_EPSILON)
X    static double epsilon ()  { return 2.2204460492503131e-16; }
N    _RWSTD_STATIC_FUN (double, round_error, _RWSTD_DBL_ROUND_ERROR)
X    static double round_error ()  { return 0.5; }
N
N    _RWSTD_STATIC (double, int, min_exponent,   DBL_MIN_EXP);
X    static const int min_exponent = ((-1021));
N    _RWSTD_STATIC (double, int, min_exponent10, DBL_MIN_10_EXP);
X    static const int min_exponent10 = ((-307));
N    _RWSTD_STATIC (double, int, max_exponent,   DBL_MAX_EXP);
X    static const int max_exponent = (1024);
N    _RWSTD_STATIC (double, int, max_exponent10, DBL_MAX_10_EXP);
X    static const int max_exponent10 = (308);
N
N    _RWSTD_STATIC (double, bool, has_infinity,      _RWSTD_HAS_INFINITY);
X    static const bool has_infinity = (true);
N    _RWSTD_STATIC (double, bool, has_quiet_NaN,     _RWSTD_HAS_QUIET_NAN);
X    static const bool has_quiet_NaN = (true);
N    _RWSTD_STATIC (double, bool, has_signaling_NaN, _RWSTD_HAS_SIG_NAN);
X    static const bool has_signaling_NaN = (true);
N    _RWSTD_STATIC (double, float_denorm_style, has_denorm,
N                   _RWSTD_HAS_DENORM);
X    static const float_denorm_style has_denorm = (denorm_absent);
N    _RWSTD_STATIC (double, bool, has_denorm_loss,   _RWSTD_HAS_DENORM_LOSS);
X    static const bool has_denorm_loss = (false);
N
N#if __has_builtin(__builtin_inf)
X#if 0
S    _RWSTD_STATIC_FUN (double, infinity,      __builtin_inf())   // VENDOR
S    _RWSTD_STATIC_FUN (double, quiet_NaN,     __builtin_nan(""))   // VENDOR
S    _RWSTD_STATIC_FUN (double, signaling_NaN, __builtin_nans(""))   // VENDOR
N#else
N    _RWSTD_STATIC_FUN (double, infinity,      __ESCAPE__(0d_7FF0000000000000))   // VENDOR
X    static double infinity ()  { return __ESCAPE__(0d_7FF0000000000000); }   
N    _RWSTD_STATIC_FUN (double, quiet_NaN,     __ESCAPE__(0d_7FF8000000000000))   // VENDOR
X    static double quiet_NaN ()  { return __ESCAPE__(0d_7FF8000000000000); }   
N    _RWSTD_STATIC_FUN (double, signaling_NaN, __ESCAPE__(0d_7FF0000000000001))   // VENDOR
X    static double signaling_NaN ()  { return __ESCAPE__(0d_7FF0000000000001); }   
N#endif
N    _RWSTD_STATIC_FUN (double, denorm_min,    _RWSTD_DBL_DENORM_MIN)
X    static double denorm_min ()  { return 2.22507385850720138e-308; }
N
N    _RWSTD_STATIC (double, bool, is_iec559,  _RWSTD_IS_IEC559);
X    static const bool is_iec559 = (false);
N    _RWSTD_STATIC (double, bool, is_bounded, true);
X    static const bool is_bounded = (true);
N    _RWSTD_STATIC (double, bool, is_modulo,  false);              // VENDOR
X    static const bool is_modulo = (false);              
N
N    _RWSTD_STATIC (double, bool, traps, true);                   // VENDOR
X    static const bool traps = (true);                   
N    _RWSTD_STATIC (double, bool, tinyness_before, false);         // VENDOR
X    static const bool tinyness_before = (false);         
N
N    _RWSTD_STATIC_ROUNDS (double, float_round_style, round_style, FLT_ROUNDS);
X    static const float_round_style  round_style;
N
N     // extension: type converts to without loss of data
N    _RWSTD_TYPEDEF (long double _C_convertible)
X    typedef long double _C_convertible;
N
N_RWSTD_CLASS_END   // numeric_limits<double>
X};   
N
N
N#ifndef _RWSTD_NO_LONG_DOUBLE
N
N_RWSTD_CLASS_BEGIN (_RWSTD_SPECIALIZED_CLASS
N                    class _RWSTD_EXPORT numeric_limits<long double>)
Xtemplate< > class numeric_limits<long double> { public:
N
N    _RWSTD_STATIC (long double, bool, is_specialized, true);
X    static const bool is_specialized = (true);
N
N    _RWSTD_STATIC_FUN (long double, min, LDBL_MIN) 
X    static long double min ()  { return 2.22507385850720138e-308L; } 
N    _RWSTD_STATIC_FUN (long double, max, LDBL_MAX) 
X    static long double max ()  { return 1.79769313486231571e+308L; } 
N
N    _RWSTD_STATIC (long double, int, digits,   LDBL_MANT_DIG);
X    static const int digits = (53);
N    _RWSTD_STATIC (long double, int, digits10, LDBL_DIG);
X    static const int digits10 = (15);
N
N    _RWSTD_STATIC (long double, bool, is_signed,  true);
X    static const bool is_signed = (true);
N    _RWSTD_STATIC (long double, bool, is_integer, false);
X    static const bool is_integer = (false);
N    _RWSTD_STATIC (long double, bool, is_exact,   false);
X    static const bool is_exact = (false);
N    _RWSTD_STATIC (long double, int,  radix,      FLT_RADIX);
X    static const int radix = (2);
N
N    _RWSTD_STATIC_FUN (long double, epsilon,     LDBL_EPSILON) 
X    static long double epsilon ()  { return 2.2204460492503131e-16L; } 
N    _RWSTD_STATIC_FUN (long double, round_error, _RWSTD_LDBL_ROUND_ERROR)
X    static long double round_error ()  { return 0.5L; }
N
N    _RWSTD_STATIC (long double, int, min_exponent,   LDBL_MIN_EXP);
X    static const int min_exponent = ((-1021));
N    _RWSTD_STATIC (long double, int, min_exponent10, LDBL_MIN_10_EXP);
X    static const int min_exponent10 = ((-307));
N    _RWSTD_STATIC (long double, int, max_exponent,   LDBL_MAX_EXP);
X    static const int max_exponent = (1024);
N    _RWSTD_STATIC (long double, int, max_exponent10, LDBL_MAX_10_EXP);
X    static const int max_exponent10 = (308);
N
N    _RWSTD_STATIC (long double, bool, has_infinity,      _RWSTD_HAS_INFINITY);
X    static const bool has_infinity = (true);
N    _RWSTD_STATIC (long double, bool, has_quiet_NaN,     _RWSTD_HAS_QUIET_NAN);
X    static const bool has_quiet_NaN = (true);
N    _RWSTD_STATIC (long double, bool, has_signaling_NaN, _RWSTD_HAS_SIG_NAN);
X    static const bool has_signaling_NaN = (true);
N    _RWSTD_STATIC (long double, float_denorm_style, has_denorm,
N                   denorm_indeterminate);
X    static const float_denorm_style has_denorm = (denorm_indeterminate);
N    _RWSTD_STATIC (long double, bool, has_denorm_loss, _RWSTD_HAS_DENORM_LOSS);
X    static const bool has_denorm_loss = (false);
N
N#if __has_builtin(__builtin_inf)
X#if 0
S    _RWSTD_STATIC_FUN (long double, infinity,      __builtin_inf())   // VENDOR
S    _RWSTD_STATIC_FUN (long double, quiet_NaN,     __builtin_nan(""))   // VENDOR
S    _RWSTD_STATIC_FUN (long double, signaling_NaN, __builtin_nans(""))   // VENDOR
N#else
N    _RWSTD_STATIC_FUN (long double, infinity,      __ESCAPE__(0d_7FF0000000000000))   // VENDOR
X    static long double infinity ()  { return __ESCAPE__(0d_7FF0000000000000); }   
N    _RWSTD_STATIC_FUN (long double, quiet_NaN,     __ESCAPE__(0d_7FF8000000000000))   // VENDOR
X    static long double quiet_NaN ()  { return __ESCAPE__(0d_7FF8000000000000); }   
N    _RWSTD_STATIC_FUN (long double, signaling_NaN, __ESCAPE__(0d_7FF0000000000001))   // VENDOR
X    static long double signaling_NaN ()  { return __ESCAPE__(0d_7FF0000000000001); }   
N#endif
N    _RWSTD_STATIC_FUN (long double, denorm_min,    _RWSTD_LDBL_DENORM_MIN)
X    static long double denorm_min ()  { return 2.22507385850720138e-308L; }
N
N    _RWSTD_STATIC (long double, bool, is_iec559,  _RWSTD_IS_IEC559);
X    static const bool is_iec559 = (false);
N    _RWSTD_STATIC (long double, bool, is_bounded, true);
X    static const bool is_bounded = (true);
N    _RWSTD_STATIC (long double, bool, is_modulo,  false);         // VENDOR
X    static const bool is_modulo = (false);         
N
N    _RWSTD_STATIC (long double, bool, traps, true);              // VENDOR
X    static const bool traps = (true);              
N    _RWSTD_STATIC (long double, bool, tinyness_before, false);    // VENDOR
X    static const bool tinyness_before = (false);    
N
N    _RWSTD_STATIC_ROUNDS (long double, float_round_style, round_style,
N                          FLT_ROUNDS);
X    static const float_round_style  round_style;
N
N     // extension: type converts to without loss of data
N    _RWSTD_TYPEDEF (long double _C_convertible)
X    typedef long double _C_convertible;
N
N_RWSTD_CLASS_END    // numeric_limits<long double>
X};    
N
N#endif   // _RWSTD_NO_LONG_DOUBLE
N
N
N#define _RWSTD_UCHAR_MIN 0
N#define _RWSTD_USHRT_MIN 0
N#define _RWSTD_UINT_MIN  0
N#define _RWSTD_ULONG_MIN 0
N
N#define _RWSTD_UCHAR_MAX UCHAR_MAX
N#define _RWSTD_USHRT_MAX USHRT_MAX
N#define _RWSTD_UINT_MAX  UINT_MAX
N#define _RWSTD_ULONG_MAX ULONG_MAX
N
N
N// types each integral type converts to with no loss of precision (if possible)
N#ifdef _RWSTD_LONG_LONG
N#  if UINT_MAX < ULONG_MAX
X#  if 0xffffffffU < 0xffffffffUL
S#    define _RWSTD_INT_CONVERTIBLE long
N#  else
N#    define _RWSTD_INT_CONVERTIBLE _RWSTD_LONG_LONG
N#  endif
N#  define _RWSTD_LONG_CONVERTIBLE  _RWSTD_LONG_LONG
N#else   // if !defined (_RWSTD_LONG_LONG)
S#  define _RWSTD_INT_CONVERTIBLE  long
S#  define _RWSTD_LONG_CONVERTIBLE long
N#endif   // _RWSTD_LONG_LONG
N
N
N#if UCHAR_MAX < UINT_MAX
X#if 255 < 0xffffffffU
N#  define _RWSTD_CHAR_CONVERTIBLE int
N#else
S#  define _RWSTD_CHAR_CONVERTIBLE _RWSTD_INT_CONVERTIBLE
N#endif   // UCHAR_MAX < UINT_MAX
N
N
N#if USHRT_MAX < UINT_MAX
X#if 65535 < 0xffffffffU
N#  define _RWSTD_SHORT_CONVERTIBLE int
N#else
S#  define _RWSTD_SHORT_CONVERTIBLE _RWSTD_INT_CONVERTIBLE
N#endif   // USHRT_MAX < UINT_MAX
N
N
N// define numeric_limits<> integral specializations
N_RWSTD_SPECIALIZE_LIMITS (char, _RWSTD_CHAR_CONVERTIBLE, CHAR)
Xtemplate< > class numeric_limits<char> { public: static const bool is_specialized = (true); static char min ()  { return 0; } static char max ()  { return 255; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (255) ? 1 : (8 * sizeof (char) - ((0) != 0)))); static const int digits10 = (((((1 == (255) ? 1 : (8 * sizeof (char) - ((0) != 0)))) * 301) / 1000)); static const int radix = (2); static char epsilon ()  { return 0; } static char round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static char infinity ()  { return 0; } static char quiet_NaN ()  { return 0; } static char signaling_NaN ()  { return 0; } static char denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 255); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef int _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (unsigned char,
N                          unsigned _RWSTD_CHAR_CONVERTIBLE, _RWSTD_UCHAR)
Xtemplate< > class numeric_limits<unsigned char> { public: static const bool is_specialized = (true); static unsigned char min ()  { return 0; } static unsigned char max ()  { return 255; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (255) ? 1 : (8 * sizeof (unsigned char) - ((0) != 0)))); static const int digits10 = (((((1 == (255) ? 1 : (8 * sizeof (unsigned char) - ((0) != 0)))) * 301) / 1000)); static const int radix = (2); static unsigned char epsilon ()  { return 0; } static unsigned char round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static unsigned char infinity ()  { return 0; } static unsigned char quiet_NaN ()  { return 0; } static unsigned char signaling_NaN ()  { return 0; } static unsigned char denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 255); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef unsigned int _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (signed char, _RWSTD_CHAR_CONVERTIBLE, SCHAR)
Xtemplate< > class numeric_limits<signed char> { public: static const bool is_specialized = (true); static signed char min ()  { return (-128); } static signed char max ()  { return 127; } static const bool is_signed = ((-128) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (127) ? 1 : (8 * sizeof (signed char) - (((-128)) != 0)))); static const int digits10 = (((((1 == (127) ? 1 : (8 * sizeof (signed char) - (((-128)) != 0)))) * 301) / 1000)); static const int radix = (2); static signed char epsilon ()  { return 0; } static signed char round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static signed char infinity ()  { return 0; } static signed char quiet_NaN ()  { return 0; } static signed char signaling_NaN ()  { return 0; } static signed char denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 127); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef int _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (short int, _RWSTD_SHORT_CONVERTIBLE, SHRT)
Xtemplate< > class numeric_limits<short int> { public: static const bool is_specialized = (true); static short int min ()  { return (-0x8000); } static short int max ()  { return 0x7fff; } static const bool is_signed = ((-0x8000) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0x7fff) ? 1 : (8 * sizeof (short int) - (((-0x8000)) != 0)))); static const int digits10 = (((((1 == (0x7fff) ? 1 : (8 * sizeof (short int) - (((-0x8000)) != 0)))) * 301) / 1000)); static const int radix = (2); static short int epsilon ()  { return 0; } static short int round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static short int infinity ()  { return 0; } static short int quiet_NaN ()  { return 0; } static short int signaling_NaN ()  { return 0; } static short int denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0x7fff); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef int _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (unsigned short,
N                          unsigned _RWSTD_SHORT_CONVERTIBLE, _RWSTD_USHRT)
Xtemplate< > class numeric_limits<unsigned short> { public: static const bool is_specialized = (true); static unsigned short min ()  { return 0; } static unsigned short max ()  { return 65535; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (65535) ? 1 : (8 * sizeof (unsigned short) - ((0) != 0)))); static const int digits10 = (((((1 == (65535) ? 1 : (8 * sizeof (unsigned short) - ((0) != 0)))) * 301) / 1000)); static const int radix = (2); static unsigned short epsilon ()  { return 0; } static unsigned short round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static unsigned short infinity ()  { return 0; } static unsigned short quiet_NaN ()  { return 0; } static unsigned short signaling_NaN ()  { return 0; } static unsigned short denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 65535); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef unsigned int _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (int, _RWSTD_INT_CONVERTIBLE, INT)
Xtemplate< > class numeric_limits<int> { public: static const bool is_specialized = (true); static int min ()  { return (~0x7fffffff); } static int max ()  { return 0x7fffffff; } static const bool is_signed = ((~0x7fffffff) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0x7fffffff) ? 1 : (8 * sizeof (int) - (((~0x7fffffff)) != 0)))); static const int digits10 = (((((1 == (0x7fffffff) ? 1 : (8 * sizeof (int) - (((~0x7fffffff)) != 0)))) * 301) / 1000)); static const int radix = (2); static int epsilon ()  { return 0; } static int round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static int infinity ()  { return 0; } static int quiet_NaN ()  { return 0; } static int signaling_NaN ()  { return 0; } static int denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0x7fffffff); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef __int64 _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (unsigned int,
N                          unsigned _RWSTD_INT_CONVERTIBLE, _RWSTD_UINT)
Xtemplate< > class numeric_limits<unsigned int> { public: static const bool is_specialized = (true); static unsigned int min ()  { return 0; } static unsigned int max ()  { return 0xffffffffU; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0xffffffffU) ? 1 : (8 * sizeof (unsigned int) - ((0) != 0)))); static const int digits10 = (((((1 == (0xffffffffU) ? 1 : (8 * sizeof (unsigned int) - ((0) != 0)))) * 301) / 1000)); static const int radix = (2); static unsigned int epsilon ()  { return 0; } static unsigned int round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static unsigned int infinity ()  { return 0; } static unsigned int quiet_NaN ()  { return 0; } static unsigned int signaling_NaN ()  { return 0; } static unsigned int denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0xffffffffU); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef unsigned __int64 _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (long int, _RWSTD_LONG_CONVERTIBLE, LONG)
Xtemplate< > class numeric_limits<long int> { public: static const bool is_specialized = (true); static long int min ()  { return (~0x7fffffffL); } static long int max ()  { return 0x7fffffffL; } static const bool is_signed = ((~0x7fffffffL) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0x7fffffffL) ? 1 : (8 * sizeof (long int) - (((~0x7fffffffL)) != 0)))); static const int digits10 = (((((1 == (0x7fffffffL) ? 1 : (8 * sizeof (long int) - (((~0x7fffffffL)) != 0)))) * 301) / 1000)); static const int radix = (2); static long int epsilon ()  { return 0; } static long int round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static long int infinity ()  { return 0; } static long int quiet_NaN ()  { return 0; } static long int signaling_NaN ()  { return 0; } static long int denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0x7fffffffL); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef __int64 _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (unsigned long int,
N                          unsigned _RWSTD_LONG_CONVERTIBLE, _RWSTD_ULONG)
Xtemplate< > class numeric_limits<unsigned long int> { public: static const bool is_specialized = (true); static unsigned long int min ()  { return 0; } static unsigned long int max ()  { return 0xffffffffUL; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0xffffffffUL) ? 1 : (8 * sizeof (unsigned long int) - ((0) != 0)))); static const int digits10 = (((((1 == (0xffffffffUL) ? 1 : (8 * sizeof (unsigned long int) - ((0) != 0)))) * 301) / 1000)); static const int radix = (2); static unsigned long int epsilon ()  { return 0; } static unsigned long int round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static unsigned long int infinity ()  { return 0; } static unsigned long int quiet_NaN ()  { return 0; } static unsigned long int signaling_NaN ()  { return 0; } static unsigned long int denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0xffffffffUL); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef unsigned __int64 _C_convertible; };
N
N
N#undef _RWSTD_UCHAR_MIN
N#undef _RWSTD_USHRT_MIN
N#undef _RWSTD_UINT_MIN
N#undef _RWSTD_ULONG_MIN
N
N#undef _RWSTD_UCHAR_MAX
N#undef _RWSTD_USHRT_MAX
N#undef _RWSTD_UINT_MAX
N#undef _RWSTD_ULONG_MAX
N
N#ifndef _RWSTD_NO_NATIVE_WCHAR_T
N
N#  define _RWSTD_WCHAR_MIN                                   \
N          (  wchar_t (-1) > 0 ? 0                            \
N           : sizeof (wchar_t) == sizeof (short) ? SHRT_MIN   \
N           : sizeof (wchar_t) == sizeof (int)   ? INT_MIN    \
N           : sizeof (wchar_t) == sizeof (long)  ? LONG_MIN   \
N           : SCHAR_MIN)
X#  define _RWSTD_WCHAR_MIN                                             (  wchar_t (-1) > 0 ? 0                                       : sizeof (wchar_t) == sizeof (short) ? SHRT_MIN              : sizeof (wchar_t) == sizeof (int)   ? INT_MIN               : sizeof (wchar_t) == sizeof (long)  ? LONG_MIN              : SCHAR_MIN)
N                        
N#  define _RWSTD_WCHAR_MAX                                       \
N          (  wchar_t (-1) > 0 ?                                  \
N             (  sizeof (wchar_t) == sizeof (short) ? USHRT_MAX   \
N              : sizeof (wchar_t) == sizeof (int)   ? UINT_MAX    \
N              : sizeof (wchar_t) == sizeof (long)  ? ULONG_MAX   \
N              : SCHAR_MAX)                                       \
N           : (  sizeof (wchar_t) == sizeof (short) ? SHRT_MAX    \
N              : sizeof (wchar_t) == sizeof (int)   ? INT_MAX     \
N              : sizeof (wchar_t) == sizeof (long)  ? LONG_MAX    \
N              : UCHAR_MAX))
X#  define _RWSTD_WCHAR_MAX                                                 (  wchar_t (-1) > 0 ?                                               (  sizeof (wchar_t) == sizeof (short) ? USHRT_MAX                 : sizeof (wchar_t) == sizeof (int)   ? UINT_MAX                  : sizeof (wchar_t) == sizeof (long)  ? ULONG_MAX                 : SCHAR_MAX)                                                  : (  sizeof (wchar_t) == sizeof (short) ? SHRT_MAX                  : sizeof (wchar_t) == sizeof (int)   ? INT_MAX                   : sizeof (wchar_t) == sizeof (long)  ? LONG_MAX                  : UCHAR_MAX))
N
N
N_RWSTD_SPECIALIZE_LIMITS (wchar_t, _RWSTD_INT_CONVERTIBLE, _RWSTD_WCHAR)
Xtemplate< > class numeric_limits<wchar_t> { public: static const bool is_specialized = (true); static wchar_t min ()  { return ( wchar_t (-1) > 0 ? 0 : sizeof (wchar_t) == sizeof (short) ? (-0x8000) : sizeof (wchar_t) == sizeof (int) ? (~0x7fffffff) : sizeof (wchar_t) == sizeof (long) ? (~0x7fffffffL) : (-128)); } static wchar_t max ()  { return ( wchar_t (-1) > 0 ? ( sizeof (wchar_t) == sizeof (short) ? 65535 : sizeof (wchar_t) == sizeof (int) ? 0xffffffffU : sizeof (wchar_t) == sizeof (long) ? 0xffffffffUL : 127) : ( sizeof (wchar_t) == sizeof (short) ? 0x7fff : sizeof (wchar_t) == sizeof (int) ? 0x7fffffff : sizeof (wchar_t) == sizeof (long) ? 0x7fffffffL : 255)); } static const bool is_signed = (( wchar_t (-1) > 0 ? 0 : sizeof (wchar_t) == sizeof (short) ? (-0x8000) : sizeof (wchar_t) == sizeof (int) ? (~0x7fffffff) : sizeof (wchar_t) == sizeof (long) ? (~0x7fffffffL) : (-128)) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (( wchar_t (-1) > 0 ? ( sizeof (wchar_t) == sizeof (short) ? 65535 : sizeof (wchar_t) == sizeof (int) ? 0xffffffffU : sizeof (wchar_t) == sizeof (long) ? 0xffffffffUL : 127) : ( sizeof (wchar_t) == sizeof (short) ? 0x7fff : sizeof (wchar_t) == sizeof (int) ? 0x7fffffff : sizeof (wchar_t) == sizeof (long) ? 0x7fffffffL : 255))) ? 1 : (8 * sizeof (wchar_t) - ((( wchar_t (-1) > 0 ? 0 : sizeof (wchar_t) == sizeof (short) ? (-0x8000) : sizeof (wchar_t) == sizeof (int) ? (~0x7fffffff) : sizeof (wchar_t) == sizeof (long) ? (~0x7fffffffL) : (-128))) != 0)))); static const int digits10 = (((((1 == (( wchar_t (-1) > 0 ? ( sizeof (wchar_t) == sizeof (short) ? 65535 : sizeof (wchar_t) == sizeof (int) ? 0xffffffffU : sizeof (wchar_t) == sizeof (long) ? 0xffffffffUL : 127) : ( sizeof (wchar_t) == sizeof (short) ? 0x7fff : sizeof (wchar_t) == sizeof (int) ? 0x7fffffff : sizeof (wchar_t) == sizeof (long) ? 0x7fffffffL : 255))) ? 1 : (8 * sizeof (wchar_t) - ((( wchar_t (-1) > 0 ? 0 : sizeof (wchar_t) == sizeof (short) ? (-0x8000) : sizeof (wchar_t) == sizeof (int) ? (~0x7fffffff) : sizeof (wchar_t) == sizeof (long) ? (~0x7fffffffL) : (-128))) != 0)))) * 301) / 1000)); static const int radix = (2); static wchar_t epsilon ()  { return 0; } static wchar_t round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static wchar_t infinity ()  { return 0; } static wchar_t quiet_NaN ()  { return 0; } static wchar_t signaling_NaN ()  { return 0; } static wchar_t denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != ( wchar_t (-1) > 0 ? ( sizeof (wchar_t) == sizeof (short) ? 65535 : sizeof (wchar_t) == sizeof (int) ? 0xffffffffU : sizeof (wchar_t) == sizeof (long) ? 0xffffffffUL : 127) : ( sizeof (wchar_t) == sizeof (short) ? 0x7fff : sizeof (wchar_t) == sizeof (int) ? 0x7fffffff : sizeof (wchar_t) == sizeof (long) ? 0x7fffffffL : 255))); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef __int64 _C_convertible; };
N
N#  undef _RWSTD_WCHAR_MIN
N#  undef _RWSTD_WCHAR_MAX
N
N#endif   // _RWSTD_NO_NATIVE_WCHAR_T
N
N
N#ifndef _RWSTD_NO_BOOL
N
N#  define _RWSTD_BOOL_MIN   false
N#  define _RWSTD_BOOL_MAX   true
N
N_RWSTD_SPECIALIZE_LIMITS (bool, int, _RWSTD_BOOL)
Xtemplate< > class numeric_limits<bool> { public: static const bool is_specialized = (true); static bool min ()  { return false; } static bool max ()  { return true; } static const bool is_signed = (false != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (true) ? 1 : (8 * sizeof (bool) - ((false) != 0)))); static const int digits10 = (((((1 == (true) ? 1 : (8 * sizeof (bool) - ((false) != 0)))) * 301) / 1000)); static const int radix = (2); static bool epsilon ()  { return 0; } static bool round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static bool infinity ()  { return 0; } static bool quiet_NaN ()  { return 0; } static bool signaling_NaN ()  { return 0; } static bool denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != true); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef int _C_convertible; };
N
N#  undef _RWSTD_BOOL_MIN
N#  undef _RWSTD_BOOL_MAX
N
N#endif   // _RWSTD_NO_BOOL
N
N
N#ifdef _RWSTD_LONG_LONG                                             // VENDOR
N
N#  if defined (_WIN32) && defined (_MSC_VER)
X#  if 0L && 0L
S#    define LONG_LONG_MIN   _I64_MIN
S#    define LONG_LONG_MAX   _I64_MAX
S#    define ULONG_LONG_MAX  _UI64_MAX
N#  else   // if !(defined (_WIN32) && defined (_MSC_VER))
N
N#  ifndef LONG_LONG_MIN
N#    ifndef LLONG_MIN
S       // assuming modulo 2 representation and a working shift
S#      define LONG_LONG_MIN \
S          (((_RWSTD_LONG_LONG)1) << (sizeof (_RWSTD_LONG_LONG) * CHAR_BIT - 1))
X#      define LONG_LONG_MIN           (((_RWSTD_LONG_LONG)1) << (sizeof (_RWSTD_LONG_LONG) * CHAR_BIT - 1))
S#      define LONG_LONG_MAX   (~LONG_LONG_MIN)
S#      define ULONG_LONG_MAX  (~(unsigned _RWSTD_LONG_LONG)0)
N#    else   // if defined (LLONG_MIN)
N       // e.g., Sun libc 
N#      define LONG_LONG_MIN   LLONG_MIN
N#      define LONG_LONG_MAX   LLONG_MAX
N#      define ULONG_LONG_MAX  ULLONG_MAX
N#    endif   // LLONG_MIN
N#  endif   // LONG_LONG_MIN
N
N#endif   // _WIN32 && _MSC_VER
N
N#  define ULONG_LONG_MIN   0
N
N_RWSTD_SPECIALIZE_LIMITS (_RWSTD_LONG_LONG, _RWSTD_LONG_LONG, LONG_LONG)
Xtemplate< > class numeric_limits<__int64> { public: static const bool is_specialized = (true); static __int64 min ()  { return (~0x7fffffffffffffffLL); } static __int64 max ()  { return 0x7fffffffffffffffLL; } static const bool is_signed = ((~0x7fffffffffffffffLL) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0x7fffffffffffffffLL) ? 1 : (8 * sizeof (__int64) - (((~0x7fffffffffffffffLL)) != 0)))); static const int digits10 = (((((1 == (0x7fffffffffffffffLL) ? 1 : (8 * sizeof (__int64) - (((~0x7fffffffffffffffLL)) != 0)))) * 301) / 1000)); static const int radix = (2); static __int64 epsilon ()  { return 0; } static __int64 round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static __int64 infinity ()  { return 0; } static __int64 quiet_NaN ()  { return 0; } static __int64 signaling_NaN ()  { return 0; } static __int64 denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0x7fffffffffffffffLL); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef __int64 _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (unsigned _RWSTD_LONG_LONG,
N                          unsigned _RWSTD_LONG_LONG, ULONG_LONG)
Xtemplate< > class numeric_limits<unsigned __int64> { public: static const bool is_specialized = (true); static unsigned __int64 min ()  { return 0; } static unsigned __int64 max ()  { return 0xffffffffffffffffULL; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0xffffffffffffffffULL) ? 1 : (8 * sizeof (unsigned __int64) - ((0) != 0)))); static const int digits10 = (((((1 == (0xffffffffffffffffULL) ? 1 : (8 * sizeof (unsigned __int64) - ((0) != 0)))) * 301) / 1000)); static const int radix = (2); static unsigned __int64 epsilon ()  { return 0; } static unsigned __int64 round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static unsigned __int64 infinity ()  { return 0; } static unsigned __int64 quiet_NaN ()  { return 0; } static unsigned __int64 signaling_NaN ()  { return 0; } static unsigned __int64 denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0xffffffffffffffffULL); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef unsigned __int64 _C_convertible; };
N
N#  undef ULONG_LONG_MIN 
N
N#endif   // _RWSTD_LONG_LONG
N
N
N#undef _RWSTD_CHAR_CONVERTIBLE
N#undef _RWSTD_SHORT_CONVERTIBLE
N#undef _RWSTD_INT_CONVERTIBLE
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#ifdef _RWSTD_COMPILE_INSTANTIATE
S#  include <limits.cc>
N#endif
N
N#endif   // _RWSTD_LIMITS_INCLUDED
N
L 49 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\vector" 2
N#include <memory>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\memory" 1
N// -*- C++ -*-
N/***************************************************************************
N *
N * memory - declarations for the Standard Library memory implementation
N *
N * $Id: memory 173524 2012-02-07 16:46:27Z ismith $ 
N *
N ***************************************************************************
N *
N * Copyright (c) 1994
N * Hewlett-Packard Company
N *
N * Permission to use, copy, modify, distribute and sell this software
N * and its documentation for any purpose is hereby granted without fee,
N * provided that the above copyright notice appear in all copies and
N * that both that copyright notice and this permission notice appear
N * in supporting documentation.  Hewlett-Packard Company makes no
N * representations about the suitability of this software for any
N * purpose.  It is provided "as is" without express or implied warranty.
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/ 
N
N#ifndef _RWSTD_MEMORY_INCLUDED
N#define _RWSTD_MEMORY_INCLUDED
N
N#include <new>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\new" 1
N/*
N * C++ Library file new
N * Copyright 1993-2001 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision: 185828 $
N * Checkin $Date: 2014-06-18 17:10:58 +0100 (Wed, 18 Jun 2014) $
N * Revising $Author: ricbar01 $
N */
N
N/* Edison Design Group, 1992-2013. */
N/*
Nnew -- Include file for C++ default operator new (see ARM 12.5).
N*/
N
N#ifndef __NEW_STDH
N#define __NEW_STDH
N#ifndef __STDDEF_H
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5050106
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
N        namespace std {
N        #define __CLIBNS ::std::
N        extern "C" {
N    #else
S      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 1L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
S  #if !defined(__STRICT_ANSI__)
S  /* unconditional in non-strict C for consistency of debug info */
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
S  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N    #ifdef __cplusplus
N         }  /* extern "C" */
N      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
N    #ifndef __STDDEF_NO_EXPORTS
N      using ::std::size_t;
N      using ::std::ptrdiff_t;
N    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 21 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\new" 2
N#endif  /* ifndef __STDDEF_H */
N#ifndef __NEW
N#define __NEW
N#define __ARMCLIB_VERSION 5050106
N
N#ifndef __EXCEPTION_INCLUDED
N#include <exception>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\exception" 1
N/*
N * C++ Library file exception
N * Copyright 2001 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision: 177844 $
N * Checkin $Date: 2012-11-21 11:51:12 +0000 (Wed, 21 Nov 2012) $
N * Revising $Author: pwright $
N */
N
N#ifndef __EXCEPTION_INCLUDED
N#define __EXCEPTION_INCLUDED
N#define __ARMCLIB_VERSION 5050106
N
N/* Edison Design Group, 1995-2005. */
N/*
Nexception -- Include file for exception handling (see 18.6)
N*/
N
Nnamespace std {
N
N/* This lets users disable the EDG supplied exception classes. */
N#ifndef __NO_EDG_EXCEPTION_CLASSES
N
N  class exception {
N  public:
N    exception() throw();
N    exception(const exception&) throw();
N    exception& operator=(const exception&) throw();
N    virtual ~exception() throw();
N    virtual const char* what() const throw();
N  };
N
N  class bad_exception : public exception {
N  public:
N    bad_exception() throw();
N    bad_exception(const bad_exception&) throw();
N    bad_exception& operator=(const bad_exception&) throw();
N    virtual ~bad_exception() throw();
N    virtual const char* what() const throw();
N  };
N
N#endif /* ifndef __NO_EDG_EXCEPTION_CLASSES */
N
N  typedef void (*terminate_handler)();
N  extern terminate_handler set_terminate(terminate_handler) throw();
N
N  typedef void (*unexpected_handler)();
N  extern unexpected_handler set_unexpected(unexpected_handler) throw();
N
N  void terminate();
N  void unexpected();
N
N  extern bool uncaught_exception() throw();
N
N}  /* namespace std */
N
N#ifdef __EDG_IMPLICIT_USING_STD
S/* Implicitly include a using directive for the STD namespace when this
S   preprocessing flag is TRUE. */
Susing namespace ::std;
N#endif /* ifdef __EDG_IMPLICIT_USING_STD */
N
N#endif /* __EXCEPTION_INCLUDED */
N
L 28 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\new" 2
N#endif /* __EXCEPTION_INCLUDED */
N
N#if defined(__EDG_RUNTIME_USES_NAMESPACES) || __clang__
X#if 1L || __clang__
Nnamespace std {
N#endif /* if defined(__EDG_RUNTIME_USES_NAMESPACES) || __clang__ */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef unsigned long size_t;   /* see <stddef.h> */
N#else
N  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N/* This lets users disable the EDG supplied exception classes. */
N#ifndef __NO_EDG_EXCEPTION_CLASSES
N
N  class bad_alloc : public exception {
N  public:
N    bad_alloc() throw();
N    bad_alloc(const bad_alloc&) throw();
N    bad_alloc& operator=(const bad_alloc&) throw();
N    virtual ~bad_alloc() throw();
N    virtual const char* what() const throw();
N  };
N
N  class bad_array_new_length : public bad_alloc {
N  public:
N    bad_array_new_length() throw();
N    virtual ~bad_array_new_length() throw();
N  };
N
N#endif /* ifndef __NO_EDG_EXCEPTION_CLASSES */
N
N  typedef void (*new_handler)();
N  new_handler set_new_handler(new_handler) throw();
N  struct nothrow_t { };
N  // Declaration of object nothrow to permit the use of the placement new
N  // syntax: new (nothrow) T;
N  extern const nothrow_t nothrow;
N
N#if defined(__EDG_RUNTIME_USES_NAMESPACES) || __clang__
X#if 1L || __clang__
N}  /* namespace std */
N#endif /* __EDG_RUNTIME_USES_NAMESPACES || __clang__ */
N
N#ifdef __EDG_IMPLICIT_USING_STD
S/* Implicitly include a using directive for the STD namespace when this
S   preprocessing flag is TRUE. */
Susing namespace ::std;
N#endif /* ifdef __EDG_IMPLICIT_USING_STD */
N
N/* Normal operator new. */
Nvoid *operator new(std::size_t) throw(std::bad_alloc);
N
N/* Normal operator delete. */
Nvoid operator delete(void*) throw ();
N
N/* Nothrow version of operator new. */
Nvoid *operator new(std::size_t, const std::nothrow_t&) throw();
N
N/* Nothrow version of operator delete. */
Nvoid operator delete(void*, const std::nothrow_t&) throw();
N
N/* Placement new. */
Ninline void *operator new(std::size_t, void* __ptr) throw() { return __ptr; }
N
N/* Placement delete. */
Ninline void operator delete(void*, void*) throw() { /* nothing */ }
N
N
N/* Array new. */
Nvoid *operator new[](std::size_t) throw(std::bad_alloc);
N
N/* Array delete. */
Nvoid operator delete[](void*) throw ();
N
N/* Placement array new. */
Ninline void *operator new[](std::size_t, void* __ptr) throw() { return __ptr; }
N
N/* Placement array delete. */
Ninline void operator delete[](void*, void*) throw() { /* nothing */ }
N
N/* Nothrow version of array new. */
Nvoid *operator new[](std::size_t,
N                     const std::nothrow_t&) throw();
N
N/* Nothrow version of array delete. */
Nvoid operator delete[](void*,
N                       const std::nothrow_t&) throw();
N
N#endif /*__NEW */
N/* End of new */
N
N#endif /*__NEW_STDH */
L 49 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\memory" 2
N#include <utility>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\utility" 1
N// -*- C++ -*-
N/***************************************************************************
N *
N * utility - Declarations for the Standard Library utility classes
N *
N ***************************************************************************
N *
N * Copyright (c) 1994
N * Hewlett-Packard Company
N *
N * Permission to use, copy, modify, distribute and sell this software
N * and its documentation for any purpose is hereby granted without fee,
N * provided that the above copyright notice appear in all copies and
N * that both that copyright notice and this permission notice appear
N * in supporting documentation.  Hewlett-Packard Company makes no
N * representations about the suitability of this software for any
N * purpose.  It is provided "as is" without express or implied warranty.
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_UTILITY_INCLUDED
N#define _RWSTD_UTILITY_INCLUDED
N
N#include <rw/_defs.h>
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N#ifndef _RWSTD_NO_NAMESPACE
N
N// rel_ops contents not available if namespaces are disabled
N// to avoid ambiguities with other overloaded operators
N
N_RWSTD_NAMESPACE_BEGIN (rel_ops)
Xnamespace rel_ops {
N
N
Ntemplate <class _TypeT>
Ninline bool operator!= (const _TypeT& __x, const _TypeT& __y)
N{
N    return !(__x == __y);
N}
N
Ntemplate <class _TypeT>
Ninline bool operator> (const _TypeT& __x, const _TypeT& __y)
N{
N    return __y < __x;
N}
N
Ntemplate <class _TypeT>
Ninline bool operator<= (const _TypeT& __x, const _TypeT& __y)
N{
N    return !(__y < __x);
N}
N
Ntemplate <class _TypeT>
Ninline bool operator>= (const _TypeT& __x, const _TypeT& __y)
N{
N    return !(__x < __y);
N}
N
N
N_RWSTD_NAMESPACE_END   // rel_ops
X}   
N
N
N#endif   // _RWSTD_NO_NAMESPACE
N
N
N// 20.2.2
Ntemplate <class _TypeT, class _TypeU>
Nstruct pair
N{
N    typedef _TypeT first_type;
N    typedef _TypeU second_type;
N
N    first_type  first;
N    second_type second;
N
N    pair (const first_type &__x, const second_type &__y)
N        : first (__x), second (__y) { }
N
N    pair ()
N#ifndef _RWSTD_NO_EMPTY_MEM_INITIALIZER
N        : first (/* lwg issue 265 */), second () { }
N#else
S        : first (first_type ()), second (second_type ()) { }
N#endif   // _RWSTD_NO_EMPTY_MEM_INITIALIZER
N
N    pair (const pair &__rhs): first (__rhs.first), second (__rhs.second) { }
N
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N
N    template <class _TypeX, class _TypeY>
N    pair (const pair <_TypeX, _TypeY> &__rhs) 
N        : first (__rhs.first), second (__rhs.second) { }
N
N#endif   // _RWSTD_NO_MEMBER_TEMPLATES
N
N};
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator== (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
N{ 
N    return __x.first == __y.first && __x.second == __y.second; 
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator!= (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
N{ 
N    return !(__x == __y);
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator< (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
N{ 
N    return    __x.first < __y.first
N           || (!(__y.first < __x.first) && __x.second < __y.second); 
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator> (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
N{ 
N    return __y < __x;
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator>= (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
N{ 
N    return !(__x < __y);
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator<= (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
N{ 
N    return !(__y < __x);
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline pair<_TypeT, _TypeU>
Nmake_pair (const _TypeT &__x, const _TypeU &__y)
N{
N    return pair<_TypeT, _TypeU>(__x, __y);
N}
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#endif   // _RWSTD_UTILITY_INCLUDED
N
L 50 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\memory" 2
N
N#include <rw/_iterbase.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_iterbase.h" 1
N/***************************************************************************
N *
N * _iterbase.h - Definitions of iterator primitives
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id: _iterbase.h 172106 2011-11-02 17:04:12Z statham $
N *
N ***************************************************************************
N *
N * Copyright (c) 1994
N * Hewlett-Packard Company
N *
N * Permission to use, copy, modify, distribute and sell this software
N * and its documentation for any purpose is hereby granted without fee,
N * provided that the above copyright notice appear in all copies and
N * that both that copyright notice and this permission notice appear
N * in supporting documentation.  Hewlett-Packard Company makes no
N * representations about the suitability of this software for any
N * purpose.  It is provided "as is" without express or implied warranty.
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_ITERBASE_H_INCLUDED
N#define _RWSTD_ITERBASE_H_INCLUDED
N
N#include <rw/_defs.h>
N#include _RWSTD_CSTDDEF
X#include <cstddef>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstddef" 1
N/*
N * C++ header for C header stddef.h
N * Copyright 1997 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision: 177844 $
N * Checkin $Date: 2012-11-21 11:51:12 +0000 (Wed, 21 Nov 2012) $
N * Revising $Author: pwright $
N */
N
N
N#ifndef __cstddef
N#define __cstddef
N#define __ARMCLIB_VERSION 5050106
N
N  #define __STDDEF_NO_EXPORTS 1
N  #include <stddef.h>
N  #undef __STDDEF_NO_EXPORTS
N
N  #undef __stddef_h  // later inclusion of stddef.h must do using std::*
N  #ifdef __EDG_IMPLICIT_USING_STD
S    /* Implicitly include a using directive for the STD namespace when this
S       preprocessing flag is TRUE. */
S       using namespace ::std;
N  #endif /* ifdef __EDG_IMPLICIT_USING_STD */
N  
N#endif /* __cstddef */
N
N
L 52 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_iterbase.h" 2
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N// 24.3.1 - Iterator traits
Ntemplate <class _Iterator>
Nstruct iterator_traits
N{
N    typedef _TYPENAME _Iterator::value_type        value_type;
X    typedef typename _Iterator::value_type        value_type;
N    typedef _TYPENAME _Iterator::difference_type   difference_type;
X    typedef typename _Iterator::difference_type   difference_type;
N    typedef _TYPENAME _Iterator::pointer           pointer;
X    typedef typename _Iterator::pointer           pointer;
N    typedef _TYPENAME _Iterator::reference         reference;
X    typedef typename _Iterator::reference         reference;
N    typedef _TYPENAME _Iterator::iterator_category iterator_category;
X    typedef typename _Iterator::iterator_category iterator_category;
N};
N
N
N// 24.3.3 - Standard iterator tags
Nstruct input_iterator_tag { };
Nstruct output_iterator_tag { };
Nstruct forward_iterator_tag : public input_iterator_tag { };
Nstruct bidirectional_iterator_tag : public forward_iterator_tag { };
Nstruct random_access_iterator_tag : public bidirectional_iterator_tag { };
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
Ntemplate <class _TypeT>
Nstruct iterator_traits<_TypeT*>
N{
N    typedef _TypeT                     value_type;
N    typedef ptrdiff_t                  difference_type;
N    typedef value_type*                pointer;
N    typedef value_type&                reference;
N    typedef random_access_iterator_tag iterator_category;
N};
N
N
Ntemplate <class _TypeT>
Nstruct iterator_traits<const _TypeT*>
N{
N    typedef _TypeT                     value_type;
N    typedef ptrdiff_t                  difference_type;
N    typedef const value_type*          pointer;
N    typedef const value_type&          reference;
N    typedef random_access_iterator_tag iterator_category;
N};
N
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N// 24.3.2 - Basic iterator
Ntemplate <class _Category, class _TypeT,  
N          class _Distance _RWSTD_SIMPLE_DEFAULT (ptrdiff_t), 
X          class _Distance = ptrdiff_t, 
N          class _Pointer _RWSTD_SIMPLE_DEFAULT (_TypeT*), 
X          class _Pointer = _TypeT*, 
N          class _Reference _RWSTD_SIMPLE_DEFAULT (_TypeT&)>
X          class _Reference = _TypeT& >
Nstruct iterator
N{
N    typedef _TypeT     value_type;
N    typedef _Distance  difference_type;
N    typedef _Pointer   pointer;
N    typedef _Reference reference;
N    typedef _Category  iterator_category;
N};
N
N
N// returns the category of an iterator
Ntemplate <class _TypeT>
Ninline random_access_iterator_tag __iterator_category (const _TypeT*)
N{
N    return random_access_iterator_tag ();
N}
N
N
Ntemplate <class _Category, class _TypeT, class _Distance, 
N          class _Pointer, class _Reference> 
Ninline _Category
N__iterator_category (const iterator<_Category, _TypeT,
N                                    _Distance, _Pointer, _Reference>&)
N{
N    typedef _TYPENAME iterator<_Category, _TypeT, _Distance, _TypeT*,
X    typedef typename iterator<_Category, _TypeT, _Distance, _TypeT*,
N                               _TypeT&>::iterator_category _IterCategory;
N
N    return _IterCategory ();
N}
N
N
Ntemplate <class _Tag>
Ninline bool __is_input_iterator (_Tag)
N{
N    return false;
N}
N
N
Ntemplate <class _Tag>
Ninline bool __is_bidirectional_iterator (_Tag)
N{
N    return false;
N}
N
N
Ntemplate <class _Tag>
Ninline bool __is_random_access_iterator (_Tag)
N{
N    return false;
N}
N
N
N_RWSTD_SPECIALIZED_FUNCTION 
Xtemplate< > 
Ninline bool __is_input_iterator (input_iterator_tag)
N{
N    return true;
N}
N
N
N_RWSTD_SPECIALIZED_FUNCTION 
Xtemplate< > 
Ninline bool __is_bidirectional_iterator (bidirectional_iterator_tag)
N{
N    return true;
N}
N
N
N_RWSTD_SPECIALIZED_FUNCTION 
Xtemplate< > 
Ninline bool __is_bidirectional_iterator (random_access_iterator_tag)
N{
N    return true;
N}
N
N
N_RWSTD_SPECIALIZED_FUNCTION 
Xtemplate< > 
Ninline bool __is_random_access_iterator (random_access_iterator_tag)
N{
N    return true;
N}
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
Ntemplate <class _Iterator>
Ninline _TYPENAME iterator_traits<_Iterator>::value_type*
Xinline typename iterator_traits<_Iterator>::value_type*
N__value_type (const _Iterator*)
N{ 
N    return 0;
N}
N
N#else   // if defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
S
Stemplate <class _Category, class _TypeT, class _Distance, 
S          class _Pointer, class _Reference>
Sinline _TypeT*
S__value_type (const iterator<_Category, _TypeT, _Distance,
S                             _Pointer, _Reference>*)
S{
S    return 0;
S}
S
Stemplate <class _TypeT>
Sinline _TypeT* __value_type (const _TypeT* const*)
S{
S    return 0;
S}
S
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
Ntemplate <class _Iterator>
Ninline _TYPENAME iterator_traits<_Iterator>::difference_type*
Xinline typename iterator_traits<_Iterator>::difference_type*
N__distance_type (_Iterator)
N{ 
N    return 0;
N}
N
N#else   // if defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
S
Stemplate <class _Category, class _TypeT, class _Distance, 
S          class _Pointer, class _Reference>
Sinline _Distance* 
S__distance_type (iterator<_Category, _TypeT, _Distance, _Pointer, _Reference>)
S{
S    return 0;
S}
S
Stemplate <class _TypeT>
Sinline ptrdiff_t* __distance_type (const _TypeT*)
S{ 
S    return 0;
S}
S
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N// 24.3.4 - Iterator operations
N
Ntemplate <class _InputIterator, class _Distance>
Ninline void __advance (_InputIterator &__it, _Distance __n, input_iterator_tag)
N{
N    _RWSTD_ASSERT (__n == 0 || __n > 0);
X    ((void)0);
N
N    while (__n > 0) {
N        --__n;
N        ++__it;
N    }
N}
N
N
Ntemplate <class _ForwardIterator, class _Distance>
Ninline void __advance (_ForwardIterator &__it, _Distance __n,
N                       forward_iterator_tag)
N{
N    __advance (__it, __n, input_iterator_tag ());
N}
N
N
Ntemplate <class _BidirectionalIterator, class _Distance>
Ninline void __advance (_BidirectionalIterator &__it, _Distance __n, 
N                       bidirectional_iterator_tag)
N{
N    if (__n > 0)
N        __advance (__it, __n, input_iterator_tag ());
N    else
N        while (__n) {
N            ++__n;
N            --__it;
N        }
N}
N
N
Ntemplate <class _RandomAccessIterator, class _Distance>
Ninline void __advance (_RandomAccessIterator& __it, _Distance __n, 
N                       random_access_iterator_tag)
N{
N    __it += __n;
N}
N
N
N// 24.3.4, p2
Ntemplate <class _InputIterator, class _Distance>
Ninline void advance (_InputIterator& __it, _Distance __n)
N{
N    __advance (__it, __n, _RWSTD_ITERATOR_CATEGORY (_InputIterator, __it));
X    __advance (__it, __n, typename std::iterator_traits< _InputIterator > ::iterator_category ());
N}
N
N
Ntemplate <class _InputIterator, class _Distance>
Ninline void __distance (const _InputIterator &__first,
N                        const _InputIterator &__last,
N                        _Distance            &__n,
N                        input_iterator_tag)
N{
N    for (_InputIterator __it = __first; __it != __last; ++__it)
N        ++__n;
N}
N
N
Ntemplate <class _ForwardIterator, class _Distance>
Ninline void __distance (const _ForwardIterator &__first,
N                        const _ForwardIterator &__last,
N                        _Distance              &__n,
N                        forward_iterator_tag)
N{
N    __distance (__first, __last, __n, input_iterator_tag ());
N}
N
Ntemplate <class _BidirectionalIterator, class _Distance>
Ninline void __distance (const _BidirectionalIterator &__first,
N                        const _BidirectionalIterator &__last, 
N                        _Distance                    &__n,
N                        bidirectional_iterator_tag)
N{
N    __distance (__first, __last, __n, input_iterator_tag ());
N}
N
N
Ntemplate <class _RandomAccessIterator, class _Distance>
Ninline void __distance (const _RandomAccessIterator &__first,
N                        const _RandomAccessIterator &__last, 
N                        _Distance                   &__n,
N                        random_access_iterator_tag)
N{
N    __n = __last - __first;
N}
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N// 24.3.4, p4
Ntemplate <class _ForwardIterator>
Ninline _TYPENAME iterator_traits<_ForwardIterator>::difference_type
Xinline typename iterator_traits<_ForwardIterator>::difference_type
Ndistance (const _ForwardIterator &__first, const _ForwardIterator &__last)
N{
N    _TYPENAME iterator_traits<_ForwardIterator>::difference_type __n = 0;
X    typename iterator_traits<_ForwardIterator>::difference_type __n = 0;
N
N    __distance (__first, __last, __n,
N                _RWSTD_ITERATOR_CATEGORY (_ForwardIterator, __first));
X                typename std::iterator_traits< _ForwardIterator > ::iterator_category ());
N
N    return __n;
N}
N
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N#ifndef _RWSTD_NO_EXT_VOID_DISTANCE
N
Ntemplate <class _ForwardIterator, class _Distance>
Ninline void distance (const _ForwardIterator &__first,
N                      const _ForwardIterator &__last,
N                      _Distance              &__n)
N{
N    __distance (__first, __last, __n,
N                _RWSTD_ITERATOR_CATEGORY (_ForwardIterator, __first));
X                typename std::iterator_traits< _ForwardIterator > ::iterator_category ());
N}
N
N#endif   // _RWSTD_NO_EXT_VOID_DISTANCE
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// __rw_distance: Same purpose as 3-parameter distance function, but
N// with return value.
N
Ntemplate <class _ForwardIterator, class _Distance>
Ninline _Distance
N__rw_distance (const _ForwardIterator &__first,
N               const _ForwardIterator &__last,
N               _Distance               __n)
N{
N    _STD::__distance (__first, __last, __n,
X    std::__distance (__first, __last, __n,
N                      _RWSTD_ITERATOR_CATEGORY (_ForwardIterator, __first));
X                      typename std::iterator_traits< _ForwardIterator > ::iterator_category ());
N    return __n;
N}
N
N
N_RWSTD_NAMESPACE_END // __rw
X} 
N
N
N#ifndef _RWSTD_NO_DEBUG_ITER
S
S_RWSTD_NAMESPACE_BEGIN (__rw)
S
S// __rw_debug_iter - iterator adapter with debugging support
S// _Iterator is either iterator or const_iterator; if the latter,
S// _MutableIterator should be iterator to allow for implicit
S// conversions from non-const (mutable) to const_iterator objects
S
S
Stemplate <class _Container, class _Iterator, class _MutableIterator>
Sclass __rw_debug_iter
S{
S    typedef _Container                                container_type;
S    typedef _Iterator                                 iterator_type;
S    typedef _STD::iterator_traits<iterator_type>      traits_type;
S
Spublic:
S
S    typedef _TYPENAME traits_type::value_type         value_type;
S    typedef _TYPENAME traits_type::difference_type    difference_type;
S    typedef _TYPENAME traits_type::reference          reference;
S    typedef _TYPENAME traits_type::pointer            pointer;
S    typedef _TYPENAME traits_type::iterator_category  iterator_category;
S
S    typedef __rw_debug_iter <container_type, _MutableIterator,
S                             _MutableIterator>        _C_mutable_iterator;
S
S    __rw_debug_iter (): _C_cont (0) { }
S
S    __rw_debug_iter (const container_type &__cont, const iterator_type &__it)
S        : _C_iter (__it), _C_cont (&__cont) { }
S
S    // no copy ctor other than the one below is defined
S    // will use a compiler generated one if _Iterator != _MutableIterator
S    __rw_debug_iter (const _C_mutable_iterator &__rhs)
S        : _C_iter (__rhs._C_iter), _C_cont (__rhs._C_cont) { }
S
S    __rw_debug_iter& operator= (const __rw_debug_iter &__rhs) {
S        if (this != &__rhs) {
S            _C_iter = __rhs._C_iter;
S            _C_cont = __rhs._C_cont;
S        }
S        return *this;
S    }
S
S    reference operator* () const {
S        _RWSTD_ASSERT (_C_is_dereferenceable ());
S        return *_C_iter;
S    }
S
S    reference operator[] (difference_type __n) const {
S        _RWSTD_ASSERT ((*this + __n)._C_is_dereferenceable ());
S        return _C_iter [__n];
S    }
S
S    _RWSTD_OPERATOR_ARROW (pointer operator-> () const);
S
S    __rw_debug_iter& operator++ () {
S        _RWSTD_ASSERT (!_C_is_end ());
S        return ++_C_iter, *this;
S    }
S
S    __rw_debug_iter& operator-- () {
S        _RWSTD_ASSERT (!_C_is_begin ());
S        return --_C_iter, *this;
S    }
S
S    __rw_debug_iter operator++ (int) {
S        __rw_debug_iter __tmp = *this;
S        return ++*this, __tmp;
S    }
S
S    __rw_debug_iter operator-- (int) {
S        __rw_debug_iter __tmp = *this;
S        return --*this, __tmp;
S    }
S
S    __rw_debug_iter& operator+= (difference_type __n) {
S        _C_iter += __n;
S        _RWSTD_ASSERT (   _C_iter >= _C_cont->begin ()._C_iter
S                       && _C_iter <= _C_cont->end ()._C_iter);
S        return *this;
S    }
S
S    __rw_debug_iter& operator-= (difference_type __n) {
S        _C_iter -= __n;
S        _RWSTD_ASSERT (   _C_iter >= _C_cont->begin ()._C_iter
S                       && _C_iter <= _C_cont->end ()._C_iter);
S        return *this;
S    }
S
S    __rw_debug_iter operator+ (difference_type __n) const {
S        return __rw_debug_iter (*this) += __n;
S    }
S
S    __rw_debug_iter operator- (difference_type __n) const {
S        return __rw_debug_iter (*this) -= __n;
S    }
S
S    bool _C_is_begin () const {
S        return _C_cont && _C_cont->begin () == *this;
S    }
S
S    bool _C_is_end () const {
S        return _C_cont && _C_cont->end () == *this;
S    }
S
S    bool _C_is_dereferenceable () const {
S        return !_C_is_end ();
S    }
S
S    bool _C_valid_range (const __rw_debug_iter &__it) const {
S        return _C_cont && _C_cont == __it._C_cont;
S    }
S
S    const iterator_type& base () const {
S        return _C_iter;
S    }
S
S    iterator_type& base () {
S        return _C_iter;
S    }
S
S#ifndef _RWSTD_NO_MEMBER_TEMPLATES
S
S    // operators are templatized to assure const/non-const symmetry
S
S    template <class _Iter>
S    difference_type
S    operator- (const __rw_debug_iter<container_type, _Iter,
S                                     _MutableIterator> &__rhs) const {
S        _RWSTD_ASSERT (_C_cont && _C_cont == __rhs._C_cont);
S        return _C_iter - __rhs._C_iter;
S    }
S
S    template <class _Iter>
S    bool
S    operator== (const __rw_debug_iter<container_type, _Iter,
S                                      _MutableIterator> &__rhs) const {
S        return _C_iter == __rhs._C_iter;
S    }
S    
S    template <class _Iter>
S    bool
S    operator< (const __rw_debug_iter<container_type, _Iter,
S                                     _MutableIterator> &__rhs) const {
S        return _C_iter < __rhs._C_iter;
S    }
S
S    template <class _Iter>
S    bool
S    operator!= (const __rw_debug_iter<container_type, _Iter,
S                                      _MutableIterator> &__rhs) const {
S        return _C_iter != __rhs._C_iter;
S    }
S
S    template <class _Iter>
S    bool
S    operator<= (const __rw_debug_iter<container_type, _Iter,
S                                      _MutableIterator> &__rhs) const {
S        return _C_iter <= __rhs._C_iter;
S    }
S
S    template <class _Iter>
S    bool
S    operator> (const __rw_debug_iter<container_type, _Iter,
S                                     _MutableIterator> &__rhs) const {
S        return _C_iter > __rhs._C_iter;
S    }
S
S    template <class _Iter>
S    bool
S    operator>= (const __rw_debug_iter<container_type, _Iter,
S                                      _MutableIterator> &__rhs) const {
S        return _C_iter >= __rhs._C_iter;
S    }
S
S#endif   // _RWSTD_NO_MEMBER_TEMPLATES
S
S    iterator_type         _C_iter;   // wrapped iterator
S    const container_type *_C_cont;   // associated container
S};
S
S
S_RWSTD_NAMESPACE_END   // __rw
S
S
S_RWSTD_NAMESPACE_BEGIN (std)
S
S
S#ifndef _RWSTD_NO_NONDEDUCED_CONTEXT
S# define _RWSTD_CONT_DIFF_TYPE _TYPENAME _Cont::difference_type 
S#else
S# define _RWSTD_CONT_DIFF_TYPE ptrdiff_t 
S#endif
S
Stemplate <class _Cont, class _Iter, class _MutIter>
Sinline _RW::__rw_debug_iter<_Cont, _Iter, _MutIter> 
Soperator+ (_RWSTD_CONT_DIFF_TYPE                               __n,
S           const _RW::__rw_debug_iter<_Cont, _Iter, _MutIter> &__x)
S{
S    return __x + __n;
S}
S
S#undef _RWSTD_CONT_DIFF_TYPE 
S
S
S#ifdef _RWSTD_NO_MEMBER_TEMPLATES
S
S// with no support for member templates namespace-scope (non-member)
S// operators must be used - these will cause ambiguities with those
S// in std::rel_ops if the latter are found during lookup
S
S
S
S// _Iter1 may differ from _Iter2 if the function operands are const
S// and non-const iterators, respectively (allows symmetry)
S
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline _TYPENAME _Cont::difference_type
Soperator- (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S           const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    _RWSTD_ASSERT (__x._C_cont && __x._C_cont == __y._C_cont);
S    return __x._C_iter - __y._C_iter;
S}
S    
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline bool
Soperator== (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S            const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    return __x._C_iter == __y._C_iter;
S}
S
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline bool
Soperator< (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S           const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    _RWSTD_ASSERT (__x._C_cont && __x._C_cont == __y._C_cont);
S    return __x._C_iter < __y._C_iter;
S}
S
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline bool
Soperator!= (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S            const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    return !(__x == __y);
S}
S
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline bool
Soperator<= (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S            const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    return !(__y < __x);
S}
S
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline bool
Soperator>= (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S            const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    return !(__x < __y);
S}
S
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline bool
Soperator> (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S           const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    return __y < __x;
S}
S
S#endif   // _RWSTD_NO_MEMBER_TEMPLATES
S
S_RWSTD_NAMESPACE_END   // std
S
S
S_RWSTD_NAMESPACE_BEGIN (__rw)
S
S
S#define _RWSTD_DEBUG_ITER(cont, it, mutit) __rw_debug_iter< cont, it, mutit >
S
S
Stemplate <class _Cont, class _Iter, class _MutIter>
Sinline bool
S__rw_valid_range (const _RWSTD_DEBUG_ITER(_Cont, _Iter, _MutIter) &__first,
S                  const _RWSTD_DEBUG_ITER(_Cont, _Iter, _MutIter) &__last)
S{
S    return __first._C_cont && __first._C_cont == __last._C_cont;
S}
S
S
Stemplate <class _Iterator>
Sinline bool
S__rw_valid_range (const _Iterator &, const _Iterator &)
S{
S    return true;
S}
S
S
Stemplate <class _Cont, class _Iter, class _MutIter>
Sinline bool
S__rw_in_range (const _RWSTD_DEBUG_ITER(_Cont, _Iter, _MutIter) &__it,
S               const _RWSTD_DEBUG_ITER(_Cont, _Iter, _MutIter) &__first,
S               const _RWSTD_DEBUG_ITER(_Cont, _Iter, _MutIter) &__last)
S{
S    return    __rw_valid_range (__first, __it)
S           && __rw_valid_range (__it, __last);
S}
S
S
Stemplate <class _Iterator>
Sinline bool
S__rw_in_range (const _Iterator&, const _Iterator&, const _Iterator&)
S{
S    return true;
S}
S
S
Stemplate <class _Cont, class _Iter, class _MutIter>
Sinline bool
S__rw_dereferenceable (const _RWSTD_DEBUG_ITER(_Cont, _Iter, _MutIter) &__it)
S{
S    return __it._C_is_dereferenceable ();
S}
S
S
Stemplate <class _Iterator>
Sinline bool
S__rw_dereferenceable (const _Iterator&)
S{
S    return true;
S}
S
S
Stemplate <class _TypeT>
Sinline bool
S__rw_dereferenceable (const _TypeT *__ptr)
S{
S    return 0 != __ptr;
S}
S
S_RWSTD_NAMESPACE_END   // __rw
S
S#undef _RWSTD_DEBUG_ITER
S
N#endif   // _RWSTD_NO_DEBUG_ITER
N
N
N#endif   // _RWSTD_ITERBASE_H_INCLUDED
N
L 52 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\memory" 2
N#include <rw/_mutex.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_mutex.h" 1
N/***************************************************************************
N *
N * _mutex.h - Definitions of classes and inline functions providing MT safety
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id: _mutex.h 172106 2011-11-02 17:04:12Z statham $
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N ***************************************************************************
N *
N * There are two mutex classes:
N *
N * __rw::__rw_mutex_base - a POD-type class with no ctor or dtor (POSIX
N * and Solaris threads only) suitable for mutex objects with static storage
N * duration. On POSIX threads, these objects are fully constructed at static
N * initialization time and initialized via assignment by 
N * PTHREAD_MUTEX_INITIALIZER, while on Solaris threads they do not need to be
N * initialized at all. On platforms such as Win32/64 that do not support static
N * initialization this class does define a ctor that initializes the object
N * by the appropriate thread library call.
N *
N * __rw::__rw_mutex - a non-POD-type class derived from __rw::__rw_mutex_base
N * with explicitly defined ctor and dtor suitable for mutex member variables.
N * On platforms such as Win32/64 that do not support static initialization this
N * class does not define its own ctor and dtor and simply defers the
N * initialization and destruction to its base.
N *
N * __rw::__rw_static_mutex<> - a POD-type class template, defined on
N * platforms such as POSIX or Solaris threads that support static
N * initialization of mutexes, containing a single public static data member
N * of the __rw::__rw_mutex_base class. The static member object is returned
N * from the factory function template __rw::__rw_get_static_mutex<>().
N *
N * On platforms such as Win32/64 that do not support static initialization
N * of mutex objects the factory template function
N * __rw::__rw_get_static_mutex<>() defines and dynamically initializes
N * a static local reference to an object of the __rw::__rw_mutex_base class.
N * The dynamic initialization is done in an MT-safe way (i.e., such that
N * exactly one initialization of the mutex object is guaranteed). On Win32/64
N * this is accomplished by making use of the InterlockedIncrement() API call,
N * everywhere else there exists a small potential for a race condition and
N * the risk of the object being initialized multiple times. The reference is
N * initialized to refer to a properly aligned static data buffer to prevent
N * the destruction of the actual object at program termination, and the object
N * itself is constructed in this buffer space via a call to placement new.
N *
N ***************************************************************************/
N
N#ifndef _RWSTD_MUTEX_H_INCLUDED
N#define _RWSTD_MUTEX_H_INCLUDED
N
N#include <rw/_defs.h>
N
N#include _RWSTD_CSTRING
X#include <cstring>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstring" 1
N/*
N * C++ header for C header string.h
N * Copyright 1997 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision: 177844 $
N * Checkin $Date: 2012-11-21 11:51:12 +0000 (Wed, 21 Nov 2012) $
N * Revising $Author: pwright $
N */
N
N#ifndef __cstring
N#define __cstring
N#define __ARMCLIB_VERSION 5050106
N
N  #define __STRING_NO_EXPORTS 1
N  #include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5050106
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
N        namespace std {
N        #define __CLIBNS std::
N        extern "C" {
N    #else
S      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 1L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Nextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) const void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
Nextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Nextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
N    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Sextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Nextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) const char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
Nextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Nextern "C++" inline char *strchr(char * __s, int __c)
N    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Sextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Nextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) const char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
Nextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Nextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
N    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Sextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Nextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) const char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
Nextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Nextern "C++" inline char *strrchr(char * __s, int __c)
N    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Sextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Nextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) const char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
Nextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Nextern "C++" inline char *strstr(char * __s1, const char * __s2)
N    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Sextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
N         }  /* extern "C" */
N      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
N    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
N    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 18 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstring" 2
N  #undef __STRING_NO_EXPORTS
N
N  #undef __string_h  // later inclusion of string.h must do using std::*
N  #ifdef __EDG_IMPLICIT_USING_STD
S    /* Implicitly include a using directive for the STD namespace when this
S       preprocessing flag is TRUE. */
S       using namespace ::std;
N  #endif /* ifdef __EDG_IMPLICIT_USING_STD */
N  
N#endif /* __cstring */
N
L 78 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_mutex.h" 2
N
N#ifdef _RWSTD_MULTI_THREAD
S
S
S#include <rw/_exception.h>
S
S
S#if defined (_RWSTD_SOLARIS_THREADS)  // assuming Solaris 2.1 or greater
S
S// SunOS 5.7 Threads Library:
S//   "A statically  allocated  mutex does  not  need to be explicitly
S//   initialized; by default, a statically allocated mutex is initialized
S//   with  all  zeros and its scope is set to be within the calling
S//   process."
S
S#  include <synch.h>
S#  include <thread.h>
S
S#  define _RWSTD_MUTEX_INIT(mutex)      mutex_init (&mutex, USYNC_THREAD, 0)
S#  define _RWSTD_MUTEX_DESTROY(mutex)   mutex_destroy (&mutex)
S#  define _RWSTD_MUTEX_LOCK(mutex)      mutex_lock (&mutex)
S#  define _RWSTD_MUTEX_UNLOCK(mutex)    mutex_unlock (&mutex)
S#  define _RWSTD_MUTEX_T                mutex_t
S
S#elif defined (_RWSTD_POSIX_D10_THREADS)
S
S// LinuxThreads man page:
S//   "Variables of type pthread_mutex_t can also be initialized
S//    statically, using the constants  PTHREAD_MUTEX_INITIALIZER
S//    (for fast mutexes), PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
S//    (for recursive mutexes), and PTHREAD_ERRORCHECK_MUTEX_INI-
S//    TIALIZER_NP (for error checking mutexes)."
S//    ...
S//    "Attempting to initialize an already initialized mutex results
S//    in undefined behavior."
S
S#  include <pthread.h>
S
S#  define _RWSTD_MUTEX_INIT(mutex)      pthread_mutex_init (&mutex, 0)
S#  define _RWSTD_MUTEX_DESTROY(mutex)   pthread_mutex_destroy (&mutex)
S#  define _RWSTD_MUTEX_LOCK(mutex)      pthread_mutex_lock (&mutex)
S#  define _RWSTD_MUTEX_UNLOCK(mutex)    pthread_mutex_unlock (&mutex)
S#  define _RWSTD_MUTEX_T                pthread_mutex_t
S
S#elif defined (_RWSTD_DCE_THREADS)
S
S#  if defined (_RWSTD_NO_DCE_PTHREAD_H)
S#    include <pthread.h>
S#  else
S#    include <dce/pthread.h>
S#  endif
S
S#  define _RWSTD_MUTEX_INIT(mutex) \
S          pthread_mutex_init (&mutex, pthread_mutexattr_default)
X#  define _RWSTD_MUTEX_INIT(mutex)           pthread_mutex_init (&mutex, pthread_mutexattr_default)
S#  define _RWSTD_MUTEX_DESTROY(mutex)   pthread_mutex_destroy (&mutex)
S#  define _RWSTD_MUTEX_LOCK(mutex)      pthread_mutex_lock (&mutex)
S#  define _RWSTD_MUTEX_UNLOCK(mutex)    pthread_mutex_unlock (&mutex)
S#  define _RWSTD_MUTEX_T                pthread_mutex_t
S
S// DCE doesn't seem to support static mutex initialization
S#  include <new>
S
S#elif defined (_WIN32) || defined (_WIN64)
S
S#  ifdef _RWSTD_NO_FWD_DECLARATIONS
S
S#    include <windows.h>
S#    define _RWSTD_MUTEX_T _RTL_CRITICAL_SECTION
S
S#  else   // if defined (_RWSTD_NO_FWD_DECLARATIONS)
S
S   // avoid #including this header...
S   // #  include <windows.h>
S
Sextern "C" {
S
S// but rather declare these globals here
Sstruct _RTL_CRITICAL_SECTION;
S
S__declspec (dllimport) void __stdcall
SInitializeCriticalSection (_RTL_CRITICAL_SECTION*);
S
S__declspec (dllimport) void __stdcall
SEnterCriticalSection (_RTL_CRITICAL_SECTION*);
S
S__declspec (dllimport) void __stdcall
SLeaveCriticalSection (_RTL_CRITICAL_SECTION*);
S
S__declspec (dllimport) void __stdcall
SDeleteCriticalSection (_RTL_CRITICAL_SECTION*);
S
S__declspec (dllimport) long __stdcall
SInterlockedIncrement (long*);
S
S__declspec (dllimport) long __stdcall
SInterlockedDecrement (long*);
S
S__declspec (dllimport) long __stdcall
SInterlockedExchange (long*, long);
S
S}   // extern "C"
S
S_RWSTD_NAMESPACE_BEGIN (__rw)
S
S// fake critical section type
Sunion __rw_critical_section {
S    long _C_pad;   // force alignment
S    char _C_buf [24 /* == sizeof (_RTL_CRITICAL_SECTION) */];
S};
S
S#    define _RWSTD_MUTEX_T _RW::__rw_critical_section
S
S_RWSTD_NAMESPACE_END   // __rw
S
S
S#  endif   // _RWSTD_NO_FWD_DECLARATIONS
S
S
S_RWSTD_NAMESPACE_BEGIN (__rw)
S
S// Win32/64 throws non-C++ exceptions rather than returning error status
S// from some system calls like most other operating systems do
S
Sinline int __rw_mutex_init (_RTL_CRITICAL_SECTION *__mutex)
S{
S    __try {
S        InitializeCriticalSection (__mutex);
S    }
S    __except (1) {
S        return -1;
S    }
S    return 0;
S}
S
Sinline int __rw_mutex_destroy (_RTL_CRITICAL_SECTION *__mutex)
S{
S    __try {
S        DeleteCriticalSection (__mutex);
S    }
S    __except (1) {
S        return -1;
S    }
S    return 0;
S}
S
Sinline int __rw_mutex_lock (_RTL_CRITICAL_SECTION *__mutex)
S{
S    __try {
S        EnterCriticalSection (__mutex);
S    }
S    __except (1) {
S        return -1;
S    }
S    return 0;
S}
S
Sinline int __rw_mutex_unlock (_RTL_CRITICAL_SECTION *__mutex)
S{
S    __try {
S        LeaveCriticalSection (__mutex);
S    }
S    __except (1) {
S        return -1;
S    }
S    return 0;
S}
S
S#  define _RWSTD_MUTEX_INIT(mutex)      \
S   __rw_mutex_init (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
X#  define _RWSTD_MUTEX_INIT(mutex)         __rw_mutex_init (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
S#  define _RWSTD_MUTEX_DESTROY(mutex)   \
S   __rw_mutex_destroy (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
X#  define _RWSTD_MUTEX_DESTROY(mutex)      __rw_mutex_destroy (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
S#  define _RWSTD_MUTEX_LOCK(mutex)      \
S   __rw_mutex_lock (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
X#  define _RWSTD_MUTEX_LOCK(mutex)         __rw_mutex_lock (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
S#  define _RWSTD_MUTEX_UNLOCK(mutex)    \
S   __rw_mutex_unlock (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
X#  define _RWSTD_MUTEX_UNLOCK(mutex)       __rw_mutex_unlock (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
S
S_RWSTD_NAMESPACE_END   // __rw
S
S#elif defined (__OS2__)
S
S#  define INCL_DOSSEMAPHORES
S
S#  include <os2.h>
S
S#  define _RWSTD_MUTEX_INIT(mutex) \
S          DosCreateMutexSem (0, &mutex, DC_SEM_SHARED,FALSE)
X#  define _RWSTD_MUTEX_INIT(mutex)           DosCreateMutexSem (0, &mutex, DC_SEM_SHARED,FALSE)
S#  define _RWSTD_MUTEX_DESTROY(mutex)   DosCloseMutexSem (mutex)
S#  define _RWSTD_MUTEX_LOCK(mutex) \
S          DosRequestMutexSem (mutex, SEM_INDEFINITE_WAIT)
X#  define _RWSTD_MUTEX_LOCK(mutex)           DosRequestMutexSem (mutex, SEM_INDEFINITE_WAIT)
S#  define _RWSTD_MUTEX_UNLOCK(mutex)    DosReleaseMutexSem (mutex)
S#  define _RWSTD_MUTEX_T                HMTX
S
S#else
S#  error unknown thread environment
S#endif
S
S
S#if defined (__DECCXX)
S   // get declarations of __ATOMIC_XXX intrinsics
S
S#  include <machine/builtins.h>
S
S#endif   // __DECXX
S
S
S#if defined (__GNUG__) && defined (__osf__)
S   // prevent g++ warnings about missing initializers
S   // see <pthread.h> for explanation of _PTHREAD_NOMETER_STATIC
S#  ifndef _PTHREAD_NOMETER_STATIC
S#    define _RWSTD_PTHREAD_MUTEX_INITIALIZER \
S            { _PTHREAD_MSTATE_SLOW, _PTHREAD_MVALID | _PTHREAD_MVF_STA, \
S              0, 0, 0, 0, 0, 0 }
X#    define _RWSTD_PTHREAD_MUTEX_INITIALIZER             { _PTHREAD_MSTATE_SLOW, _PTHREAD_MVALID | _PTHREAD_MVF_STA,               0, 0, 0, 0, 0, 0 }
S#  else   // if defined (_PTHREAD_NOMETER_STATIC)
S#    define _RWSTD_PTHREAD_MUTEX_INITIALIZER
S            { 0, _PTHREAD_MVALID | _PTHREAD_MVF_STA, 0, 0, 0, 0, 0, 0 }
S#  endif   // _PTHREAD_NOMETER_STATIC
S#elif defined (__GNUG__) && defined (__sgi__)
S   // prevent g++ warnings about a partly bracketed initializer
S#  define _RWSTD_PTHREAD_MUTEX_INITIALIZER { PTHREAD_MUTEX_INITIALIZER }
S#else
S#  define _RWSTD_PTHREAD_MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER
S#endif
S
S
S_RWSTD_NAMESPACE_BEGIN (__rw)
S
S// a using declaration (rather than a directive)
S// used to work around yet another MSVC 6.0 bug
S_USING (std::exception);
S
Sclass __rw_thread_error : public exception
S{
Spublic:
S    __rw_thread_error () _THROWS (())
S    : exception () { }
S
S    virtual const char* what () const _THROWS (()) {
S        return "thread synchronization error";
S    }
S};                            
S
S
S// POD type with no user-defined ctor or dtor facilitates static
S// initialization of mutex objects with static storage duration
S// (important during library initialziation time)
Sclass _RWSTD_EXPORT __rw_mutex_base
S{
Spublic:
S
S    void _C_acquire () {
S#if !defined (__HP_aCC) || __HP_aCC > 32700
S        if (0 != _RWSTD_MUTEX_LOCK (_C_mutex))
S            _RW::__rw_throw (_RWSTD_ERROR_RUNTIME_ERROR,
S                             "synchronization error");
S#else
S        // working around an HP aCC 3.27 bug JAGac88738
S        _RWSTD_MUTEX_LOCK (_C_mutex);
S#endif   // !defined (__HP_aCC) || __HP_aCC > 32700
S    }
S
S    void _C_release ();
S
S#ifdef _RWSTD_NO_STATIC_MUTEX_INIT
S
S    // static initialization not an option, define ctor and dtor
S    // and make member mutex private
S
S    __rw_mutex_base ();
S
S    ~__rw_mutex_base ();
S
Sprivate:
S
S    // not defined
S    __rw_mutex_base (const __rw_mutex_base&);
S    __rw_mutex_base& operator= (const __rw_mutex_base&);
S
S#endif   // _RWSTD_NO_STATIC_MUTEX_INIT
S
S    _RWSTD_MUTEX_T _C_mutex;   // the real thing
S};
S
S
Sinline void __rw_mutex_base::_C_release ()
S{
S    // we should NOT throw from here as _C_release will typically be called
S    // during the destruction of local objects such as __rw_guard (perhaps
S    // due to another exception)
S    _RWSTD_MUTEX_UNLOCK (_C_mutex);
S}
S
S
S// non-POD type, always initializes mutex data member via a function call
Sclass  _RWSTD_EXPORT __rw_mutex: public __rw_mutex_base
S{
Spublic:
S
S#ifndef _RWSTD_NO_STATIC_MUTEX_INIT
S
S    __rw_mutex ();
S
S    ~__rw_mutex ();
S
Sprivate:
S
S    // not defined
S    __rw_mutex (const __rw_mutex&);
S    __rw_mutex& operator= (const __rw_mutex&);
S
S#endif   // _RWSTD_NO_STATIC_MUTEX_INIT
S
S};
S
S
S#ifndef _RWSTD_NO_STATIC_MUTEX_INIT
S
S// helper factory class - static member is guranteed to be constructed
S// during static initialization; objects of this POD class are not
S// destroyed during program termination (important to allow them
S// to be used in dtors of other objects with static storage duration)
Stemplate <class _TypeT>
Sstruct __rw_static_mutex
S{
S    static __rw_mutex_base _C_mutex;
S};
S
S
Stemplate <class _TypeT>
S__rw_mutex_base __rw_static_mutex<_TypeT>::_C_mutex
S
S#ifdef _RWSTD_POSIX_D10_THREADS
S
S    = { _RWSTD_PTHREAD_MUTEX_INITIALIZER }
S
S#endif   // _RWSTD_POSIX_D10_THREADS
S        ;
S
S// explicitly instantiated to work around a g++ 2.95.2 bug on COFF systems
S// (such as IBM AIX or DEC OSF1) where it "forgets" to do so implicitly for
S// explicitly initialized static data members
S_RWSTD_INSTANTIATE_1 (class _RWSTD_EXPORT __rw_static_mutex<int>);
S_RWSTD_INSTANTIATE_1 (class _RWSTD_EXPORT __rw_static_mutex<size_t>);
S
S
Sinline __rw_mutex::__rw_mutex ()
S
S#else   // if defined (_RWSTD_NO_STATIC_MUTEX_INIT)
S
Sinline __rw_mutex_base::__rw_mutex_base ()
S
S#endif   // _RWSTD_NO_STATIC_MUTEX_INIT
S{ 
S    if (0 != _RWSTD_MUTEX_INIT (_C_mutex))
S        _RW::__rw_throw (_RWSTD_ERROR_RUNTIME_ERROR, "synchronization error");
S}
S
S#ifndef _RWSTD_NO_STATIC_MUTEX_INIT
S
Sinline __rw_mutex::~__rw_mutex () 
S
S#else   // if defined (_RWSTD_NO_STATIC_MUTEX_INIT)
S
Sinline __rw_mutex_base::~__rw_mutex_base () 
S
S#endif   // _RWSTD_NO_STATIC_MUTEX_INIT
S{
S    _RWSTD_MUTEX_DESTROY (_C_mutex);
S}
S
S
S// mutex factory function avoids problematic initialization dependencies
S// introduced by definitions of mutexes with static storage duration
S// instead of defining a static mutex member that may not be initialized
S// before first use, a non-local class may either declare a unique type
S// (enum or class) or use itself as this type, and call this template
S// function with a ptr to that type to obtain an initialized mutex object
S// that is the same for each unique type passed to the function
S
S#ifndef _RWSTD_NO_STATIC_MUTEX_INIT
S
Stemplate <class _TypeT>
Sinline
S__rw_mutex_base& __rw_get_static_mutex (_TypeT*)
S{
S    // POD mutex already initialized during static initialization
S    return __rw_static_mutex<_TypeT>::_C_mutex;
S}
S
S#else   // if defined (_RWSTD_NO_STATIC_MUTEX_INIT)
S
S#ifdef _INLINE_WITH_STATICS
S
Stemplate <class _TypeT>
S_INLINE_WITH_STATICS
S__rw_mutex_base& __rw_get_static_mutex (_TypeT*)
S
S#else    // if !defined (_INLINE_WITH_STATICS)
S
Stemplate <class _TypeT>
S__rw_mutex_base& __rw_get_static_mutex (_TypeT*)
S
S#endif   // _INLINE_WITH_STATICS
S
S{
S    // allocate properly aligned memory for static mutex (necessary
S    // to prevent static local mutex from being destroyed during
S    // program termination)
S    union __mutex_buf_t {
S        long double __pad;   // force alignment (must be first)
S        char        __buf [sizeof (__rw_mutex_base)];
S    };
S
S    // using a named union to work around a bug in HP aCC 3.14.10 (JAGad03246)
S    static __mutex_buf_t __mutex_buf;
S
S    // initialize mutex reference to refer to the static buffer space
S    __rw_mutex_base &__mutex =
S        _RWSTD_REINTERPRET_CAST (__rw_mutex_base&, __mutex_buf);
S
S    // keep track of number of mutex initialization attempts
S    // although `init' may reach a value greater than 1, `mutex'
S    // will (should) never be multiply initialized
S
S    // implicit initialization used to prevent a g++ 2.95.2 warning on Tru64
S    // sorry: semantics of inline function static data are wrong (you'll wind
S    // up with multiple copies)
S    static volatile long __cntr /* = 0 */;   // initialization counter
S
S#if defined (_WIN32) || defined (_WIN64)
S    // MT safe
S    if (0 == __cntr && 1 == InterlockedIncrement ((long*)&__cntr))
S#else
S    // not so safe (volatile should help)
S    if (0 == __cntr && 1 == ++__cntr)
S#endif   // _WIN32
S
S    {
S        // manually initialize `mutex' via a call to placement new
S        new (&__mutex) __rw_mutex_base ();
S
S        // indicate that `mutex' has been fully initialized
S        // (unlikely that we'll have more than 1000 threads)
S        __cntr += 1000;
S    }
S    else
S        // busywait until `mutex' has been completely initialized
S        while (__cntr < 1000);
S
S    return __mutex;
S}
S
S#endif   //_RWSTD_NO_STATIC_MUTEX_INIT
S
S
S// clean up
S#undef _RWSTD_MUTEX_LOCK
S#undef _RWSTD_MUTEX_UNLOCK
S#undef _RWSTD_MUTEX_T
S
S
S// allows safe use of a mutex in the presence of exceptions
Sclass __rw_guard
S{
S    __rw_mutex_base *_C_mutex;
S
S    // undefined
S    __rw_guard& operator= (const __rw_guard&);
S    
Spublic:
S
S    __rw_guard (__rw_guard &__rhs)
S        : _C_mutex (__rhs._C_mutex) {
S        __rhs._C_mutex = 0;
S    }
S
S    __rw_guard (__rw_mutex_base &__mutex): _C_mutex (&__mutex) {
S        _C_mutex->_C_acquire ();
S    }
S
S    __rw_guard (__rw_mutex_base *__mutex): _C_mutex (__mutex) {
S        if (_C_mutex)
S            _C_mutex->_C_acquire ();
S    }
S
S    ~__rw_guard () {
S        if (_C_mutex)
S            _C_mutex->_C_release ();
S    }
S
S    __rw_mutex_base* _C_set (__rw_mutex_base *__mutex) {
S        __rw_mutex_base *__tmp = _C_mutex;
S        return _C_mutex = __mutex, __tmp;
S    }
S};
S
S
S// base class for obects required to guarantee some degree of MT safety
Sstruct _RWSTD_EXPORT __rw_synchronized
S{
S    __rw_mutex _C_mutex;
S
S    void _C_lock () {
S        _C_mutex._C_acquire ();
S    }
S
S    void _C_unlock () {
S        _C_mutex._C_release ();
S    }
S
S    __rw_guard _C_guard () {
S        __rw_guard __guard (_C_mutex);
S        return __guard;
S    }
S};
S
S
S// helper functions for atomic value [in|de]crement and exchange
S// the functions are atomic with respect to each other as long as
S// they are passed the same mutex by the callers
Stemplate <class _TypeT>
Sinline
S_TypeT __rw_atomic_preincrement (_TypeT &__t, __rw_mutex_base &__mutex)
S{
S    _RWSTD_MT_GUARD (__mutex);
S
S    return ++__t;
S}
S
S
Stemplate <class _TypeT>
Sinline
S_TypeT __rw_atomic_predecrement (_TypeT &__t, __rw_mutex_base &__mutex)
S{
S    _RWSTD_MT_GUARD (__mutex);
S
S    return --__t;
S}
S
S
Stemplate <class _TypeT, class _TypeU>
Sinline
S_TypeT __rw_atomic_exchange (_TypeT &__t, const _TypeU &__u,
S                             __rw_mutex_base &__mutex)
S{
S    _RWSTD_MT_GUARD (__mutex);
S
S    _TypeT __tmp = __t;
S    __t = __u;
S    return __tmp;
S}
S
S
S// for use on class statics or on namespace-scope variables
S// the unused argument is only here so that all functions can be
S// called from the same set of macros
S
Stemplate <class _TypeT>
Sinline
S_TypeT __rw_atomic_preincrement (_TypeT &__t, bool)
S{
S    return __rw_atomic_preincrement (__t,
S                                     __rw_get_static_mutex ((_TypeT*)0));
S}
S
S
Stemplate <class _TypeT>
Sinline
S_TypeT __rw_atomic_predecrement (_TypeT &__t, bool)
S{
S    return __rw_atomic_predecrement (__t,
S                                     __rw_get_static_mutex ((_TypeT*)0));
S}
S
S
Stemplate <class _TypeT, class _TypeU>
Sinline
S_TypeT __rw_atomic_exchange (_TypeT &__t, const _TypeU &__u, bool)
S{
S    return __rw_atomic_exchange (__t, __u,
S                                 __rw_get_static_mutex ((_TypeT*)0));
S}
S
S/********************** DEC CXX **************************************/
S
S#if defined (__DECCXX) && !defined (_RWSTD_NO_ATOMIC_OPERATIONS)
S
S// __ATOMIC_[DE|IN]CREMENT_[LONG|QUAD] and __ATOMIC_EXCH_[LONG|QUAD] are
S// intrinsic functions declared in <machine/builtins.h> that atomically
S// modify their argument and return its original value (__ATOMIC_XXX_LONG
S// is misnamed -- it actually operates on an int, not a long)
S
Sinline
Sint __rw_atomic_preincrement (int &__x, bool)
S{
S    return 1 + __ATOMIC_INCREMENT_LONG (&__x);
S}
S
S
Sinline
Sunsigned __rw_atomic_preincrement (unsigned &__x, bool)
S{
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Sinline
Slong __rw_atomic_preincrement (long &__x, bool)
S{
S    return 1 + __ATOMIC_INCREMENT_QUAD (&__x);
S}
S
S
Sinline
Sunsigned long __rw_atomic_preincrement (unsigned long &__x, bool)
S{
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_preincrement (_TypeT* &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       false));
S}
S
S
Sinline
Sint __rw_atomic_predecrement (int &__x, bool)
S{
S    return __ATOMIC_DECREMENT_LONG (&__x) - 1;
S}
S
Sinline
Sunsigned __rw_atomic_predecrement (unsigned &__x, bool)
S{
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Sinline
Slong __rw_atomic_predecrement (long &__x, bool)
S{
S    return __ATOMIC_DECREMENT_QUAD (&__x) - 1;
S}
S
S
Sinline
Sunsigned long __rw_atomic_predecrement (unsigned long &__x, bool)
S{
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_predecrement (_TypeT* &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       false));
S}
S
S
Sinline
Sint __rw_atomic_exchange (int &__x, int __y, bool)
S{
S    return __ATOMIC_EXCH_LONG (&__x, __y);
S}
S
S
Sinline
Sunsigned __rw_atomic_exchange (unsigned &__x, unsigned __y, bool)
S{
S    return __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (unsigned&, __x),
S                                 _RWSTD_STATIC_CAST (int, __y), false);
S}
S
S
Sinline
Slong __rw_atomic_exchange (long &__x, long __y, bool)
S{
S    return __ATOMIC_EXCH_QUAD (&__x, __y);
S}
S
S
Sinline
Sunsigned long __rw_atomic_exchange (unsigned long &__x, unsigned long __y, bool)
S{
S    return __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (unsigned long&, __x),
S                                 _RWSTD_STATIC_CAST (long, __y), false);
S}
S
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_exchange (_TypeT* &__x, const _TypeT* __y, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                   _RWSTD_REINTERPRET_CAST (long,  __y),
S                                   false));
S}
S
S/********************** gcc/i86 **************************************/
S
S#elif defined (__i386__) && defined (__GNUG__)
S
Sinline
Sint __rw_atomic_preincrement (int &__x, bool)
S{
S    __asm__ __volatile__ ("lock; addl $1,%0" : : "m" (__x));
S
S    return __x;
S}
S
S
Sinline
Sunsigned __rw_atomic_preincrement (unsigned &__x, bool)
S{
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Sinline
Slong __rw_atomic_preincrement (long &__x, bool)
S{
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Sinline
Sunsigned long __rw_atomic_preincrement (unsigned long &__x, bool)
S{
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_preincrement (_TypeT* &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       false));
S}
S
S
Sinline
Sint __rw_atomic_predecrement (int &__x, bool)
S{
S    __asm__ __volatile__ ("lock; subl $1,%0" : : "m" (__x));
S
S    return __x;
S}
S
Sinline
Sunsigned __rw_atomic_predecrement (unsigned &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (int));
S
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Sinline
Slong __rw_atomic_predecrement (long &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (int));
S
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Sinline
Sunsigned long __rw_atomic_predecrement (unsigned long &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (int));
S
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_predecrement (_TypeT* &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       false));
S}
S
S/********************** WIN 32/64 ************************************/
S
S#elif defined (_WIN32) && !defined (_RWSTD_NO_ATOMIC_OPERATIONS)
S
S// Interlocked[In|De]crement functions atomically modify their argument
S// and return the new value
S
S// InterlockedExchange atomically sets the value pointed to by the first
S// argument to that of the second argument and returns the original value
S
Sinline
Slong __rw_atomic_preincrement (long &__x, bool)
S{
S    return InterlockedIncrement (&__x);
S}
S
S
Sinline
Sunsigned long __rw_atomic_preincrement (unsigned long &__x, bool)
S{
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
Sinline
Sint __rw_atomic_preincrement (int &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
Sinline
Sunsigned int __rw_atomic_preincrement (unsigned int &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
S#if !defined (_WIN64)
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_preincrement (_TypeT* &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       false));
S}
S
S#endif   // _WIN64
S
Sinline
Slong __rw_atomic_predecrement (long &__x, bool)
S{
S    return InterlockedDecrement (&__x);
S}
S
S
Sinline
Sunsigned long __rw_atomic_predecrement (unsigned long &__x, bool)
S{
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
Sinline
Sint __rw_atomic_predecrement (int &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
Sinline
Sunsigned int __rw_atomic_predecrement (unsigned int &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
S#if !defined (_WIN64)
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_predecrement (_TypeT* &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       false));
S}
S
S#endif   // _WIN64
S
Sinline
Slong __rw_atomic_exchange (long &__x, long __y, bool)
S{
S    return InterlockedExchange (&__x, __y);
S}
S
S
Sinline
Sunsigned long __rw_atomic_exchange (unsigned long &__x, unsigned long __y,
S                                    bool)
S{
S    return __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                 _RWSTD_STATIC_CAST (long, __y), false);
S}
S
S
Sinline
Sint __rw_atomic_exchange (int &__x, int __y, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                 _RWSTD_STATIC_CAST (long, __y), false);
S}
S
S
Sinline
Sunsigned int __rw_atomic_exchange (unsigned int &__x, unsigned int __y, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                 _RWSTD_STATIC_CAST (long, __y), false);
S}
S
S
S#if !defined (_WIN64)
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_exchange (_TypeT* &__x, const _TypeT* __y, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                   _RWSTD_REINTERPRET_CAST (long,  __y),
S                                   false));
S}
S
S#endif   // _WIN64
S
S
Sinline
Slong __rw_atomic_preincrement (long &__x, __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_preincrement (__x, false);
S}
S
S
Sinline
Sunsigned long __rw_atomic_preincrement (unsigned long   &__x,
S                                        __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_preincrement (__x, false);
S}
S
S
Sinline
Sint __rw_atomic_preincrement (int &__x, __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_preincrement (__x, false);
S}
S
S
Sinline
Sunsigned int __rw_atomic_preincrement (unsigned int    &__x,
S                                       __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_preincrement (__x, false);
S}
S
S
S#if !defined (_WIN64)
S
Stemplate <class _TypeT>
Sinline
S_TypeT* __rw_atomic_preincrement (_TypeT*         &__x,
S                                  __rw_mutex_base &__mutex)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       __mutex));
S}
S
S#endif   // _WIN64
S
Sinline
Slong __rw_atomic_predecrement (long &__x, __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_predecrement (__x, false);
S}
S
S
Sinline
Sunsigned long __rw_atomic_predecrement (unsigned long   &__x,
S                                        __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_predecrement (__x, false);
S}
S
S
Sinline
Sint __rw_atomic_predecrement (int &__x, __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_predecrement (__x, false);
S}
S
S
Sinline
Sunsigned int __rw_atomic_predecrement (unsigned int    &__x,
S                                       __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_predecrement (__x, false);
S}
S
S
S#if !defined (_WIN64)
S
Stemplate <class _TypeT>
Sinline
S_TypeT* __rw_atomic_predecrement (_TypeT*         &__x,
S                                  __rw_mutex_base &__mutex)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       __mutex));
S}
S
S#endif   // _WIN64
S
Sinline
Slong __rw_atomic_exchange (long &__x, long __y, __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_exchange (__x, __y, false);
S}
S
S
Sinline
Sunsigned long __rw_atomic_exchange (unsigned long &__x, unsigned long __y,
S                                    __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_exchange (__x, __y, false);
S}
S
S
Sinline
Sint __rw_atomic_exchange (int &__x, int __y, __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_exchange (__x, __y, false);
S}
S
S
Sinline
Sunsigned int __rw_atomic_exchange (unsigned int &__x, unsigned int __y,
S                                   __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_exchange (__x, __y, false);
S}
S
S
S#if !defined (_WIN64)
S
Stemplate <class _TypeT>
Sinline
S_TypeT* __rw_atomic_exchange (_TypeT* &__x, const _TypeT* __y,
S                              __rw_mutex_base &__mutex)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                   _RWSTD_REINTERPRET_CAST (long,  __y),
S                                   __mutex));
S}
S
S#endif   // _WIN64
S
S#endif   // _WIN32
S
S
S_RWSTD_NAMESPACE_END   // __rw
S
S
N#else   // if !defined (_RWSTD_MULTI_THREAD)
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// atomic in a single-threaded environment
Ntemplate <class _TypeT, class _TypeU>
Ninline
N_TypeT __rw_atomic_exchange (_TypeT &__t, const _TypeU &__u, bool)
N{
N    _TypeT __tmp = __t;
N    __t = __u;
N    return __tmp;
N}
N
N
N// dummy classes used as a base class in single-threaded environments
N
Nstruct __rw_mutex_base
N{
N    void _C_acquire () { }
N
N    void _C_release () { }
N};
N
N
Nstruct _RWSTD_EXPORT __rw_mutex: public __rw_mutex_base
Xstruct  __rw_mutex: public __rw_mutex_base
N{
N};
N
N
Nstruct __rw_guard
N{
N    __rw_guard (__rw_mutex_base&) { }
N
N    __rw_guard (__rw_mutex_base*) { }
N
N    __rw_mutex_base* _C_set (__rw_mutex_base*) {
N        return 0;
N    }
N};
N
N
Nstruct __rw_synchronized
N{
N    // static so that it takes up no room
N    static __rw_mutex _C_mutex;
N
N    void _C_lock () { }
N
N    void _C_unlock () { }
N
N    __rw_guard _C_guard () {
N        return __rw_guard (_C_mutex);
N    }
N};
N
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N#endif   // _RWSTD_MULTI_THREAD
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// available in all environments (ST and MT), used along with
N// __rw_atomic_exchange<>() from conditional expressions in iostreams
Ntemplate <class _TypeT, class _TypeU>
Ninline
N_TypeT __rw_ordinary_exchange (_TypeT &__t, const _TypeU &__u)
N{
N    _TypeT __tmp = __t;
N    __t = __u;
N    return __tmp;
N}
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N#endif   // _RWSTD_MUTEX_H_INCLUDED
N
L 53 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\memory" 2
N#include <rw/_defs.h>
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// [de]allocate storage (in bytes)
N_RWSTD_EXPORT void* __rw_allocate (_RWSTD_C::size_t, int = 0);
X void* __rw_allocate (std::size_t, int = 0);
N_RWSTD_EXPORT void  __rw_deallocate (void*, _RWSTD_C::size_t, int = 0);
X void  __rw_deallocate (void*, std::size_t, int = 0);
N
N// this function returns a suggested new capacity for a container needing
N// more room; see stddefs.h for an explanation of these macro parameters;
N// the _Container template parameter allows more specialized overloads
N// for customization
Ntemplate <class _Container>
Ninline _RWSTD_C::size_t __rw_new_capacity (_RWSTD_C::size_t __size, const _Container*)
Xinline std::size_t __rw_new_capacity (std::size_t __size, const _Container*)
N{
N    _RWSTD_C::size_t __cap = _RWSTD_STATIC_CAST (_RWSTD_C::size_t,
N                                       _RWSTD_INCREASE_CAPACITY(__size)
N                                       /*__size * _RWSTD_NEW_CAPACITY_RATIO*/);
X    std::size_t __cap = static_cast< std::size_t >(((__size) + ((__size) >> 1) + ((__size) >> 3)));
N    return (__size += _RWSTD_MINIMUM_NEW_CAPACITY) > __cap ? __size : __cap;
X    return (__size += std::size_t (32)) > __cap ? __size : __cap;
N}
N
N
Ntemplate <class _TypeT>
Ninline void __rw_destroy (_TypeT &__ref)
N{
N    __ref.~_TypeT ();
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline void __rw_construct (_TypeT* __p, const _TypeU& __val)
N{
N    new (__p) _TypeT (__val);
N}
N
N
Ntemplate <class _ForwardIterator> 
Nvoid __rw_destroy (_ForwardIterator __first, _ForwardIterator __last)
N{
N    for (; __first != __last; ++__first)
N        __rw_destroy (*__first);
N}
N
N
N#ifndef _RWSTD_NO_PTR_VALUE_TEMPLATE_OVERLOAD
N
N// for compilers that don't optimize "empty" loops
Ntemplate <class _TypeT> 
Ninline void __rw_destroy (_TypeT**, _TypeT**)
N{ }
N
N#endif   // _RWSTD_NO_PTR_VALUE_TEMPLATE_OVERLOAD
N
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
Ntemplate <class _TypeT> class
Nallocator;
N
N
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
Nclass allocator<void>
N{
Npublic:
N    typedef void*       pointer;
N    typedef const void* const_pointer;
N    typedef void        value_type;
N   
N
N#ifdef _RWSTD_ALLOCATOR
N
N    template <class _TypeU> 
N    struct rebind {
N        typedef allocator<_TypeU> other;
N    };
N
N#endif /* _RWSTD_ALLOCATOR */
N    
N};
N
N
Ntemplate <class _TypeT>
Nclass allocator
N{
Npublic:
N    typedef _RWSTD_C::size_t    size_type;
X    typedef std::size_t    size_type;
N    typedef ptrdiff_t           difference_type;
N    typedef _TypeT              value_type;
N    typedef value_type*         pointer;
N    typedef const value_type*   const_pointer;
N    typedef value_type&         reference;
N    typedef const value_type&   const_reference;
N
N    allocator () _THROWS (()) { }
X    allocator ()  { }
N
N    allocator (const allocator &__rhs) _THROWS (()) {
X    allocator (const allocator &__rhs)  {
N        // working around an HP aCC warning 431
N        _RWSTD_UNUSED (__rhs);
X        ((void)&__rhs);
N    }
N
N#ifdef _RWSTD_ALLOCATOR
N
N    template <class _TypeU> 
N    struct rebind {
N        typedef allocator<_TypeU> other;
N    };
N
N    template <class _TypeU>
N    allocator (const allocator<_TypeU>&) _THROWS (()) { }
X    allocator (const allocator<_TypeU>&)  { }
N
N    template <class _TypeU>
N    allocator&
N    operator= (const allocator<_TypeU>&) _THROWS (()) { 
X    operator= (const allocator<_TypeU>&)  { 
N        return *this; 
N    }
N
N#endif   // _RWSTD_ALLOCATOR
N
N
N    pointer address (reference __x) const { 
N        return &__x; 
N    }
N
N    const_pointer address (const_reference __x) const { 
N        return &__x;
N    }
N
N    pointer allocate (size_type __n, allocator<void>::const_pointer = 0) {
N
N#ifdef _RWSTD_ALLOCATOR
N        return _RWSTD_STATIC_CAST (pointer,
N                   _RW::__rw_allocate (__n * sizeof (value_type)));
X        return static_cast< pointer >(__rw::__rw_allocate (__n * sizeof (value_type)));
N#else
S        return _RWSTD_STATIC_CAST (pointer, _RW::__rw_allocate (__n));
N#endif   // _RWSTD_ALLOCATOR
N    }
N
N#ifdef _RWSTD_ALLOCATOR        
N    void deallocate (pointer __p, size_type __n)
N#else
S    void deallocate (void* __p, size_type __n)
N#endif   // _RWSTD_ALLOCATOR
N    {
N        _RW::__rw_deallocate (__p, __n);
X        __rw::__rw_deallocate (__p, __n);
N    }
N
N    // 20.4.1.1, p11 - the largest N for which allocate (N) might succeed
N    size_type max_size () const _THROWS (()) { 
X    size_type max_size () const  { 
N        return size_type (~0) / sizeof (value_type) ?
N            size_type (size_type (~0) / sizeof (value_type)) : size_type (1);
N    }
N
N    void construct (pointer __p, const_reference __val) {
N        _RW::__rw_construct (__p, __val);
X        __rw::__rw_construct (__p, __val);
N    }
N    
N    void destroy (pointer __p) {
N        _RWSTD_ASSERT (0 != __p);
X        ((void)0);
N        _RW::__rw_destroy (*__p);
X        __rw::__rw_destroy (*__p);
N    }
N};
N
N
N#if    !defined (_RWSTD_NO_CLASS_PARTIAL_SPEC) \
N    && !defined (_RWSTD_NO_EXT_CONST_ALLOCATOR)
X#if    !0L     && !0L
N
N// extension: allocates/constructs/destroys const elements
N
Ntemplate <class _TypeT>
Nclass allocator<const _TypeT>
N{
Npublic:
N    typedef _RWSTD_C::size_t    size_type;
X    typedef std::size_t    size_type;
N    typedef ptrdiff_t           difference_type;
N    typedef const _TypeT        value_type;
N    typedef const value_type*   pointer;
N    typedef const value_type*   const_pointer;
N    typedef const value_type&   reference;
N    typedef const value_type&   const_reference;
N
N    allocator () _THROWS (()) { }
X    allocator ()  { }
N
N    allocator (const allocator &__rhs) _THROWS (()) {
X    allocator (const allocator &__rhs)  {
N        // working around an HP aCC warning 431
N        _RWSTD_UNUSED (__rhs);
X        ((void)&__rhs);
N    }
N
N#ifdef _RWSTD_ALLOCATOR
N
N    template <class _TypeU> 
N    struct rebind {
N        typedef allocator<_TypeU> other;
N    };
N
N    template <class _TypeU>
N    allocator (const allocator<_TypeU>&) _THROWS (()) { }
X    allocator (const allocator<_TypeU>&)  { }
N
N    template <class _TypeU>
N    allocator& operator= (const allocator<_TypeU>&) _THROWS (()) { 
X    allocator& operator= (const allocator<_TypeU>&)  { 
N        return *this; 
N    }
N
N#endif   // _RWSTD_ALLOCATOR
N
N    const_pointer address (const_reference __x) const { 
N        return &__x;
N    }
N
N    const_pointer
N    allocate (size_type __n, allocator<void>::const_pointer = 0) { 
N
N#ifdef _RWSTD_ALLOCATOR
N        return _RWSTD_STATIC_CAST (const_pointer,
N                   _RW::__rw_allocate (__n * sizeof (value_type)));
X        return static_cast< const_pointer >(__rw::__rw_allocate (__n * sizeof (value_type)));
N#else
S        return _RWSTD_STATIC_CAST (const_pointer, _RW::__rw_allocate (__n));
N#endif   // _RWSTD_ALLOCATOR
N
N    }
N
N#ifdef _RWSTD_ALLOCATOR        
N    void deallocate (const_pointer __p, size_type __n /* elements */)
N#else
S    void deallocate (const void* __p, size_type __n /* bytes */)
N#endif   // _RWSTD_ALLOCATOR
N    {
N        _RW::__rw_deallocate (_RWSTD_CONST_CAST (_TypeT*, __p), __n);
X        __rw::__rw_deallocate (const_cast< _TypeT* >(__p), __n);
N    }
N
N    // 20.4.1.1, p11 - the largest N for which allocate (N) might succeed
N    size_type max_size () const _THROWS (()) { 
X    size_type max_size () const  { 
N        return ~size_type (0) / sizeof (value_type) ?
N            size_type (size_type (~0) / sizeof (value_type)) : size_type (1);
N    }
N
N    void construct (const_pointer __p, const_reference __val) {
N        _RW::__rw_construct (_RWSTD_CONST_CAST (_TypeT*, __p), __val);
X        __rw::__rw_construct (const_cast< _TypeT* >(__p), __val);
N    }
N    
N    void destroy (const_pointer __p) {
N        _RWSTD_ASSERT (0 != __p);
X        ((void)0);
N        _RW::__rw_destroy (_RWSTD_CONST_CAST (_TypeT&, *__p));
X        __rw::__rw_destroy (const_cast< _TypeT& >(*__p));
N    }
N};
N
N#endif   // !_RWSTD_NO_CLASS_PARTIAL_SPEC && !_RWSTD_NO_EXT_CONST_ALLOCATOR)
N
N
N// allocator_interface provides all types and typed functions.  Memory
N// allocated as raw bytes using the class provided by the Allocator
N// template parameter.  allocator_interface casts appropriately.
N//
N// Multiple allocator_interface objects can attach to a single 
N// allocator, thus allowing one allocator to allocate all storage
N// for a container, regardless of how many types are involved.
N//
N// The only real restriction is that pointer and reference are
N// hard coded as _TypeT* and _TypeT&.  Partial specialization would 
N// get around this.
N//
N#ifndef _RWSTD_ALLOCATOR
S
Stemplate <class _Allocator, class _TypeT>
Sclass allocator_interface 
S{
Spublic:
S    typedef _Allocator                                allocator_type;
S    typedef _TypeT                                    value_type;
S    typedef value_type*                               pointer;
S    typedef const value_type*                         const_pointer;
S    typedef value_type&                               reference;
S    typedef const value_type&                         const_reference;
S    typedef _TYPENAME allocator_type::size_type       size_type;
S    typedef _TYPENAME allocator_type::difference_type difference_type;
S
Sprotected:
S    allocator_type _C_alloc;
S
Spublic:
S    allocator_interface()  _THROWS (())  { }
S
S    allocator_interface (const allocator_type &__alloc)  _THROWS (())
S    : _C_alloc (__alloc) { }
S
S    operator allocator_type& () {
S        return _C_alloc;
S    }
S
S    pointer address (reference __x) { 
S        return &__x;
S    }
S  
S    size_type max_size () const { 
S        return _C_alloc.max_size () / sizeof (value_type);
S    }
S
S    pointer allocate (size_type __n, const void* __p = 0) {
S        //using c-style cast to perform reinterpret-cast & const-cast in 1 step
S        return (pointer)_C_alloc.allocate (__n * sizeof (value_type),
S                                           (pointer) __p );
S    }
S
S    void deallocate (pointer __p, size_type __n) {
S        _C_alloc.deallocate (__p, __n);
S    }
S
S    void construct (pointer __p, const_reference __val) const {
S        _RW::__rw_construct(__p, __val);
S    }
S
S    void destroy (pointer __p) const {
S        _RWSTD_ASSERT (0 != __p);
S        _RW::__rw_destroy (*__p);
S    }
S};
S
S
S_RWSTD_SPECIALIZED_CLASS
Sclass allocator_interface<allocator<void>, void> 
S{
Spublic:
S    typedef allocator<void> allocator_type;
S    typedef void*           pointer;
S    typedef const void*     const_pointer;      
S    typedef void            value_type;
S
Sprotected:
S    allocator_type _C_alloc;
S
Spublic:
S    allocator_interface () _THROWS (()) { }
S
S    allocator_interface (const allocator<void>& __rhs) _THROWS (())
S    : _C_alloc (__rhs) { }
S
S};
S
S
Stemplate <class _TypeT, class _TypeU, class _TypeV, class _TypeW>
Sinline bool
Soperator== (const allocator_interface<_TypeT, _TypeU>&, 
S            const allocator_interface<_TypeV, _TypeW>&) _THROWS (())
S{
S    return true;
S}
S
N#endif  // _RWSTD_ALLOCATOR
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator== (const allocator<_TypeT>&, const allocator<_TypeU>&)  _THROWS (())
Xoperator== (const allocator<_TypeT>&, const allocator<_TypeU>&)  
N{
N    return true;
N}
N
N
N#ifndef _RWSTD_NO_NAMESPACE
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator!= (const allocator<_TypeT>& __x,
N            const allocator<_TypeU>& __y)  _THROWS (())
X            const allocator<_TypeU>& __y)  
N{
N    return !(__x == __y);
N}
N
N#endif   // _RWSTD_NO_NAMESPACE
N
N
N// 20.4.2
Ntemplate <class _OutputIterator, class _TypeT>
Nclass raw_storage_iterator
N    : public iterator<output_iterator_tag, void, void, void, void>
N{
N    _OutputIterator _C_iter;
Npublic:
N
N    // for completeness and genericity
N    typedef _OutputIterator iterator_type;
N
N    // 20.4.2, p2
N    _EXPLICIT raw_storage_iterator (iterator_type __x) : _C_iter (__x) { }
X    explicit raw_storage_iterator (iterator_type __x) : _C_iter (__x) { }
N
N    // 20.4.2, p3
N    raw_storage_iterator& operator* () {
N        return *this;
N    }
N
N    // 20.4.2, p4
N    raw_storage_iterator& operator= (const _TypeT& __rhs) {
N        ::new (&(*_C_iter)) _TypeT (__rhs);
N        return *this;
N    }
N
N    // 20.4.2, p6
N    raw_storage_iterator& operator++ () {
N        ++_C_iter;
N        return *this;
N    }
N
N    // 20.4.2, p7
N    raw_storage_iterator operator++ (int) {
N        raw_storage_iterator __tmp = *this;
N        ++*this;
N        return __tmp;
N    }
N};
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// __rw_indestructible specializations should be objects with static
N// storage duration that must "survive" all other static objects and that
N// do not need to be destroyed; this is a POD
Ntemplate <class _TypeT>
Nclass __rw_indestructible
N{
N    union _C_data_t {
N        char        _C_data;      // data to back _TypeT up with 
N        long double _C_padding;   // make sure data is suitably aligned
N    };
N
N    enum { _C_n = 1 + sizeof (_TypeT) / sizeof (_C_data_t) };
N
N    _C_data_t _C_data [_C_n];     // raw storage for an object of _TypeT
N
Npublic:
N    typedef _TypeT            value_type;
N    typedef value_type&       reference;
N    typedef const value_type& const_reference;
N    typedef value_type*       pointer;
N    typedef const value_type* const_pointer;
N
N    // no ctor to allow static POD initialization (3.6.2, p1)
N
N    // allow this to be used as a an obejct of another type
N    operator reference () {
N        return _RWSTD_REINTERPRET_CAST (reference, *_C_data);
X        return reinterpret_cast< reference >(*_C_data);
N    }
N
N    operator const_reference () const {
N        return _RWSTD_REINTERPRET_CAST (const_reference, *_C_data);
X        return reinterpret_cast< const_reference >(*_C_data);
N    }
N
N    // calls a conversion operator above
N    pointer operator& () {
N        // deprecated C-style cast used to make SunPro 5.0/T9 happy
N        // return &_RWSTD_STATIC_CAST (reference, *this);
N
N        return &(reference)*this;
N    }
N    
N    // calls a conversion operator above
N    const_pointer operator& () const {
N        // deprecated C-style cast used to make SunPro 5.0/T9 happy
N        // return &_RWSTD_STATIC_CAST (const_reference, *this);
N
N        return &(const_reference)*this;
N    }
N};
N
N
N#ifdef _INLINE_WITH_STATICS
N
N_INLINE_WITH_STATICS _RWSTD_EXPORT char* __rw_get_static_buf ()
Xinline  char* __rw_get_static_buf ()
N{
N    typedef char _CharBuf [_RWSTD_TMPBUF_SIZE + 1];
X    typedef char _CharBuf [4096 + 1];
N
N    // use `indestructible' to guarantee proper buffer alignment
N    static __rw_indestructible<_CharBuf> __buffer;
N
N    return _RWSTD_STATIC_CAST (char*, __buffer);
X    return static_cast< char* >(__buffer);
N}
N
N
N// [de]allocates a previously allocated temporary buffer
N// the constant _RWSTD_TMPBUF_SIZE controls the size of a static buffer
N// if request for area larger than _RWSTD_TMPBUF_SIZE comes in,
N// space is allocated dynamically, otherwise the static buffer is used
N// return value meaningful only if __n != 0
N_INLINE_WITH_STATICS _RWSTD_EXPORT _STD::pair<void*, _RWSTD_C::size_t>
Xinline  std::pair<void*, std::size_t>
N__rw_reallocate_temp_buffer (void *__p, _RWSTD_C::size_t __size)
X__rw_reallocate_temp_buffer (void *__p, std::size_t __size)
N{
N    // implicit initialization used to prevent a g++ 2.95.2 warning on Tru64
N    // sorry: semantics of inline function static data are wrong (you'll wind
N    // up with multiple copies)
N
N    static unsigned long __busy /* = 0 */;   // > 0 when buffer in use
N
N    unsigned long __cntr = _RWSTD_ATOMIC_PREINCREMENT (__busy, false);
X    unsigned long __cntr = ++(__busy);
N
N    static char *__buffer = __rw_get_static_buf ();
N
N    if (__p == (void*)__buffer) {
N        __p    = 0;
N        __size = 0;
N
N        // returning buffer, decrement usage counter
N        _RWSTD_ATOMIC_PREDECREMENT (__busy, false);
X        --(__busy);
N    }
N    else
N        ::operator delete (__p);
N
N    if (__size == 0) {
N        // buffer not used, decrement usage counter
N        _RWSTD_ATOMIC_PREDECREMENT (__busy, false);
X        --(__busy);
N    }
N    else if (__size > _RWSTD_TMPBUF_SIZE || __cntr > 1) {
X    else if (__size > 4096 || __cntr > 1) {
N        _TRY {
X         {
N            __p = ::operator new (__size);
N        }
N        _CATCH (...) {
X        while (0) {
N            __p    = 0;
N            __size = 0;
N        }
N
N        // buffer not used, decrement usage counter
N        _RWSTD_ATOMIC_PREDECREMENT (__busy, false);
X        --(__busy);
N    }
N    else {
N        __p = __buffer;
N
N        // buffer used, usage counter stays non-zero
N    }
N
N    return _STD::pair<void*, _RWSTD_C::size_t>(__p, __size);
X    return std::pair<void*, std::size_t>(__p, __size);
N}
N
N#else   // if !defined (_INLINE_WITH_STATICS)
S
S_STD::pair<void*, _RWSTD_C::size_t> _RWSTD_EXPORT
S__rw_reallocate_temp_buffer (void*, _RWSTD_C::size_t);
S
N#endif   // _INLINE_WITH_STATICS
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N// 20.4.3 only specifies a get_temporary_buffer<>() that takes a ptrdiff_t.
N// We overload on all types so that signed integral types other than ptrdiff_t
N// can be used. This is important in getting algorithms to compile with
N// user-defined iterators (not derived from iterator<...>) whose difference
N// type is something other than ptrdiff_t.
N
N// having this overload is important in some cases for compilers that
N// do not support partial class specialization (and where as a consequence
N// iterator_traits<> isn't available)
Ntemplate <class _TypeT, class _Distance>
Ninline pair<_TypeT*, _Distance> get_temporary_buffer (_Distance __n, _TypeT*)
N{
N    pair<void*, size_t> __pair =
N        _RW::__rw_reallocate_temp_buffer (0, __n * sizeof (_TypeT));
X        __rw::__rw_reallocate_temp_buffer (0, __n * sizeof (_TypeT));
N
N    return make_pair (_RWSTD_STATIC_CAST (_TypeT*, __pair.first),
X    return make_pair (static_cast< _TypeT* >(__pair . first),
N                      _Distance (__pair.second / sizeof (_TypeT)));
N}
N
N
N#ifndef _RWSTD_NO_TEMPLATE_ON_RETURN_TYPE
N
N// 20.4.3, p1
Ntemplate <class _TypeT>
Ninline pair<_TypeT*, ptrdiff_t> get_temporary_buffer (ptrdiff_t __n)
N{
N    return get_temporary_buffer (__n, (_TypeT*)0);
N}
N
N#endif   // _RWSTD_NO_TEMPLATE_ON_RETURN_TYPE
N
N
N// 20.4.3, p3
Ntemplate <class _TypeT>
Ninline void return_temporary_buffer (_TypeT *__p)
N{
N    _RW::__rw_reallocate_temp_buffer (__p, 0);
X    __rw::__rw_reallocate_temp_buffer (__p, 0);
N}
N
N
N// 20.4.4.1
Ntemplate <class _InputIterator, class _ForwardIterator>
Ninline
N_ForwardIterator uninitialized_copy (_InputIterator   __first,
N                                     _InputIterator   __last,
N                                     _ForwardIterator __res)
N{
N    _ForwardIterator __start = __res;
N
N    _TRY {
X     {
N        for (; __first != __last; ++__first, ++__res)
N            _RW::__rw_construct (&*__res, *__first);
X            __rw::__rw_construct (&*__res, *__first);
N    }
N    _CATCH (...) {
X    while (0) {
N        _RW::__rw_destroy (__start, __res);
X        __rw::__rw_destroy (__start, __res);
N        _RETHROW;
X        ((void)0);
N    }
N
N    return __res;
N}
N
N
N#ifdef _RWSTD_ALLOCATOR
N
N// extension
Ntemplate <class _InputIterator, class _ForwardIterator, class _Allocator>
Ninline
N_ForwardIterator uninitialized_copy (_InputIterator   __first,
N                                     _InputIterator   __last,
N                                     _ForwardIterator __res,
N                                     _Allocator&      __alloc)
N{
N    _ForwardIterator __start = __res;
N
N    _TRY {
X     {
N        for (; __first != __last; ++__first, ++__res)
N            __alloc.construct (&*__res, *__first);
N    }
N    _CATCH (...) {
X    while (0) {
N        for (; __start != __res; ++__start)
N            __alloc.destroy (&*__start);
N        _RETHROW;
X        ((void)0);
N    }
N
N    return __res;
N}
N
N#endif   // _RWSTD_ALLOCATOR
N
N
N// 20.4.4.2
Ntemplate <class _ForwardIterator, class _TypeT>
Ninline
Nvoid uninitialized_fill (_ForwardIterator __first, _ForwardIterator __last,
N                         const _TypeT& __x)
N{
N    _ForwardIterator __start = __first;
N
N    _TRY {
X     {
N        for (; __first != __last; ++__first)
N            _RW::__rw_construct (&*__first, __x);
X            __rw::__rw_construct (&*__first, __x);
N    }
N    _CATCH (...) {
X    while (0) {
N        _RW::__rw_destroy (__start, __first);
X        __rw::__rw_destroy (__start, __first);
N        _RETHROW;
X        ((void)0);
N    }
N}
N
N
N// 20.4.4.3
Ntemplate <class _ForwardIterator, class _Size, class _TypeT>
Ninline
Nvoid uninitialized_fill_n (_ForwardIterator __first, _Size __n,
N                           const _TypeT& __x)
N{
N    _ForwardIterator __start = __first;
N
N    _TRY {
X     {
N        for (; __n; --__n, ++__first)
N            _RW::__rw_construct (&*__first, __x);
X            __rw::__rw_construct (&*__first, __x);
N    }
N    _CATCH (...) {
X    while (0) {
N        _RW::__rw_destroy (__start, __first);
X        __rw::__rw_destroy (__start, __first);
N        _RETHROW;
X        ((void)0);
N    }
N}
N
N
N#ifdef _RWSTD_ALLOCATOR
N
N// extension
Ntemplate <class _ForwardIter, class _Size, class _TypeT, class _Allocator>
Ninline
Nvoid uninitialized_fill_n (_ForwardIter __first, _Size __n,
N                           const _TypeT& __x, _Allocator& __alloc)
N{
N    _ForwardIter __start = __first;
N
N    _TRY {
X     {
N        for (; __n; --__n, ++__first)
N            __alloc.construct (&*__first, __x);
N    }
N    _CATCH (...) {
X    while (0) {
N        for (; __start != __first; ++__start)
N            __alloc.destroy (&*__start);
N        _RETHROW;
X        ((void)0);
N    }
N}
N
N#else   // if !defined (_RWSTD_ALLOCATOR)
S
S// Specializations for non-standard allocators.  When vector calls
S// uninitialized_{copy,fill_n} with non-standard allocator, a temporary
S// instance of allocator_interface is passed to these functions.  Since
S// C++ forbids temporaries to be passed as non-const references, we
S// use these specializations to pass a const reference (and we can force
S// allocator_interface members construct & destroy to be const).
S
Stemplate <class _InputIterator, class _ForwardIterator,
S          class _Allocator, class _TypeT>
Sinline _ForwardIterator
Suninitialized_copy (_InputIterator   __first,
S                    _InputIterator   __last,
S                    _ForwardIterator __res,
S                    const allocator_interface<_Allocator, _TypeT>& __alloc)
S{
S    _ForwardIterator __start = __res;
S
S    _TRY {
S        for (; __first != __last; ++__first, ++__res)
S            __alloc.construct (&*__res, *__first);
S    }
S    _CATCH (...) {
S        for (; __start != __res; ++__start)
S            __alloc.destroy (&*__start);
S        _RETHROW;
S    }
S
S    return __res;
S}
S
Stemplate <class _ForwardIter, class _Size,
S          class _TypeT, class _Allocator, class _TypeU>
Sinline void
Suninitialized_fill_n (_ForwardIter __first, _Size __n,
S                      const _TypeT& __x,
S                      const allocator_interface<_Allocator, _TypeU>& __alloc)
S{
S    _ForwardIter __start = __first;
S
S    _TRY {
S        for (; __n; --__n, ++__first)
S            __alloc.construct (&*__first, __x);
S    }
S    _CATCH (...) {
S        for (; __start != __first; ++__start)
S            __alloc.destroy (&*__start);
S        _RETHROW;
S    }
S}
S
N#endif   // _RWSTD_ALLOCATOR
N
N
N// 20.4.5 - Template class auto_ptr
N
Ntemplate<class _TypeT>
Nclass auto_ptr;
N
N
N// 20.4.5, p2 (defined outside of auto_ptr<> according to the proposed
N// resolution of lwg issue 127)
Ntemplate <class _TypeT>
Nclass auto_ptr_ref 
N{
Npublic:
N    auto_ptr<_TypeT>& _C_ptr;
N
N    auto_ptr_ref (auto_ptr<_TypeT>& __rhs) : _C_ptr (__rhs) { }
N};
N
N
Ntemplate<class _TypeT>
Nclass auto_ptr
N{
Npublic:
N    typedef _TypeT element_type;
N
N    _EXPLICIT auto_ptr (element_type* __p = 0) _THROWS (())
X    explicit auto_ptr (element_type* __p = 0) 
N     : _C_ptr (__p) { }
N
N    auto_ptr (auto_ptr& __rhs) _THROWS (())
X    auto_ptr (auto_ptr& __rhs) 
N     : _C_ptr (__rhs.release ()) { }
N
N    auto_ptr& operator= (auto_ptr& __rhs) _THROWS (()) { 
X    auto_ptr& operator= (auto_ptr& __rhs)  { 
N        reset (__rhs.release ());
N        return *this;
N    }
N
N    // follows lwg issue 127
N    auto_ptr&
N    operator= (auto_ptr_ref<element_type> __rhs) _THROWS (()) {
X    operator= (auto_ptr_ref<element_type> __rhs)  {
N        reset (__rhs._C_ptr.release ());
N        return *this;
N    }
N
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N
N    template <class _TypeU>
N    operator auto_ptr_ref<_TypeU>() _THROWS (()) {
X    operator auto_ptr_ref<_TypeU>()  {
N        return auto_ptr_ref<_TypeU>(*this);
N    }
N
N    template <class _TypeU> 
N    operator auto_ptr<_TypeU>() _THROWS (()) {
X    operator auto_ptr<_TypeU>()  {
N        return auto_ptr<_TypeU>(release ());
N    }
N
N    template <class _TypeU>
N    auto_ptr (auto_ptr<_TypeU>& __rhs) _THROWS (())
X    auto_ptr (auto_ptr<_TypeU>& __rhs) 
N    : _C_ptr (__rhs.release ()) { }
N
N    template <class _TypeU>
N    auto_ptr& operator= (auto_ptr<_TypeU>& __rhs)  _THROWS (()) { 
X    auto_ptr& operator= (auto_ptr<_TypeU>& __rhs)   { 
N        reset (__rhs.release ());
N        return *this;
N    }
N
N#endif   // _RWSTD_NO_MEMBER_TEMPLATES
N
N
N    ~auto_ptr () _THROWS (()) {
X    ~auto_ptr ()  {
N        delete _C_ptr;
N    }
N
N    element_type* get () const _THROWS (()) {
X    element_type* get () const  {
N        return _C_ptr;
N    }
N
N    element_type& operator* () const _THROWS (()) {
X    element_type& operator* () const  {
N        _RWSTD_ASSERT (0 != get ());
X        ((void)0);
N        return *get (); 
N    }
N
N    _RWSTD_OPERATOR_ARROW (
N        element_type* operator-> () const _THROWS (()))
X    element_type* operator-> () const { return & * *this; }
N
N    element_type* release () _THROWS (()) { 
X    element_type* release ()  { 
N        element_type* __tmp = _C_ptr;
N        _C_ptr = 0;
N        return __tmp; 
N    }
N
N    void reset (element_type* __p = 0) _THROWS (()) { 
X    void reset (element_type* __p = 0)  { 
N        if (_C_ptr != __p) {
N            delete _C_ptr;
N            _C_ptr = __p;
N        }
N    }
N
N    auto_ptr (auto_ptr_ref<element_type> __r) _THROWS (())
X    auto_ptr (auto_ptr_ref<element_type> __r) 
N    : _C_ptr (__r._C_ptr.release ()) { }
N
Nprivate:
N    element_type* _C_ptr;
N};
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#endif   // _RWSTD_MEMORY_INCLUDED
N
L 50 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\vector" 2
N
N#include <rw/_algobase.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_algobase.h" 1
N/***************************************************************************
N *
N * _algobase.h - Declarations and inline definitions of frequently used
N *               C++ Standard Library algorithms
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id: _algobase.h 172106 2011-11-02 17:04:12Z statham $
N *
N ***************************************************************************
N *
N * Copyright (c) 1994
N * Hewlett-Packard Company
N *
N * Permission to use, copy, modify, distribute and sell this software
N * and its documentation for any purpose is hereby granted without fee,
N * provided that the above copyright notice appear in all copies and
N * that both that copyright notice and this permission notice appear
N * in supporting documentation.  Hewlett-Packard Company makes no
N * representations about the suitability of this software for any
N * purpose.  It is provided "as is" without express or implied warranty.
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_ALGOBASE_H_INCLUDED
N#define _RWSTD_ALGOBASE_H_INCLUDED
N
N#include <utility>   // for pair
N
N#ifndef _RWSTD_NO_DEBUG_ITER
S#  include <rw/_iterbase.h>
N#endif   // _RWSTD_NO_DEBUG_ITER
N
N
N#undef max
N#undef min
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N// 25.3.7, p1
Ntemplate <class _TypeT>
Ninline const _TypeT& min (const _TypeT& __a, const _TypeT& __b)
N{
N    return __b < __a ? __b : __a;
N}
N
Ntemplate <class _TypeT, class _Compare>
Ninline const _TypeT& min (const _TypeT& __a, const _TypeT& __b, _Compare __cmp)
N{
N    return __cmp (__b, __a) ? __b : __a;
N}
N
N
N// 25.3.7, p3
Ntemplate <class _TypeT>
Ninline const _TypeT& max (const _TypeT& __a, const _TypeT& __b)
N{
N    return  __a < __b ? __b : __a;
N}
N
N
Ntemplate <class _TypeT, class _Compare>
Ninline const _TypeT& max (const _TypeT& __a, const _TypeT& __b, _Compare __cmp)
N{
N    return __cmp (__a, __b) ? __b : __a;
N}
N
N
N// 25.2.1, p1
Ntemplate <class _InputIter, class _OutputIter>
Ninline _OutputIter
Ncopy (_InputIter __first, _InputIter __last, _OutputIter __res)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    for (; __first != __last; ++__first,++__res)
N        *__res = *__first;
N    return __res;
N}
N
N
N// 25.2.1, p5
Ntemplate <class _BidirIter1, class _BidirIter2>
Ninline _BidirIter2
Ncopy_backward (_BidirIter1 __first, _BidirIter1 __last, _BidirIter2 __res)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    while (__first != __last)
N        *--__res = *--__last;
N    return __res;
N}
N
N
N// 25.2.5
Ntemplate <class _FwdIter, class _TypeT>
Ninline void fill (_FwdIter __first, _FwdIter __last, const _TypeT& __value)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    for (;__first != __last; ++__first)
N        *__first = __value;
N}
N
N
Ntemplate <class _OutputIter, class _Size, class _TypeT>
Ninline void fill_n (_OutputIter __first, _Size __n, const _TypeT& __value)
N{
N    for (;__n > 0;--__n, ++__first)
N        *__first = __value;
N}
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// `less than' qusi-function object - used by algorithms for code reuse
Ntemplate <class _TypeT>
Nstruct __rw_lt
N{
N    bool operator() (const _TypeT &__lhs, const _TypeT &__rhs) const {
N        return __lhs < __rhs;
N    }
N};
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N#  define _RWSTD_LESS(iterT) \
N     _RW::__rw_lt<_TYPENAME _STD::iterator_traits< iterT >::value_type>()
X#  define _RWSTD_LESS(iterT)      _RW::__rw_lt<_TYPENAME _STD::iterator_traits< iterT >::value_type>()
N
N#else   // if defined (_RWSTD_NO_PARTIAL_CLASS_SPEC)
S
S#  define _RWSTD_LESS(iterT) \
S     _RW::__rw_make_lt (_RWSTD_VALUE_TYPE (iterT))
X#  define _RWSTD_LESS(iterT)      _RW::__rw_make_lt (_RWSTD_VALUE_TYPE (iterT))
S
Stemplate <class _TypeT>
S__rw_lt<_TypeT> __rw_make_lt (const _TypeT*)
S{
S    return __rw_lt<_TypeT>();
S}
S
N#endif   // _RWSTD_NO_PARTIAL_CLASS_SPEC
N
N
N// swaps values of 2 (possibly distinct) types
Ntemplate <class _TypeT, class _TypeU>
Ninline void __rw_swap (_TypeT& __a, _TypeU& __b)
N{
N    // _TypeT must satisfy Assignable and CopyConstructible
N    _TypeT __tmp = __a;
N    __a = __b;
N    __b = __tmp;
N}
N
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N// 25.2.2, p1
Ntemplate <class _TypeT>
Ninline void swap (_TypeT& __a, _TypeT& __b)
N{
N    // LWG issue 227 - _TypeT must satisfy Assignable and CopyConstructible
N    _TypeT __tmp = __a;
N    __a = __b;
N    __b = __tmp;
N}
N
N
N// 25.2.2, p7
Ntemplate <class _FwdIter1, class _FwdIter2>
Ninline void iter_swap (_FwdIter1 __a, _FwdIter2 __b)
N{
N    // std::iterator_traits<_FwdIter[12]>::value_type must satisfy
N    // both Assignable and CopyConstructible
N    _RW::__rw_swap (*__a, *__b);
X    __rw::__rw_swap (*__a, *__b);
N}
N
N
N// 25.1.7 - Mismatch
Ntemplate <class _InputIter1, class _InputIter2>
Ninline pair<_InputIter1, _InputIter2>
Nmismatch (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2)
N{
N    _RWSTD_ASSERT_RANGE (__first1, __last1);
X    ((void)0);
N
N    while (__first1 != __last1 && *__first1 == *__first2) {
N        ++__first1;
N        ++__first2;
N    }
N    return pair<_InputIter1, _InputIter2> (__first1, __first2);
N}
N
N
Ntemplate <class _InputIter1, class _InputIter2, class _BinaryPredicate>
Ninline pair<_InputIter1, _InputIter2>
Nmismatch (_InputIter1 __first1, _InputIter1 __last1,
N          _InputIter2 __first2, _BinaryPredicate __pred)
N{
N    _RWSTD_ASSERT_RANGE (__first1, __last1);
X    ((void)0);
N
N    while (__first1 != __last1 && __pred (*__first1, *__first2)) {
N        ++__first1;
N        ++__first2;
N    }
N    return pair<_InputIter1, _InputIter2> (__first1, __first2);
N}
N
N
N// 25.1.8 - Equal
Ntemplate <class _InputIter1, class _InputIter2>
Ninline bool
Nequal (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2)
N{
N    return __last1 == _STD::mismatch (__first1, __last1, __first2).first;
X    return __last1 == std::mismatch (__first1, __last1, __first2).first;
N}
N
N
Ntemplate <class _InputIter1, class _InputIter2, class _BinaryPredicate>
Ninline bool equal (_InputIter1 __first1, _InputIter1 __last1,
N                   _InputIter2 __first2, _BinaryPredicate __pred)
N{
N    return __last1 == _STD::mismatch (__first1, __last1,
X    return __last1 == std::mismatch (__first1, __last1,
N                                      __first2, __pred).first;
N}
N
N
N// 25.3.8 - Lexicographical Comparison
Ntemplate <class _InputIter1, class _InputIter2>
Nbool lexicographical_compare (_InputIter1 __first1, _InputIter1 __last1,
N                              _InputIter2 __first2, _InputIter2 __last2);
N
N
Ntemplate <class _InputIter1, class _InputIter2, class _Compare>
Nbool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
N                             _InputIter2 __first2, _InputIter2 __last2,
N                             _Compare __comp);
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#ifdef _RWSTD_COMPILE_INSTANTIATE
S#  include <rw/_algobase.cc>
N#endif
N
N
N#endif   // _RWSTD_ALGOBASE_H_INCLUDED
N
L 52 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\vector" 2
N#include <rw/_iterator.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_iterator.h" 1
N/***************************************************************************
N *
N * _iterator.h - Iterator declarations for the Standard Library
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id: _iterator.h 172106 2011-11-02 17:04:12Z statham $
N *
N ***************************************************************************
N *
N * Copyright (c) 1994
N * Hewlett-Packard Company
N *
N * Permission to use, copy, modify, distribute and sell this software
N * and its documentation for any purpose is hereby granted without fee,
N * provided that the above copyright notice appear in all copies and
N * that both that copyright notice and this permission notice appear
N * in supporting documentation.  Hewlett-Packard Company makes no
N * representations about the suitability of this software for any
N * purpose.  It is provided "as is" without express or implied warranty.
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_ITERATOR_H_INCLUDED
N#define _RWSTD_ITERATOR_H_INCLUDED
N
N#include <rw/_iterbase.h>
N#include <rw/_defs.h>
N
N#include _RWSTD_CSTDDEF
X#include <cstddef>
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N// Reverse iterator.     
N
N//
N//  Macros for reverse iterators to accomodate non-standard compilers
N//
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC 
N#  define _RWSTD_ITER_TEMPLATE template <class _Iterator>
N#  define _RWSTD_ITER_ID(i)    i <_Iterator>
N#  define _RWSTD_ITER_DIFF_TYPE(i, ignore)                             \
N          _TYPENAME iterator_traits<_Iterator>::difference_type
X#  define _RWSTD_ITER_DIFF_TYPE(i, ignore)                                       _TYPENAME iterator_traits<_Iterator>::difference_type
N#else
S#  define _RWSTD_ITER_TEMPLATE                                         \
S          template <class _Iterator, class _Category, class _TypeT,    \
S                    class _Reference, class _Pointer, class _Distance>
X#  define _RWSTD_ITER_TEMPLATE                                                   template <class _Iterator, class _Category, class _TypeT,                        class _Reference, class _Pointer, class _Distance>
S#  define _RWSTD_ITER_ID(i)                                            \
S          i <_Iterator, _Category, _TypeT, _Reference, _Pointer, _Distance>
X#  define _RWSTD_ITER_ID(i)                                                      i <_Iterator, _Category, _TypeT, _Reference, _Pointer, _Distance>
S#  define _RWSTD_ITER_DIFF_TYPE(ignore, distance) distance          
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC 
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC 
N
Ntemplate <class _Iterator>
Nclass reverse_iterator
N    : public iterator<_TYPENAME iterator_traits<_Iterator>::iterator_category, 
X    : public iterator<typename iterator_traits<_Iterator>::iterator_category, 
N                      _TYPENAME iterator_traits<_Iterator>::value_type, 
X                      typename iterator_traits<_Iterator>::value_type, 
N                      _TYPENAME iterator_traits<_Iterator>::difference_type,
X                      typename iterator_traits<_Iterator>::difference_type,
N                      _TYPENAME iterator_traits<_Iterator>::pointer, 
X                      typename iterator_traits<_Iterator>::pointer, 
N                      _TYPENAME iterator_traits<_Iterator>::reference>
X                      typename iterator_traits<_Iterator>::reference>
N{
N    typedef iterator_traits<_Iterator>  traits_type;
Npublic:
N    typedef _TYPENAME traits_type::difference_type difference_type;
X    typedef typename traits_type::difference_type difference_type;
N    typedef _TYPENAME traits_type::value_type value_type;
X    typedef typename traits_type::value_type value_type;
N    typedef _TYPENAME traits_type::pointer pointer;
X    typedef typename traits_type::pointer pointer;
N    typedef _TYPENAME traits_type::reference reference;
X    typedef typename traits_type::reference reference;
N
N#else   // if defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
S
Stemplate <class _Iterator, class _Category, class _TypeT,
S          class _Reference _RWSTD_COMPLEX_DEFAULT (_TypeT&), 
S          class _Pointer _RWSTD_COMPLEX_DEFAULT (_TypeT*), 
S          class _Distance _RWSTD_COMPLEX_DEFAULT (ptrdiff_t)>
Sclass reverse_iterator
S    : public iterator<_Category, _TypeT, _Distance, _Pointer, _Reference>
S
S{
Spublic:
S    typedef _Distance  difference_type;
S    typedef _TypeT     value_type;
S    typedef _Reference reference;
S    typedef _Pointer   pointer;
S
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N    typedef _Iterator iterator_type;
N
N    reverse_iterator () { }
N
N    _EXPLICIT reverse_iterator (iterator_type __rhs) : current (__rhs) { }
X    explicit reverse_iterator (iterator_type __rhs) : current (__rhs) { }
N 
N
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N#  ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC 
N
N      template <class _TypeU>
N      reverse_iterator (const reverse_iterator<_TypeU>& __rhs)
N          : current (__rhs.base ()) { }
N
N#  else   // if defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
S
S      template <class _Iterator2, class _Category2, class _TypeU,
S                class _Reference2, class _Pointer2, class _Distance2>
S      reverse_iterator (const reverse_iterator<_Iterator2, _Category2, _TypeU,
S                        _Reference2, _Pointer2, _Distance2>& __rhs)
S          : current (__rhs.base ()) { }
S
N#  endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC 
N#endif  // _RWSTD_NO_MEMBER_TEMPLATES
N
N
N    iterator_type base () const {
N        return current;
N    }
N
N    reference operator* () const {
N        iterator_type __tmp = base ();
N        return *--__tmp;
N    }
N
N    _RWSTD_OPERATOR_ARROW (pointer operator->() const);
X    pointer operator->() const { return & * *this; };
N
N    reverse_iterator& operator++ () {
N        return --current, *this;
N    }
N
N    reverse_iterator operator++ (int) {
N        reverse_iterator __tmp = *this;
N        ++*this;
N        return __tmp;
N    }
N
N    reverse_iterator& operator-- () {
N        return ++current, *this;
N    }
N
N    reverse_iterator operator-- (int) {
N        reverse_iterator __tmp = *this;
N        --*this;
N        return __tmp;
N    }
N
N    reverse_iterator& operator+= (difference_type __n) {
N        return current -= __n, *this;
N    }
N
N    reverse_iterator& operator-= (difference_type __n) {
N        return *this += -__n;
N    }
N
N    reverse_iterator operator+ (difference_type __n) const {
N        return reverse_iterator (*this) += __n;
N    }
N
N    reverse_iterator operator- (difference_type __n) const {
N        return reverse_iterator (*this) -= __n;
N    }
N
N    reference operator[] (difference_type __n) const {
N        return *(*this + __n);
N    }
N
Nprotected:
N
N    iterator_type current;
N};
N
N
N_RWSTD_ITER_TEMPLATE
Xtemplate <class _Iterator>
Ninline bool operator== (const _RWSTD_ITER_ID (reverse_iterator)& __x,
Xinline bool operator== (const reverse_iterator <_Iterator> & __x,
N                        const _RWSTD_ITER_ID (reverse_iterator)& __y)
X                        const reverse_iterator <_Iterator> & __y)
N{
N    return __x.base () == __y.base ();
N}
N
N
N_RWSTD_ITER_TEMPLATE
Xtemplate <class _Iterator>
Ninline bool operator< (const _RWSTD_ITER_ID (reverse_iterator)& __x,
Xinline bool operator< (const reverse_iterator <_Iterator> & __x,
N                       const _RWSTD_ITER_ID (reverse_iterator)& __y)
X                       const reverse_iterator <_Iterator> & __y)
N{
N    return __y.base() < __x.base();
N}
N
N
N_RWSTD_ITER_TEMPLATE
Xtemplate <class _Iterator>
Ninline bool operator!= (const _RWSTD_ITER_ID (reverse_iterator)& __x, 
Xinline bool operator!= (const reverse_iterator <_Iterator> & __x, 
N                        const _RWSTD_ITER_ID (reverse_iterator)& __y)
X                        const reverse_iterator <_Iterator> & __y)
N{
N    return !(__x == __y);
N}
N
N
N_RWSTD_ITER_TEMPLATE
Xtemplate <class _Iterator>
Ninline bool operator> (const _RWSTD_ITER_ID (reverse_iterator)& __x, 
Xinline bool operator> (const reverse_iterator <_Iterator> & __x, 
N                       const _RWSTD_ITER_ID (reverse_iterator)& __y)
X                       const reverse_iterator <_Iterator> & __y)
N{
N    return __y < __x;
N}
N
N
N_RWSTD_ITER_TEMPLATE
Xtemplate <class _Iterator>
Ninline bool operator<= (const _RWSTD_ITER_ID (reverse_iterator)& __x,
Xinline bool operator<= (const reverse_iterator <_Iterator> & __x,
N                        const _RWSTD_ITER_ID (reverse_iterator)& __y)
X                        const reverse_iterator <_Iterator> & __y)
N{
N    return !(__y < __x);
N}
N
N
N_RWSTD_ITER_TEMPLATE
Xtemplate <class _Iterator>
Ninline bool operator>= (const _RWSTD_ITER_ID (reverse_iterator)& __x, 
Xinline bool operator>= (const reverse_iterator <_Iterator> & __x, 
N                        const _RWSTD_ITER_ID (reverse_iterator)& __y)
X                        const reverse_iterator <_Iterator> & __y)
N{
N    return !(__x < __y);
N}
N
N
N_RWSTD_ITER_TEMPLATE
Xtemplate <class _Iterator>
Ninline _RWSTD_ITER_DIFF_TYPE (_Iterator, _Distance)
Xinline typename iterator_traits<_Iterator> ::difference_type
Noperator- (const _RWSTD_ITER_ID (reverse_iterator)& __x, 
Xoperator- (const reverse_iterator <_Iterator> & __x, 
N           const _RWSTD_ITER_ID (reverse_iterator)& __y)
X           const reverse_iterator <_Iterator> & __y)
N{
N    return __y.base () - __x.base ();
N}
N
N
N_RWSTD_ITER_TEMPLATE
Xtemplate <class _Iterator>
Ninline _RWSTD_ITER_ID (reverse_iterator)
Xinline reverse_iterator <_Iterator>
Noperator+ (_RWSTD_ITER_DIFF_TYPE (_Iterator, _Distance) __n, 
Xoperator+ (typename iterator_traits<_Iterator> ::difference_type __n, 
N           const _RWSTD_ITER_ID (reverse_iterator)&     __x)
X           const reverse_iterator <_Iterator> &     __x)
N{
N    return __x + __n;
N}
N
N#undef _RWSTD_ITER_DIFF_TYPE
N
N#ifdef _RWSTD_NO_CLASS_PARTIAL_SPEC
S
S_RWSTD_NAMESPACE_END   // std
S
S_RWSTD_NAMESPACE_BEGIN (__rw)
S
S// Reverse bidirectional iterator.       
S// This is needed to get around non-standard compilers that insist
S// on instantiating all members of a class whether they're used 
S// or not.
S
Stemplate <class _Iterator, class _Category, class _TypeT, 
S          class _Reference _RWSTD_COMPLEX_DEFAULT (_TypeT&), 
S          class _Pointer _RWSTD_COMPLEX_DEFAULT (_TypeT*), 
S          class _Distance _RWSTD_COMPLEX_DEFAULT (ptrdiff_t) >
Sclass __reverse_bi_iterator
S    : public _STD::iterator<_Category, _TypeT, _Distance, _Pointer, _Reference>
S{
Spublic:
S    typedef _Distance  difference_type;
S    typedef _TypeT     value_type;
S    typedef _Reference reference;
S    typedef _Pointer   pointer;
S    typedef _Iterator  iterator_type;
S
S    __reverse_bi_iterator () { }
S
S    _EXPLICIT __reverse_bi_iterator (const iterator_type &__rhs) 
S        : current (__rhs) { }
S
S
S#ifndef _RWSTD_NO_MEMBER_TEMPLATES
S#  ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC 
S
S      template <class _TypeU>
S      __reverse_bi_iterator (const __reverse_bi_iterator<_TypeU>& __rhs)
S          : current (__rhs.base ()) { }
S
S#  else   // if defined (_RWSTD_NO_CLASS_PARTIAL_SPEC )
S
S      template <class _Iterator2, class _Category2, class _TypeU,
S                class _Reference2, class _Pointer2, class _Distance2>
S      __reverse_bi_iterator (const __reverse_bi_iterator<_Iterator2,
S                                                         _Category2,
S                                                         _TypeU,
S                                                         _Reference2,
S                                                         _Pointer2,
S                                                         _Distance2>& __rhs)
S          : current (__rhs.base ()) { }
S#  endif
S#endif // _RWSTD_NO_MEMBER_TEMPLATES
S
S
S    iterator_type base () const {
S        return current;
S    }
S
S    reference operator* () const {
S        iterator_type __tmp = base ();
S        return *--__tmp;
S    }
S
S    _RWSTD_OPERATOR_ARROW (pointer operator->() const);
S
S    __reverse_bi_iterator& operator++ () {
S        return --current, *this;
S    }
S
S    __reverse_bi_iterator  operator++ (int) {
S        __reverse_bi_iterator __tmp (*this);
S        ++*this;
S        return __tmp;
S    }
S
S    __reverse_bi_iterator& operator-- () {
S        return ++current, *this;
S    }
S
S    __reverse_bi_iterator operator-- (int) {
S        __reverse_bi_iterator __tmp (*this);
S        --*this;
S        return __tmp;
S    }
S
Sprotected:
S
S    iterator_type current;
S};
S
S
S_RWSTD_ITER_TEMPLATE
Sinline bool operator== (const _RWSTD_ITER_ID (__reverse_bi_iterator)& __x, 
S                        const _RWSTD_ITER_ID (__reverse_bi_iterator)& __y)
S{
S    return __x.base () == __y.base ();
S}
S
S
S_RWSTD_ITER_TEMPLATE
Sinline bool operator!= (const _RWSTD_ITER_ID (__reverse_bi_iterator)& __x,
S                        const _RWSTD_ITER_ID (__reverse_bi_iterator)& __y)
S{
S    return !(__x == __y);
S}
S
S#undef _RWSTD_ITER_TEMPLATE
S#undef _RWSTD_ITER_ID
S
S_RWSTD_NAMESPACE_END   // __rw
S
S_RWSTD_NAMESPACE_BEGIN (std)
S
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N#  define _RWSTD_INSERT_ITERATOR_BASE(ignore)       \
N          iterator<output_iterator_tag, void, void, void, void>
X#  define _RWSTD_INSERT_ITERATOR_BASE(ignore)                 iterator<output_iterator_tag, void, void, void, void>
N#else
S   // necessary to allow __iterator_category, __value_type, etc. to work
S#  define _RWSTD_INSERT_ITERATOR_BASE(cont)         \
S          iterator<output_iterator_tag,             \
S                   _TYPENAME cont::value_type,      \
S                   _TYPENAME cont::difference_type, \
S                   _TYPENAME cont::pointer,         \
S                   _TYPENAME cont::reference>
X#  define _RWSTD_INSERT_ITERATOR_BASE(cont)                   iterator<output_iterator_tag,                                _TYPENAME cont::value_type,                         _TYPENAME cont::difference_type,                    _TYPENAME cont::pointer,                            _TYPENAME cont::reference>
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
Ntemplate <class _Container>
Nclass back_insert_iterator: public _RWSTD_INSERT_ITERATOR_BASE (_Container)
Xclass back_insert_iterator: public iterator<output_iterator_tag, void, void, void, void>
N{
Npublic:
N    typedef _Container container_type;
N
N    _EXPLICIT back_insert_iterator (container_type& __rhs)
X    explicit back_insert_iterator (container_type& __rhs)
N        : container (&__rhs) { }
N
N    back_insert_iterator&
N    operator= (_TYPENAME container_type::const_reference __x) {
X    operator= (typename container_type::const_reference __x) {
N        return container->push_back (__x), *this;
N    }
N
N    back_insert_iterator& operator*  () {
N        return *this;
N    }
N
N    back_insert_iterator& operator++ () {
N        return *this;
N    }
N
N    back_insert_iterator operator++ (int) {
N        return *this;
N    }
N
Nprotected:
N
N    container_type* container;
N};
N
N
Ntemplate <class _Container>
Ninline back_insert_iterator<_Container> back_inserter (_Container& __x)
N{
N    return back_insert_iterator<_Container>(__x);
N}
N
N
Ntemplate <class _Container>
Nclass front_insert_iterator: public _RWSTD_INSERT_ITERATOR_BASE (_Container)
Xclass front_insert_iterator: public iterator<output_iterator_tag, void, void, void, void>
N{
Npublic:
N    typedef _Container container_type;
N
N    _EXPLICIT front_insert_iterator (container_type& __rhs)
X    explicit front_insert_iterator (container_type& __rhs)
N        : container (&__rhs) { }
N
N    front_insert_iterator&
N    operator= (_TYPENAME container_type::const_reference __x) { 
X    operator= (typename container_type::const_reference __x) { 
N        return container->push_front (__x), *this;
N    }
N
N    front_insert_iterator& operator* () {
N        return *this;
N    }
N
N    front_insert_iterator& operator++ () {
N        return *this;
N    }
N
N    front_insert_iterator operator++ (int) {
N        return *this;
N    }
N
Nprotected:
N
N    container_type* container;
N};
N
N
Ntemplate <class _Container>
Ninline front_insert_iterator<_Container> front_inserter (_Container& __x)
N{
N    return front_insert_iterator<_Container>(__x);
N}
N
N
Ntemplate <class _Container>
Nclass insert_iterator: public _RWSTD_INSERT_ITERATOR_BASE (_Container)
Xclass insert_iterator: public iterator<output_iterator_tag, void, void, void, void>
N{
Npublic:
N    typedef _Container container_type;
N
N    insert_iterator (container_type                    &__x,
N                     _TYPENAME container_type::iterator __it)
X                     typename container_type::iterator __it)
N      : iter (__it), container (&__x) { }
N
N    insert_iterator&
N    operator= (_TYPENAME container_type::const_reference __x) { 
X    operator= (typename container_type::const_reference __x) { 
N        iter = container->insert (iter, __x);
N        return ++iter, *this;
N    }
N
N    insert_iterator& operator* () {
N        return *this;
N    }
N
N    insert_iterator& operator++ () {
N        return *this;
N    }
N
N    insert_iterator& operator++ (int) {
N        return *this;
N    }
N
Nprotected:
N
N    _TYPENAME container_type::iterator iter;
X    typename container_type::iterator iter;
N    container_type*                    container;
N};
N
N
Ntemplate <class _Container, class _Iterator>
Ninline insert_iterator<_Container> inserter (_Container& __x, _Iterator __it)
N{
N    typedef _TYPENAME _Container::iterator _Iter;
X    typedef typename _Container::iterator _Iter;
N
N    return insert_iterator<_Container> (__x, _Iter (__it));
N}
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N#endif   // _RWSTD_ITERATOR_H_INCLUDED
N
L 53 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\vector" 2
N#include <rw/_defs.h>
N#include <rw/_dispatch.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_dispatch.h" 1
N/***************************************************************************
N *
N * _dispatch.h - Functions used for method selection in containers
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id: _dispatch.h 172106 2011-11-02 17:04:12Z statham $
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_DISPATCH_H_INCLUDED
N#define _RWSTD_DISPATCH_H_INCLUDED
N
N#include <rw/_defs.h>
N
N
Nstruct _RW_is_integer {};
Nstruct _RW_is_not_integer {};
N
Ntemplate <class _TypeT>
Nstruct _RWdispatch {
N  typedef _RW_is_not_integer _RWtype;
N};
N
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
Nstruct _RWdispatch<int> {
N  typedef _RW_is_integer _RWtype;
N};
N
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
N   struct _RWdispatch<unsigned int> {
N	typedef _RW_is_integer _RWtype;
N};
N
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
N   struct _RWdispatch<long> {
N	typedef _RW_is_integer _RWtype;
N};
N
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
N   struct _RWdispatch<unsigned long> {
N	typedef _RW_is_integer _RWtype;
N};
N
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
N   struct _RWdispatch<short> {
N	typedef _RW_is_integer _RWtype;
N};
N
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
N   struct _RWdispatch<unsigned short> {
N	typedef _RW_is_integer _RWtype;
N};
N
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
N   struct _RWdispatch<char> {
N	typedef _RW_is_integer _RWtype;
N};
N
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
N   struct _RWdispatch<unsigned char> {
N	typedef _RW_is_integer _RWtype;
N};
N
N#ifndef _RWSTD_NO_BOOL
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
N   struct _RWdispatch<bool> {
N	typedef _RW_is_integer _RWtype;
N};
N#endif
N
N#ifndef _RWSTD_NO_NATIVE_WCHAR_T
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
N   struct _RWdispatch<wchar_t> {
N	typedef _RW_is_integer _RWtype;
N};
N#endif
N
N#endif   // _RWSTD_DISPATCH_H_INCLUDED
N
L 55 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\vector" 2
N#include <rw/_error.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_error.h" 1
N/**************************************************************************
N *
N * Definition of class except_msg_string
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id: _error.h 172106 2011-11-02 17:04:12Z statham $
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N ***************************************************************************/
N
N#ifndef _RWSTD_ERROR_H_INCLUDED
N#define _RWSTD_ERROR_H_INCLUDED
N
N#ifndef _RWSTD_NO_INCLUDES
N   // prevent inclusion if compiling a .rc file with MSVC
N#  include <rw/_defs.h>
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// throws an exception identified by first argument, optional arguments
N// (if any) used to format the exception object's what() string
Nvoid _RWSTD_EXPORT __rw_throw (int, ...);
Xvoid  __rw_throw (int, ...);
N
Nextern "C" {
N
N// throws an exception identified by first argument with the second
N// argument containing the exception object's what() string, which
N// if non-zero and the first argument <= _RWSTD_ERROR_BAD_CAST, is
N// dynamically allocated and must be delete[]'d unless the function
N// returns or calls the original throw_proc
N// may be assigned to a user-defined handler (e.g., to prevent
N// the library from throwing exceptions or to implement logging)
Nextern void _RWSTD_EXPORT (*__rw_throw_proc)(int, char*);
Xextern void  (*__rw_throw_proc)(int, char*);
N
N}   // extern "C"
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N#endif   // _RWSTD_NO_INCLUDES
N
N
N#ifndef _RWSTD_ERROR_CATALOG
N   // name of catalog optionally followed by a colon and a set number
N   // catalog looked up according to rules of catopen(3)
N   // may be customized at lib build time (pathname okay)
N#  define _RWSTD_ERROR_CATALOG "rwstderr:1"
N#endif   // _RWSTD_ERROR_CATALOG
N
N#ifndef _RWSTD_ERROR_ENVVAR
N   // environment variable name - overrides _RWSTD_ERROR_CATALOG
N   // may be customized at lib build time
N#  define _RWSTD_ERROR_ENVVAR "RWSTDERR"
N#endif   // _RWSTD_ERROR_ENVVAR
N
N#ifndef _RWSTD_ERROR_FIRST
N   // id of first message - 1, may be customized at lib build time
N#  define _RWSTD_ERROR_FIRST 0
N#endif   // _RWSTD_ERROR_FIRST
N
N
N// these must be macros to accomodate MSVC's resource compiler, with values
N// expected to be consecutive starting with _RWSTD_ERROR_FIRST + 1
N
N// #  define _RWSTD_ERROR_EXCEPTION                   (_RWSTD_ERROR_FIRST +  1)
N// #  define _RWSTD_ERROR_BAD_EXCEPTION               (_RWSTD_ERROR_FIRST +  2)
N// #  define _RWSTD_ERROR_BAD_ALLOC                   (_RWSTD_ERROR_FIRST +  3)
N#  define _RWSTD_ERROR_BAD_CAST                    (_RWSTD_ERROR_FIRST +  4)
N#  define _RWSTD_ERROR_LOGIC_ERROR                 (_RWSTD_ERROR_FIRST +  5)
N#  define _RWSTD_ERROR_DOMAIN_ERROR                (_RWSTD_ERROR_FIRST +  6)
N#  define _RWSTD_ERROR_INVALID_ARGUMENT            (_RWSTD_ERROR_FIRST +  7)
N#  define _RWSTD_ERROR_LENGTH_ERROR                (_RWSTD_ERROR_FIRST +  8)
N#  define _RWSTD_ERROR_OUT_OF_RANGE                (_RWSTD_ERROR_FIRST +  9)
N#  define _RWSTD_ERROR_RUNTIME_ERROR               (_RWSTD_ERROR_FIRST + 10)
N#  define _RWSTD_ERROR_RANGE_ERROR                 (_RWSTD_ERROR_FIRST + 11)
N#  define _RWSTD_ERROR_OVERFLOW_ERROR              (_RWSTD_ERROR_FIRST + 12)
N#  define _RWSTD_ERROR_UNDERFLOW_ERROR             (_RWSTD_ERROR_FIRST + 13)
N
N#  define _RWSTD_ERROR_FAILBIT_SET                 (_RWSTD_ERROR_FIRST + 14)
N#  define _RWSTD_ERROR_BADBIT_SET                  (_RWSTD_ERROR_FIRST + 15)
N#  define _RWSTD_ERROR_EOFBIT_SET                  (_RWSTD_ERROR_FIRST + 16)
N#  define _RWSTD_ERROR_IOSTATE_BIT_SET             (_RWSTD_ERROR_FIRST + 17)
N
N#  define _RWSTD_ERROR_FACET_NOT_FOUND             (_RWSTD_ERROR_FIRST + 18)
N#  define _RWSTD_ERROR_LOCALE_BAD_NAME             (_RWSTD_ERROR_FIRST + 20)
N#  define _RWSTD_ERROR_LOCALE_ERROR_NAME           (_RWSTD_ERROR_FIRST + 21)
N#  define _RWSTD_ERROR_CODECVT                     (_RWSTD_ERROR_FIRST + 22)
N
N#  define _RWSTD_ERROR_BAD_POINTER                 (_RWSTD_ERROR_FIRST + 23)
N
N#  define _RWSTD_ERROR_STRINGS                          \
N          "%s: unspecified error",                      \
N          "%s: exception",                              \
N          "%s: unexpected exception",                   \
N          "%s: bad_alloc: out of memory",               \
N          "%s: bad cast",                               \
N          "%s: logic error",                            \
N          "%s: out of memory",                          \
N          "%s: bad cast",                               \
N          "%s: length error: %u > %u",                  \
N          "%s: argument value %u out of range [0, %u)", \
N          "%s: runtime error",                          \
N          "%s: range error: invalid range [%d, %d)",    \
N          "%s: overflow error",                         \
N          "%s: underflow error",                        \
N          "%s: stream object has set ios::failbit",     \
N          "%s: stream object has set ios::badbit",      \
N          "%s: stream object has set ios::eofbit",      \
N          "%s: stream object has set %s",               \
N          "%s: facet %u not found in \"%s\" locale",    \
N          "%s: bad locale name: \"%s\"",                \
N          "%s: failed to construct locale name",        \
N          "%s: conversion failed",                      \
N          "%s: invalid pointer %p"
X#  define _RWSTD_ERROR_STRINGS                                    "%s: unspecified error",                                "%s: exception",                                        "%s: unexpected exception",                             "%s: bad_alloc: out of memory",                         "%s: bad cast",                                         "%s: logic error",                                      "%s: out of memory",                                    "%s: bad cast",                                         "%s: length error: %u > %u",                            "%s: argument value %u out of range [0, %u)",           "%s: runtime error",                                    "%s: range error: invalid range [%d, %d)",              "%s: overflow error",                                   "%s: underflow error",                                  "%s: stream object has set ios::failbit",               "%s: stream object has set ios::badbit",                "%s: stream object has set ios::eofbit",                "%s: stream object has set %s",                         "%s: facet %u not found in \"%s\" locale",              "%s: bad locale name: \"%s\"",                          "%s: failed to construct locale name",                  "%s: conversion failed",                                "%s: invalid pointer %p"
N
N#define _RWSTD_ERROR_EXCEPTION     "exception"
N#define _RWSTD_ERROR_BAD_EXCEPTION "unexpected exception"
N#define _RWSTD_ERROR_BAD_ALLOC     "bad_alloc: out of memory"
N
N
N#endif   // _RWSTD_ERROR_H_INCLUDED
N
L 56 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\vector" 2
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
Ntemplate <class _TypeT,
N          class _Allocator _RWSTD_COMPLEX_DEFAULT(allocator<_TypeT>) >
X          class _Allocator = allocator<_TypeT> >
Nclass vector : private _Allocator
N{
Npublic:
N
N    typedef _TypeT                                     value_type;
N    typedef _Allocator                                 allocator_type;
N    typedef _TYPENAME allocator_type::size_type        size_type;
X    typedef typename allocator_type::size_type        size_type;
N    typedef _TYPENAME allocator_type::difference_type  difference_type;
X    typedef typename allocator_type::difference_type  difference_type;
N    typedef _TYPENAME allocator_type::reference        reference;
X    typedef typename allocator_type::reference        reference;
N    typedef _TYPENAME allocator_type::const_reference  const_reference;
X    typedef typename allocator_type::const_reference  const_reference;
N    typedef _TYPENAME allocator_type::pointer          pointer;
X    typedef typename allocator_type::pointer          pointer;
N    typedef _TYPENAME allocator_type::const_pointer    const_pointer;
X    typedef typename allocator_type::const_pointer    const_pointer;
N
N
N#ifndef _RWSTD_NO_DEBUG_ITER
S
S    typedef _RW::__rw_debug_iter <vector, pointer, pointer>  iterator;
S    
S    typedef _RW::__rw_debug_iter <vector, const_pointer, pointer>
S        const_iterator;
S
S    iterator _C_make_iter (pointer __ptr) {
S        return iterator (*this, __ptr);
S    }
S
S    const_iterator _C_make_iter (pointer __ptr) const {
S        return const_iterator (*this, __ptr);
S    }
S
N#else   // if defined (_RWSTD_NO_DEBUG_ITER)
N
N    typedef pointer         iterator;
N    typedef const_pointer   const_iterator;
N
N    iterator _C_make_iter (pointer __ptr) {
N        return __ptr;
N    }
N
N    const_iterator _C_make_iter (const_pointer __ptr) const {
N        return __ptr;
N    }
N
N#endif   // _RWSTD_NO_DEBUG_ITER
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC 
N    typedef _STD::reverse_iterator<const_iterator> const_reverse_iterator;
X    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
N    typedef _STD::reverse_iterator<iterator>       reverse_iterator;
X    typedef std::reverse_iterator<iterator>       reverse_iterator;
N#else
S    typedef _STD::reverse_iterator<const_iterator, 
S      random_access_iterator_tag, value_type, 
S      const_reference, const_pointer, difference_type>
S      const_reverse_iterator;
S    typedef _STD::reverse_iterator<iterator, 
S      random_access_iterator_tag, value_type,
S      reference, pointer, difference_type>
S      reverse_iterator;
N#endif
N
Nprotected:
N    typedef _RWSTD_ALLOC_TYPE (_Allocator, value_type) _C_value_alloc_type;
X    typedef _Allocator _C_value_alloc_type;
N    pointer            _C_start;
N    pointer            _C_finish;
N    pointer            _C_end_of_storage;
N
N    void _C_insert_aux (iterator, const_reference);
N    
N    void _C_insert_aux (iterator, size_type, const_reference);
N    
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N
N    template<class _InputIter>
N    void _C_insert_aux (iterator __position, _InputIter __first,
N                        _InputIter __last, _RW_is_not_integer) {
N        _C_insert_aux2 (__position, __first, __last);
N    }
N
N    template<class _InputIter>
N    void _C_insert_aux (iterator __position, _InputIter __first,
N                        _InputIter __last, _RW_is_integer) {
N        _C_insert_aux (__position, (size_type)__first, __last);
N    }
N    
N    template<class _InputIter>
N    void _C_insert_aux2 (iterator __position, _InputIter __first,
N                         _InputIter __last);
N
N    template <class _InputIter>
N    void _C_insert_interval_dispatch (iterator __position,
N                                      _InputIter __first, 
N                                      _InputIter __last,
N                                      forward_iterator_tag) {
N        typedef _TYPENAME _RWdispatch<_InputIter>::_RWtype _RWtype;
X        typedef typename _RWdispatch<_InputIter>::_RWtype _RWtype;
N        _C_insert_aux(__position, __first, __last, _RWtype());
N    }
N    
N    template <class _InputIter>
N    void _C_insert_interval_dispatch (iterator __position,
N                                      _InputIter __first, 
N                                      _InputIter __last,
N                                      input_iterator_tag) { 
N        while(__first != __last) { 
N            __position = insert (__position,*__first); 
N            ++__position;
N            ++__first;
N        }
N    }
N
N#else
S    void _C_insert_aux2 (iterator, const_iterator, const_iterator);
N#endif
N
N    void _C_destroy (iterator __start, iterator __finish) {
N        for ( ; __start != __finish; ++__start)
N            _RWSTD_VALUE_ALLOC (_C_value_alloc_type, destroy (&*__start));
X            allocator_type::destroy (& *__start);
N    }
N    
N    // 
N    //  Allocate buffers and fill with __n values
N    //
N    void _C_initn(size_type __n, const_reference __value) {
N        size_t __initial_capacity = 
N            max (__n, (size_t)_RW::__rw_new_capacity(0,this));
X            max (__n, (size_t)__rw::__rw_new_capacity(0,this));
N
N        _C_start = _RWSTD_VALUE_ALLOC(_C_value_alloc_type,
N                                      allocate(__initial_capacity,0));
X        _C_start = allocator_type::allocate(__initial_capacity,0);
N        _TRY {
X         {
N            uninitialized_fill_n(begin(), __n, __value,
N                                 _RWSTD_VALUE_ALLOC_CAST (*this));
X                                 static_cast< allocator_type& >(*this));
N        }
N        _CATCH (...) {
X        while (0) {
N            _RWSTD_VALUE_ALLOC(_C_value_alloc_type, deallocate(_C_start,__n));
X            allocator_type::deallocate(_C_start,__n);
N            _RETHROW;
X            ((void)0);
N        }
N        _C_finish = _C_start + __n;
N        _C_end_of_storage = _C_start + __initial_capacity;
N    } 
N
N
Npublic:
N
N    _EXPLICIT vector (const _Allocator& __alloc = allocator_type ())
X    explicit vector (const _Allocator& __alloc = allocator_type ())
N        : allocator_type (__alloc), _C_start (0), _C_finish (0),
N          _C_end_of_storage (0){ }
N
N    _EXPLICIT
X    explicit
N    vector (size_type __n, const_reference __value = value_type (),
N            const _Allocator& __alloc = allocator_type ())
N        : allocator_type(__alloc), _C_start(0), _C_finish(0),
N          _C_end_of_storage (0) {
N        _C_initn (size_type (__n), __value);
N    }
N
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N    
N    template<class _InputIter>
N    void _C_init_aux (_InputIter __first, _InputIter __last,
N                     _RW_is_not_integer) {
N        if (__is_input_iterator (_RWSTD_ITERATOR_CATEGORY (_InputIter,
N                                                           __first))) {
X        if (__is_input_iterator (typename std::iterator_traits< _InputIter > ::iterator_category ())) {
N            copy(__first, __last, back_inserter(*this));
N        }
N        else {
N            size_type __n = _DISTANCE (__first, __last, size_type);
X            size_type __n = std::distance (__first, __last);
N            size_t __initial_capacity = 
N                max (__n, (size_t)_RW::__rw_new_capacity(0,this));
X                max (__n, (size_t)__rw::__rw_new_capacity(0,this));
N            _C_start = _RWSTD_VALUE_ALLOC(_C_value_alloc_type,
N                                          allocate(__initial_capacity,0));
X            _C_start = allocator_type::allocate(__initial_capacity,0);
N            
N            _TRY {
X             {
N                uninitialized_copy(__first, __last, _C_start,
N                                   _RWSTD_VALUE_ALLOC_CAST (*this));
X                                   static_cast< allocator_type& >(*this));
N            }
N            _CATCH (...) {
X            while (0) {
N                _RWSTD_VALUE_ALLOC(_C_value_alloc_type,
N                                   deallocate(_C_start,__n));
X                allocator_type::deallocate(_C_start,__n);
N                _RETHROW;
X                ((void)0);
N            }
N            _C_finish = _C_start + __n;
N            _C_end_of_storage = _C_start + __initial_capacity;
N        }
N    }
N
N    template<class _InputIter>
N    void _C_init_aux (_InputIter __first, _InputIter __last,
N                      _RW_is_integer) {
N        _C_initn((size_type)__first,__last);
N    }
N
N    template<class _InputIter>
N    vector (_InputIter __first, _InputIter __last,
N            const _Allocator& __alloc = allocator_type ())
N      : allocator_type(__alloc), _C_start(0), _C_finish(0),
N        _C_end_of_storage(0) {
N        typedef _TYPENAME _RWdispatch<_InputIter>::_RWtype _RWtype;
X        typedef typename _RWdispatch<_InputIter>::_RWtype _RWtype;
N        _C_init_aux(__first, __last, _RWtype());
N    }
N    
N#else  // defined _RWSTD_NO_MEMBER_TEMPLATES
S
S    vector (const_iterator __first, const_iterator __last,
S            const _Allocator& __alloc = allocator_type ())
S      : allocator_type(__alloc), _C_start(0), _C_finish(0),
S        _C_end_of_storage(0) {
S        size_type __n = _DISTANCE (__first, __last, size_type);
S        size_t __initial_capacity = 
S            max (__n, (size_t)_RW::__rw_new_capacity(0,this));
S        _C_start = _RWSTD_VALUE_ALLOC(_C_value_alloc_type,
S                                      allocate(__initial_capacity,0));
S        
S        _TRY {
S            uninitialized_copy(__first, __last, _C_start,
S                                 _RWSTD_VALUE_ALLOC_CAST (*this));
S        }
S        _CATCH (...) {
S            _RWSTD_VALUE_ALLOC(_C_value_alloc_type, deallocate(_C_start,__n));
S            _RETHROW;
S        }
S        _C_finish = _C_start + __n;
S        _C_end_of_storage = _C_start + __initial_capacity;
S    }
S    
N#endif // _RWSTD_NO_MEMBER_TEMPLATES
N
N    vector (const vector &__x)
N        : allocator_type (__x.get_allocator ()), _C_start(0), _C_finish(0),
N          _C_end_of_storage(0) {
N
N        size_t __initial_capacity = 
N            max (__x.size(), (size_t)_RW::__rw_new_capacity(0,this));
X            max (__x.size(), (size_t)__rw::__rw_new_capacity(0,this));
N        _C_start = _RWSTD_VALUE_ALLOC(_C_value_alloc_type,
N                                      allocate(__initial_capacity,0));
X        _C_start = allocator_type::allocate(__initial_capacity,0);
N        _TRY {
X         {
N            uninitialized_copy(__x.begin(), __x.end(), begin(),
N                                 _RWSTD_VALUE_ALLOC_CAST (*this));
X                                 static_cast< allocator_type& >(*this));
N        }
N        _CATCH (...) {
X        while (0) {
N            _RWSTD_VALUE_ALLOC(_C_value_alloc_type,
N                               deallocate(_C_start,__x.size()));
X            allocator_type::deallocate(_C_start,__x . size());
N            _RETHROW;
X            ((void)0);
N        }
N        _C_finish = _C_start + __x.size();
N        _C_end_of_storage = _C_start + __initial_capacity;
N    }
N    
N    
N    ~vector () { 
N        _C_destroy(begin (), end ()); 
N        _RWSTD_VALUE_ALLOC(_C_value_alloc_type, deallocate(_C_start,
N                                              _C_end_of_storage - _C_start));
X        allocator_type::deallocate(_C_start, _C_end_of_storage - _C_start);
N    }
N    
N    vector& operator= (const vector &__x);
N    
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N    template<class _InputIter>
N    void assign (_InputIter __first, _InputIter __last) {
N        erase(begin(), end());
N        typedef _TYPENAME _RWdispatch<_InputIter>::_RWtype _RWtype;
X        typedef typename _RWdispatch<_InputIter>::_RWtype _RWtype;
N        _C_insert_aux(begin(), __first, __last, _RWtype());
N    }
N    
N    void assign (size_type __n, const_reference __t) {
N        erase(begin(), end()); insert(begin(), __n, __t);
N    }
N#else
S    void assign (const_iterator __first, const_iterator __last) {
S        erase(begin(), end()); insert(begin(), __first, __last);
S    }
S    //
S    // Assign n copies of t to this vector.
S    //
S    void assign (size_type __n, const_reference __t) {
S        erase(begin(), end()); insert(begin(), __n, __t);
S    }
S
N#endif // _RWSTD_NO_MEMBER_TEMPLATES
N
N    allocator_type get_allocator() const {
N        return *this;
N    }
N    
N    //
N    // Iterators.
N    //
N    iterator       begin ()       {
N        return _C_make_iter (_C_start);
N    }
N
N    const_iterator begin () const {
N        return _C_make_iter (_C_start);
N    }
N
N    iterator       end ()         {
N        return _C_make_iter (_C_finish);
N    }
N
N    const_iterator end ()   const {
N        return _C_make_iter (_C_finish);
N    }
N    
N    reverse_iterator rbegin () { 
N        reverse_iterator __tmp(end());
N        return __tmp;
N    }
N    
N    const_reverse_iterator rbegin () const { 
N        const_reverse_iterator __tmp(end());
N        return __tmp;
N    }
N    
N    reverse_iterator rend () { 
N        reverse_iterator __tmp(begin());
N        return __tmp;
N    }
N    
N    const_reverse_iterator rend () const { 
N        const_reverse_iterator __tmp(begin());
N        return __tmp;
N    }
N
N    size_type size ()     const {
N        return size_type(end() - begin());
N    }
N
N    size_type max_size () const {
N        return _RWSTD_VALUE_ALLOC(_C_value_alloc_type, max_size());
X        return allocator_type::max_size();
N    }
N    
N    void resize (size_type __new_size, value_type __value = value_type ()) {
N        if (__new_size > size())
N            insert(end(), __new_size - size(), __value);
N        else if (__new_size < size())
N            erase(begin() + __new_size, end());
N    }
N
N    size_type capacity () const {
N        return _C_end_of_storage - _C_start;
N    }
N    
N    bool      empty ()    const {
N        return begin() == end();
N    }
N    
N    void reserve (size_type __n) {
N        _RWSTD_REQUIRES (__n <= max_size (),
N                         (_RWSTD_ERROR_LENGTH_ERROR,
N                          _RWSTD_FUNC ("vector::reserve(size_type)"),
N                          __n, max_size ()));
X        (__n <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, max_size ());
N
N        if (capacity() < __n) {
N            size_t __new_capacity = 
N                max (__n, (size_t)_RW::__rw_new_capacity(size(),this));
X                max (__n, (size_t)__rw::__rw_new_capacity(size(),this));
N            pointer __tmp =
N                _RWSTD_VALUE_ALLOC(_C_value_alloc_type,
N                                   allocate(__new_capacity,_C_start));
X                allocator_type::allocate(__new_capacity,_C_start);
N
N            _TRY {
X             {
N                uninitialized_copy(begin(), end(), _C_make_iter (__tmp),
N                                 _RWSTD_VALUE_ALLOC_CAST (*this));
X                                 static_cast< allocator_type& >(*this));
N            }
N            _CATCH (...) {
X            while (0) {
N                _RWSTD_VALUE_ALLOC(_C_value_alloc_type, deallocate(__tmp,__n));
X                allocator_type::deallocate(__tmp,__n);
N                _RETHROW;
X                ((void)0);
N            }
N            _C_destroy(begin (), end ());
N            _RWSTD_VALUE_ALLOC(_C_value_alloc_type, 
N                deallocate(_C_start, _C_end_of_storage - _C_start));
X            allocator_type::deallocate(_C_start, _C_end_of_storage - _C_start);
N            _C_finish = __tmp + size();
N            _C_start = __tmp;
N            _C_end_of_storage = _C_start + __new_capacity;
N        }
N    }
N
N    //
N    // Element access.
N    //
N    reference       operator[] (size_type __n) {
N
N#ifdef _RWSTD_BOUNDS_CHECKING
S
S        _RWSTD_REQUIRES (__n < size (),
S                         (_RWSTD_ERROR_OUT_OF_RANGE,
S                          _RWSTD_FUNC ("vector::operator[](size_type)"),
S                          __n, size ()));
S
N#endif   // _RWSTD_BOUNDS_CHECKING
N
N        return *(begin() + __n);
N
N    }
N  
N    const_reference operator[] (size_type __n) const {
N
N#ifdef _RWSTD_BOUNDS_CHECKING
S
S        _RWSTD_REQUIRES (__n < size (),
S                         (_RWSTD_ERROR_OUT_OF_RANGE,
S                          _RWSTD_FUNC ("vector::operator[](size_type) const"),
S                          __n, size ()));
S
N#endif   // _RWSTD_BOUNDS_CHECKING
N
N        return *(begin() + __n);
N    }
N  
N    reference at (size_type __n) { 
N        _RWSTD_REQUIRES (__n < size (),
N                         (_RWSTD_ERROR_OUT_OF_RANGE,
N                          _RWSTD_FUNC ("vector::at (size_type)"),
N                          __n, size ()));
X        (__n < size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __n, size ());
N        return *(begin() + __n); 
N    }
N    
N    const_reference at (size_type __n)  const  { 
N        _RWSTD_REQUIRES (__n < size (),
N                         (_RWSTD_ERROR_OUT_OF_RANGE,
N                          _RWSTD_FUNC ("vector::at(size_type) const"),
N                          __n, size ()));
X        (__n < size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __n, size ());
N        return *(begin() + __n); 
N    }
N    
N    reference front () {
N        return *begin();
N    }
N    
N    const_reference front () const {
N        return *begin();
N    }
N    
N    reference back () {
N        return *(end() - 1);
N    }
N    
N    const_reference back () const {
N        return *(end() - 1);
N    }
N
N    //
N    // Modifiers.
N    //
N    void push_back (const_reference __x) {
N        if (_C_finish != _C_end_of_storage) {
N            ++_C_finish;
N            _TRY {
X             {
N                _RWSTD_VALUE_ALLOC (_C_value_alloc_type,
N                                    construct (_C_finish - difference_type (1),
N                                               __x));
X                allocator_type::construct (_C_finish - difference_type (1), __x);
N            }
N            _CATCH (...) {
X            while (0) {
N                --_C_finish;
N                _RETHROW;
X                ((void)0);
N            }
N        }
N        else
N            _C_insert_aux(end(), __x);
N    }
N    
N    void pop_back()
N    {
N        _RWSTD_VALUE_ALLOC(_C_value_alloc_type, destroy(_C_finish-1));
X        allocator_type::destroy(_C_finish-1);
N        --_C_finish; 
N    }
N
N    //
N    // Insert x at __position.
N    //
N    iterator insert (iterator __position, const_reference __x) {
N        size_type __n = __position - begin();
N        if (_C_finish != _C_end_of_storage && __position == end()) {
N            ++_C_finish;
N            _TRY {
X             {
N                _RWSTD_VALUE_ALLOC(_C_value_alloc_type,
N                                   construct(_C_finish - 1, __x));
X                allocator_type::construct(_C_finish - 1, __x);
N            }
N            _CATCH (...) {
X            while (0) {
N                --_C_finish;
N                _RETHROW;
X                ((void)0);
N            }
N        }
N        else
N            _C_insert_aux(__position, __x);
N        return begin() + __n;
N    }
N
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N
N    template <class _InputIter>
N    void insert (iterator __pos, _InputIter __first, _InputIter __last) {
N        insert (__pos, __first, __last, _RWSTD_DISPATCH (_InputIter));
X        insert (__pos, __first, __last, ((__rw::__rw_select<numeric_limits< _InputIter > ::is_integer> *)0));
N    }
N    
N    template <class _InputIter>
N    void insert (iterator __pos, _InputIter __first, _InputIter __last,
N                 _RWSTD_DISPATCH_INT (false)) {
X                 const __rw::__rw_select < false > *) {
N        // unnamed arg is used for overload resolution
N        // _RWSTD_COMPILE_ASSERT (sizeof (*__first));
N        _C_insert_interval_dispatch  (__pos, __first, __last,
N                                      _RWSTD_ITERATOR_CATEGORY (_InputIter,
N                                                                __first));
X                                      typename std::iterator_traits< _InputIter > ::iterator_category ());
N    }
N
N    void insert (iterator __pos, size_type __n, const_reference __val,
N                 _RWSTD_DISPATCH_INT (true)) {
X                 const __rw::__rw_select < true > *) {
N        // unnamed arg is used for overload resolution
N        _C_insert_aux (__pos, __n, __val);
N    }
N
N    void insert (iterator __position, size_type __n, const_reference __value) {
N        _C_insert_aux(__position,__n,__value);
N    }
N    
N#else
S
S    void insert (iterator __position, size_type __n, const_reference __x) {
S        _C_insert_aux(__position,__n,__x);
S    }
S    
S    void insert (iterator __position, const_iterator __first,
S                 const_iterator __last) {
S        _C_insert_aux2(__position, __first, __last);
S    }
S    
N#endif // _RWSTD_NO_MEMBER_TEMPLATES
N
N    iterator erase (iterator __position) {
N        if (!empty ()) { 
N            if (__position + 1 != end()) 
N                copy(__position + 1, end(), __position);
N            _RWSTD_VALUE_ALLOC(_C_value_alloc_type, destroy(_C_finish - 1));
X            allocator_type::destroy(_C_finish - 1);
N            --_C_finish;
N        }
N        return __position;
N    }
N
N    iterator erase (iterator __first, iterator __last) {
N        if (!empty ()) {
N            iterator __i = copy (__last, end(), __first);
N            iterator __tmp = end ();
N            _C_destroy(__i, __tmp);
N            _C_finish -= (__last - __first);
N        }
N        return __first;
N    }
N
N    void swap (vector& __x) {
N        if((_C_value_alloc_type)*this==(_C_value_alloc_type)__x) {
N            _STD::swap (_C_start, __x._C_start);
X            std::swap (_C_start, __x._C_start);
N            _STD::swap (_C_finish, __x._C_finish);
X            std::swap (_C_finish, __x._C_finish);
N            _STD::swap (_C_end_of_storage, __x._C_end_of_storage);
X            std::swap (_C_end_of_storage, __x._C_end_of_storage);
N        }
N        else {
N            vector __v = *this;
N            *this = __x;
N            __x=__v;
N        } 
N    }
N    
N    void clear () {
N        erase (begin (), end ());
N    }
N
N};
N
Ntemplate <class _TypeT, class _Allocator>
Ninline bool operator== (const vector<_TypeT,_Allocator>& __x,
N                        const vector<_TypeT,_Allocator>& __y)
N{
N    return __x.size() == __y.size()
N        && equal(__x.begin(), __x.end(), __y.begin());
N}
N
Ntemplate <class _TypeT, class _Allocator>
Ninline bool operator< (const vector<_TypeT,_Allocator>& __x,
N                       const vector<_TypeT,_Allocator>& __y)
N{
N    return lexicographical_compare(__x.begin(), __x.end(),
N                                   __y.begin(), __y.end());
N}
N
Ntemplate <class _TypeT, class _Allocator>
Ninline bool operator!= (const vector<_TypeT,_Allocator>& __x,
N                        const vector<_TypeT,_Allocator>& __y)
N{
N    return !(__x == __y);
N}
N
Ntemplate <class _TypeT, class _Allocator>
Ninline bool operator> (const vector<_TypeT,_Allocator>& __x,
N                       const vector<_TypeT,_Allocator>& __y)
N{
N    return __y < __x;
N}
N
Ntemplate <class _TypeT, class _Allocator>
Ninline bool operator>= (const vector<_TypeT,_Allocator>& __x,
N                        const vector<_TypeT,_Allocator>& __y)
N{
N    return !(__x < __y);
N}
N
Ntemplate <class _TypeT, class _Allocator>
Ninline bool operator<= (const vector<_TypeT,_Allocator>& __x,
N                        const vector<_TypeT,_Allocator>& __y)
N{
N    return !(__y <  __x);
N}
N
N#ifndef _RWSTD_NO_PART_SPEC_OVERLOAD
N
Ntemplate <class _TypeT, class _Allocator>
Ninline void swap(vector<_TypeT,_Allocator>& __a, vector<_TypeT,_Allocator>& __b)
N{
N    __a.swap(__b);
N}
N
N#endif   // _RWSTD_NO_PART_SPEC_OVERLOAD
N
N
N#ifndef _RWSTD_NO_VECTOR_BOOL
N
N#ifndef _RWSTD_NO_BOOL
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N  template <class _Allocator>
N
N#else   // if defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
S
S     // use a macro to mutate _Allocator into allocator<bool>
S# define _Allocator allocator<bool>
S
S_RWSTD_SPECIALIZED_CLASS
S
N#endif  // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
Nclass _RWSTD_EXPORT vector<bool, _Allocator > : private _Allocator
Xclass  vector<bool, _Allocator > : private _Allocator
N{
N    typedef _RWSTD_REBIND(_Allocator, unsigned int)       _C_value_alloc_type;
X    typedef typename _Allocator::template rebind < unsigned int > ::other       _C_value_alloc_type;
N
N    typedef vector                                        _C_self;
Npublic:
N
N    typedef _Allocator                                    allocator_type;
N    typedef bool                                          value_type;
N
N    typedef _TYPENAME allocator_type::size_type           size_type;
X    typedef typename allocator_type::size_type           size_type;
N    typedef _TYPENAME allocator_type::difference_type     difference_type;
X    typedef typename allocator_type::difference_type     difference_type;
N    typedef _TYPENAME _C_value_alloc_type::pointer        pointer;
X    typedef typename _C_value_alloc_type::pointer        pointer;
N    typedef _TYPENAME _C_value_alloc_type::const_pointer  const_pointer;
X    typedef typename _C_value_alloc_type::const_pointer  const_pointer;
N
N    class iterator;
N    class const_iterator;
N
N    class reference {
N        friend class iterator;
N        friend class const_iterator;
N
N    protected:
N
N        unsigned int* _C_p;
N        unsigned int _C_mask;
N        reference (unsigned int* __x, unsigned int __y)
N            : _C_p (__x), _C_mask (__y) { }
N    public:
N
N        reference () : _C_p(0), _C_mask(0) {}
N
N        operator bool () const {
N            return !!(*_C_p & _C_mask);
N        }
N
N        reference& operator= (bool __x) {
N            if (__x)      
N                *_C_p |= _C_mask;
N            else
N                *_C_p &= ~_C_mask;
N            return *this;
N        }
N
N        reference& operator= (const reference& __x) {
N            return *this = bool(__x);
N        }
N
N#ifndef _RWSTD_NO_EXT_VECTOR_BOOL_REF_OPS
N
N      bool operator== (const reference& __x) const {
N          return bool(*this) == bool(__x);
N      }
N
N      bool operator< (const reference& __x) const {
N#ifndef _MSC_VER
N          return bool(*this) < bool(__x);
N#else
S          return int(*this) < int(__x);
N#endif
N      }
N
N        bool operator!= (const reference& __x) const {
N            return !(*this == __x);
N        }
N
N        bool operator> (const reference& __x) const {
N            return  __x < *this;
N        }
N
N        bool operator>= (const reference& __x) const {
N            return !(*this < __x);
N        }
N
N        bool operator<= (const reference& __x) const {
N            return !(*this > __x);
N        }
N
N#endif // _RWSTD_NO_EXT_VECTOR_BOOL_REF_OPS
N
N        void flip () {
N            *_C_p ^= _C_mask;
N        }
N    };
N    
N    typedef bool const_reference;
N
N    // hacks working around bogus g++ 2.95.2 warnings coming out of
N    // iterators below as well as what's probably an MSVC 6.0 bug
N    typedef reference       _C_ref;
N    typedef const_reference _C_const_ref;
N    typedef difference_type _C_diff_t;
N
N    class _C_iter {
N        friend class iterator;
N        friend class const_iterator;
N
N    protected:
N
N#if defined (__GNUG__) && __GNUG__ == 2 && __GNUG_MINOR__ < 96
X#if 0L && __GNUG__ == 2 && __GNUG_MINOR__ < 96
S    public:
S#elif defined (_MSC_VER) && _MSC_VER <= 1300
X#elif 0L && _MSC_VER <= 1300
S        friend class vector<bool, _Allocator>;
N#else
N        friend class vector;
N#endif
N        unsigned int* _C_p;
N        unsigned int  _C_offset;
N
N        _C_iter (unsigned int* __x = 0, unsigned int __y = 0)
N            : _C_p (__x), _C_offset (__y) { }
N
N        void operator++ () {
N            if (_C_offset++ == _RWSTD_WORD_BIT - 1) {
X            if (_C_offset++ == (int(8*sizeof(unsigned int))) - 1) {
N                _C_offset = 0; 
N                ++_C_p;
N            }
N        }
N
N        void operator-- () {
N            if (_C_offset-- == 0) {
N                _C_offset = _RWSTD_WORD_BIT - 1; 
X                _C_offset = (int(8*sizeof(unsigned int))) - 1; 
N                --_C_p;
N            }
N        }
N
N        void operator+= (difference_type __i) {
N            difference_type __n = __i + _C_offset;
N            _C_p += __n / _RWSTD_WORD_BIT;
X            _C_p += __n / (int(8*sizeof(unsigned int)));
N            __n = __n % _RWSTD_WORD_BIT;
X            __n = __n % (int(8*sizeof(unsigned int)));
N            if (__n < 0) {
N                _C_offset = _RWSTD_STATIC_CAST (unsigned int,
N                                                __n + _RWSTD_WORD_BIT);
X                _C_offset = static_cast< unsigned int >(__n + (int(8*sizeof(unsigned int))));
N                --_C_p;
N            }
N            else
N                _C_offset = _RWSTD_STATIC_CAST (unsigned int,__n);
X                _C_offset = static_cast< unsigned int >(__n);
N        }
N
N    public:
N
N        bool operator== (const _C_iter& __x) const {
N            return _C_p == __x._C_p && _C_offset == __x._C_offset;
N        }
N
N        bool operator< (const _C_iter& __x) const {
N            return _C_p < __x._C_p ||
N                (_C_p == __x._C_p && _C_offset < __x._C_offset);
N        }
N
N        bool operator!= (const _C_iter& __x) const {
N            return !(*this == __x);
N        }
N
N        bool operator> (const _C_iter& __x) const {
N            return __x < *this;
N        }
N
N        bool operator>= (const _C_iter& __x) const {
N            return !(*this < __x);
N        }
N
N        bool operator<= (const _C_iter& __x) const {
N            return !(*this > __x);
N        }
N    };
N      
N    class iterator
N        : public _C_iter,
N          public _STD::iterator<random_access_iterator_tag,
X          public std::iterator<random_access_iterator_tag,
N                                value_type, _C_diff_t,
N                                pointer, _C_ref> {
N    public:
N
N        // bring names used in declarations below into scope
N        // (dependent base members not visible without qualification)
N        typedef _C_ref    reference;
N        typedef _C_diff_t difference_type;
N
N        iterator (unsigned int *__x = 0, unsigned int __y = 0)
N            : _C_iter (__x, __y) { }
N
N        reference operator* () const { 
N            typedef reference _Reference;
N            return _Reference (this->_C_p, 1U << this->_C_offset); 
N        }
N
N        iterator& operator++ () {
N            return _C_iter::operator++(), *this;
N        }
N
N        iterator operator++ (int) {
N            iterator __tmp = *this;
N            ++*this;
N            return __tmp;
N        }
N
N        iterator& operator-- () {
N            return _C_iter::operator--(), *this;
N        }
N
N        iterator operator-- (int) {
N            iterator __tmp = *this;
N            --*this;
N            return __tmp;
N        }
N
N        iterator& operator+= (difference_type __i) {
N            return _C_iter::operator+= (__i), *this;
N        }
N
N        iterator& operator-= (difference_type __i) {
N            *this += -__i;
N            return *this;
N        }
N
N        iterator operator+ (difference_type __i) const {
N            iterator __tmp = *this;
N            return __tmp += __i;
N        }
N
N        iterator operator- (difference_type __i) const {
N            iterator __tmp = *this;
N            return __tmp -= __i;
N        }
N
N        difference_type operator- (iterator __x) const {
N            return   _RWSTD_WORD_BIT * (this->_C_p - __x._C_p)
X            return   (int(8*sizeof(unsigned int))) * (this->_C_p - __x._C_p)
N                   + this->_C_offset - __x._C_offset;
N        }
N
N        reference operator[] (difference_type __i) {
N            return *(*this + __i);
N        }
N    };
N
N    class const_iterator
N        : public _C_iter,
N          public _STD::iterator<random_access_iterator_tag,
X          public std::iterator<random_access_iterator_tag,
N                                value_type, _C_diff_t,
N                                const_pointer, _C_const_ref> {
N    public:
N
N        // bring names used in declarations below into scope
N        // (dependent base members not visible without qualification)
N        typedef _C_const_ref const_reference;
N        typedef _C_diff_t    difference_type;
N
N        const_iterator (unsigned int *__x = 0, unsigned int __y = 0)
N            : _C_iter (__x, __y) { }
N
N        const_iterator (const _C_iter &__x)
N            : _C_iter (__x._C_p, __x._C_offset) { }
N
N        const_reference operator* () const {
N            return _C_ref (this->_C_p, 1U << this->_C_offset);
N        }
N
N        const_iterator& operator++ () {
N            return _C_iter::operator++(), *this;
N        }
N
N        const_iterator operator++ (int) {
N            const_iterator __tmp = *this;
N            ++*this;
N            return __tmp;
N        }
N
N        const_iterator& operator-- () {
N            return _C_iter::operator--(), *this;
N        }
N
N        const_iterator operator-- (int) {
N            const_iterator __tmp = *this;
N            --*this;
N            return __tmp;
N        }
N
N        const_iterator& operator+= (difference_type __i) {
N            return _C_iter::operator+= (__i), *this;
N        }
N
N        const_iterator& operator-= (difference_type __i) {
N            return *this += -__i;
N        }
N
N        const_iterator
N        operator+ (difference_type __i) const {
N            return const_iterator (*this) += __i;
N        }
N
N        const_iterator operator- (difference_type __i) const {
N            return const_iterator (*this) -= __i;
N        }
N
N        difference_type operator- (const_iterator __x) const {
N            return   _RWSTD_WORD_BIT * (this->_C_p - __x._C_p)
X            return   (int(8*sizeof(unsigned int))) * (this->_C_p - __x._C_p)
N                   + this->_C_offset - __x._C_offset;
N        }
N
N        const_reference operator[] (difference_type __i) { 
N            return *(*this + __i); 
N        }
N    };
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC 
N
N    typedef _STD::reverse_iterator<const_iterator> const_reverse_iterator;
X    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
N    typedef _STD::reverse_iterator<iterator>       reverse_iterator;
X    typedef std::reverse_iterator<iterator>       reverse_iterator;
N
N#else
S
S    typedef _STD::reverse_iterator<const_iterator, 
S        random_access_iterator_tag, value_type, 
S        const_reference, const_pointer, difference_type>
S    const_reverse_iterator;
S
S    typedef _STD::reverse_iterator<iterator, 
S        random_access_iterator_tag, value_type,
S        reference, pointer, difference_type>
S    reverse_iterator;
S
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC 
N
N  private:
N    //
N    // These private functions are replicas of generic algorithms.
N    //  We provide them here to avoid putting instantiations of 
N    //  the generic algorithms into an archive or shared library.
N    //  This gives you full flexibilty in deciding where you want
N    //  to put particular instantiations of the generic 
N    //  algorithms.
N    //
N  
N    void _C_fill (iterator __first, iterator __last, const bool& __value) {
N        while (__first != __last) *__first++ = __value;
N    }
N
N    void _C_fill_n (iterator __first, size_type __n, const bool& __value) {
N        while (__n-- > 0) *__first++ = __value;
N    }
N
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N
N    template <class _Iterator>
N    iterator _C_copy (_Iterator __first, _Iterator __last, iterator __res) {
N        while (__first != __last)
N            *__res++ = *__first++;
N        return __res;
N    }
N
N    template <class _Iterator>
N    iterator
N    _C_copy_backward (_Iterator __first, _Iterator __last, iterator __res) {
N        while (__first != __last) *--__res = *--__last;
N        return __res;
N    }
N
N#else
S    iterator
S    _C_copy (const_iterator __first, const_iterator __last, iterator __res) {
S        while (__first != __last)
S            *__res++ = *__first++;
S        return __res;
S    }
S
S    iterator _C_copy (const bool* __first, const bool* __last, iterator __res) {
S        while (__first != __last)
S            *__res++ = *__first++;
S        return __res;
S    }
S
S    iterator _C_copy_backward (const_iterator __first, const_iterator __last,
S                               iterator __res) {
S        while (__first != __last)
S            *--__res = *--__last;
S        return __res;
S    }
S
S    iterator
S    _C_copy_backward (const bool* __first, const bool* __last, iterator __res) {
S        while (__first != __last)
S            *--__res = *--__last;
S        return __res;
S    }
S
N#endif
N
Nprotected:
N
N    iterator       _C_start;
N    iterator       _C_finish;
N    unsigned int * _C_end_of_storage;
N
N    unsigned int* _C_bit_alloc (size_type __n) {
N        return _C_value_alloc_type(*this).
N            allocate ((__n + _RWSTD_WORD_BIT - 1)/_RWSTD_WORD_BIT,
X            allocate ((__n + (int(8*sizeof(unsigned int))) - 1)/(int(8*sizeof(unsigned int))),
N                      pointer(_C_start._C_p));
N    }
N
N    void _C_init (size_type __n) {
N        unsigned int* __q = _C_bit_alloc(__n);
N        _C_end_of_storage = __q + (__n + _RWSTD_WORD_BIT - 1)/_RWSTD_WORD_BIT;
X        _C_end_of_storage = __q + (__n + (int(8*sizeof(unsigned int))) - 1)/(int(8*sizeof(unsigned int)));
N        _C_start = iterator(__q, 0);
N        _C_finish = _C_start + __n;
N    }
N
N    void _C_insert_aux (iterator, bool);
N
Npublic:
N
N    vector (const _Allocator&  __alloc = allocator_type ())
N      : allocator_type (__alloc), _C_start(iterator()), _C_finish(iterator()), 
N        _C_end_of_storage(0) { }
N
N    _EXPLICIT vector (size_type __n, bool __value = bool(), 
X    explicit vector (size_type __n, bool __value = bool(), 
N       const _Allocator&  __alloc = allocator_type ())
N      : allocator_type (__alloc), _C_end_of_storage(0) {
N      _C_init(__n); 
N      unsigned int * __first = _C_start._C_p;
N      size_type __m = (__n + _RWSTD_WORD_BIT - 1)/_RWSTD_WORD_BIT;
X      size_type __m = (__n + (int(8*sizeof(unsigned int))) - 1)/(int(8*sizeof(unsigned int)));
N      while (__m-- > 0) *__first++ = __value ? ~0 : 0;
N    }
N
N    vector (const _C_self &__x)
N        : allocator_type (__x.get_allocator ()), _C_end_of_storage (0) {
N        _C_init (__x.size ()); 
N        _C_copy (__x.begin (), __x.end (), _C_start);
N    }
N
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N    template<class _InputIter>
N    vector  (_InputIter __first, _InputIter __last)
N      : _C_end_of_storage(0)
N    {
N      size_type __n = _DISTANCE (__first, __last, size_type);
X      size_type __n = std::distance (__first, __last);
N      _C_init(__n); 
N      _C_copy(__first, __last, _C_start);
N    }
N#else
S    vector (const_iterator __first, const_iterator __last)
S      : _C_end_of_storage(0)
S    {
S      size_type __n = _DISTANCE (__first, __last, size_type);
S      _C_init(__n);
S      _C_copy(__first, __last, _C_start);
S    }
S    vector (const bool* __first, const bool* __last)
S      : _C_end_of_storage(0)
S    {
S      size_type __n = _DISTANCE (__first, __last, size_type);
S      _C_init(__n);
S      _C_copy(__first, __last, _C_start);
S    }
N#endif
N  
N    ~vector () {
N      _C_value_alloc_type(*this).deallocate(_C_start._C_p,  
N        _C_end_of_storage - _C_start._C_p); 
N    }
N    _C_self& operator= (const _C_self& __x)
N    {
N      if (&__x == this) return *this;
N      if (__x.size() > capacity())
N      {
N        _C_value_alloc_type(*this).deallocate(_C_start._C_p,
N          _C_end_of_storage - _C_start._C_p); 
N        _C_init(__x.size());
N      }
N      _C_copy(__x.begin(), __x.end(), begin());
N      _C_finish = begin() + __x.size();
N      return *this;
N    }
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N    template<class _InputIter>
N    void assign (_InputIter __first, _InputIter __last)
N    { erase(begin(), end()); insert(begin(), __first, __last); }
N#else
S    void assign (const_iterator __first, const_iterator __last)
S    { erase(begin(), end()); insert(begin(), __first, __last); }
N#endif
N
N    void assign (size_type __n, const bool& __t = bool())
N    { 
N        erase(begin(), end()); insert(begin(), __n, __t);  
N    }
N
N    allocator_type get_allocator() const
N    {
N      return *this;
N    }
N
N    //
N    // iterators
N    //
N    iterator       begin ()       { return _C_start; }
N    const_iterator begin () const 
N    { return const_iterator(_C_start._C_p,_C_start._C_offset); }
N    iterator       end   ()       { return _C_finish; }
N    const_iterator end   () const 
N    { return const_iterator(_C_finish._C_p,_C_finish._C_offset); }
N
N    reverse_iterator       rbegin () { return reverse_iterator(end()); }
N    const_reverse_iterator rbegin () const
N    { 
N      return const_reverse_iterator(end()); 
N    }
N    reverse_iterator       rend () { return reverse_iterator(begin()); }
N    const_reverse_iterator rend () const
N    { 
N      return const_reverse_iterator(begin()); 
N    }
N
N    //
N    // capacity
N    //
N    size_type size     () const { return size_type(end() - begin());  }
N    size_type max_size () const {
N        return _C_value_alloc_type(*this).max_size();
N    }
N    void resize (size_type __new_size, bool __c = false);
N    size_type capacity () const
N    {
N      return size_type(const_iterator(_C_end_of_storage, 0) - begin());
N    }
N    bool empty () const { return begin() == end(); }
N    void reserve (size_type __n)
N    {
N        _RWSTD_REQUIRES (__n <= max_size (),
N                         (_RWSTD_ERROR_LENGTH_ERROR,
N                          _RWSTD_FUNC ("vector<bool>::reserve (size_type)"),
N                          __n, max_size ()));
X        (__n <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, max_size ());
N
N      if (capacity() < __n)
N      {
N        unsigned int* __q = _C_bit_alloc(__n);
N        _C_finish = _C_copy(begin(), end(), iterator(__q, 0));
N        _C_value_alloc_type(*this).deallocate(_C_start._C_p,
N                                             _C_end_of_storage - _C_start._C_p);
N        _C_start = iterator(__q, 0);
N        _C_end_of_storage = __q + (__n + _RWSTD_WORD_BIT - 1)/_RWSTD_WORD_BIT;
X        _C_end_of_storage = __q + (__n + (int(8*sizeof(unsigned int))) - 1)/(int(8*sizeof(unsigned int)));
N      }
N    }
N
N    //
N    // element access
N    //
N    reference       operator[] (size_type __n)       
N    { 
N#ifdef _RWSTD_BOUNDS_CHECKING
S
S        _RWSTD_REQUIRES (__n < size (),
S                         (_RWSTD_ERROR_LENGTH_ERROR,
S                          _RWSTD_FUNC ("vector<bool>::[](size_type)"),
S                          __n, size ()));
S
N#endif   // _RWSTD_BOUNDS_CHECKING
N
N      return *(begin() + __n); 
N    }
N    const_reference operator[] (size_type __n) const 
N    { 
N#ifdef _RWSTD_BOUNDS_CHECKING
S
S        _RWSTD_REQUIRES (__n < size (),
S                         (_RWSTD_ERROR_LENGTH_ERROR,
S                          _RWSTD_FUNC ("vector<bool>::[](size_type)"),
S                          __n, size ()));
S
N#endif   // _RWSTD_BOUNDS_CHECKING
N
N      return *(begin() + __n); 
N    }
N    reference       at (size_type __n)               
N    { 
N        _RWSTD_REQUIRES (__n < size (),
N                         (_RWSTD_ERROR_LENGTH_ERROR,
N                          _RWSTD_FUNC ("vector<bool>::at(size_type)"),
N                          __n, size ()));
X        (__n < size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, size ());
N      return *(begin() + __n); 
N    }
N    const_reference at (size_type __n)   const 
N    {
N        _RWSTD_REQUIRES (__n < size (),
N                         (_RWSTD_ERROR_LENGTH_ERROR,
N                          _RWSTD_FUNC ("vector<bool>::at(size_type) const"),
N                          __n, size ()));
X        (__n < size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, size ());
N
N      return *(begin() + __n); 
N    }
N    reference       front ()       { return *begin();     }
N    const_reference front () const { return *begin();     }
N    reference       back  ()       { return *(end() - 1); }
N    const_reference back  () const { return *(end() - 1); }
N    
N    //
N    // modifiers
N    //
N    void push_back (const bool& __x)
N    {
N        if (_C_finish._C_p != _C_end_of_storage) {
N            ++_C_finish;
N            *(_C_finish-1) = __x;
N        }
N        else
N            _C_insert_aux(end(), __x);
N    }
N    void pop_back () { --_C_finish; }
N
N    iterator insert (iterator __position, const bool& __x = bool())
N    {
N      size_type __n = __position - begin();
N      if (_C_finish._C_p != _C_end_of_storage && __position == end()) {
N          ++_C_finish;
N          *(_C_finish-1) = __x;
N      }
N      else
N        _C_insert_aux(__position, __x);
N      return begin() + __n;
N    }
N    void insert (iterator __position, size_type __n, const bool& __x);
N
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N    template<class _InputIter>
N    void insert (iterator __position, _InputIter __first,
N                 _InputIter __last);
N#else
S    void insert (iterator __position, const_iterator __first, 
S                 const_iterator __last);
N#endif
N
N    iterator erase (iterator __position)
N    {
N      if (!(__position + 1 == end()))
N        _C_copy(__position + 1, end(), __position);
N      --_C_finish;
N      return __position;
N    }
N    iterator erase(iterator __first, iterator __last)
N    {
N      _C_finish = _C_copy(__last, end(), __first);
N      return __first;
N    }
N    void swap (_C_self& __x)
N    {
N      if((_C_value_alloc_type)*this == (_C_value_alloc_type)__x)
N      {
N        _STD::swap (_C_start,          __x._C_start);
X        std::swap (_C_start,          __x._C_start);
N        _STD::swap (_C_finish,         __x._C_finish);
X        std::swap (_C_finish,         __x._C_finish);
N        _STD::swap (_C_end_of_storage, __x._C_end_of_storage);
X        std::swap (_C_end_of_storage, __x._C_end_of_storage);
N      }
N      else
N      {
N        _C_self _x = *this;
N        *this = __x;
N        __x=_x;
N      } 
N    }
N    static void swap(reference __x, reference __y);
N    void flip ();
N    void clear()
N    {
N      erase(begin(),end());
N    }
N
N  };
N  
N#ifndef _RWSTD_NO_FUNC_PARTIAL_SPEC
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N  template <class _Allocator>
N#endif
N  inline bool operator== (const vector<bool,_Allocator >& __x, 
N                          const vector<bool,_Allocator >& __y)
N  {
N    if (__x.size() == __y.size())
N    {
N        _TYPENAME vector<bool,_Allocator >::const_iterator
X        typename vector<bool,_Allocator >::const_iterator
N        first1 = __x.begin(), 
N        last1  = __x.end(),
N        first2 = __y.begin();
N            
N      while (first1 != last1 && *first1 == *first2)
N      {
N        ++first1;
N        ++first2;
N      }
N      return first1 == last1;
N    }
N    return false;
N  }
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N  template <class _Allocator>
N#endif
N  inline bool operator< (const vector<bool,_Allocator >& __x, 
N                         const vector<bool,_Allocator >& __y)
N  {
N    _TYPENAME vector<bool,_Allocator >::const_iterator
X    typename vector<bool,_Allocator >::const_iterator
N        first1 = __x.begin(), 
N        last1  = __x.end(),
N        first2 = __y.begin(),
N        last2  = __y.end();
N
N    while (first1 != last1 && first2 != last2)
N    {
N      if ((int)*first1 < (int)*first2)     return true;
N      if ((int)*first2++ < (int)*first1++) return false;
N    }
N    return first1 == last1 && first2 != last2;
N  }
N#else
S
S_RWSTD_SPECIALIZED_FUNCTION
S  inline bool operator== (const vector<bool,allocator<bool> >& __x, 
S                          const vector<bool,allocator<bool> >& __y)
S  {
S    if (__x.size() == __y.size())
S    {
S        vector<bool,allocator<bool> >::const_iterator
S        first1 = __x.begin(), 
S        last1  = __x.end(),
S        first2 = __y.begin();
S            
S      while (first1 != last1 && *first1 == *first2)
S      {
S        ++first1;
S        ++first2;
S      }
S      return first1 == last1;
S    }
S    return false;
S  }
S
S_RWSTD_SPECIALIZED_FUNCTION
S  inline bool operator< (const vector<bool,allocator<bool> >& __x, 
S                         const vector<bool,allocator<bool> >& __y)
S  {
S    vector<bool,allocator<bool> >::const_iterator
S        first1 = __x.begin(), 
S        last1  = __x.end(),
S        first2 = __y.begin(),
S        last2  = __y.end();
S
S    while (first1 != last1 && first2 != last2)
S    {
S      if ((int)*first1 < (int)*first2)     return true;
S      if ((int)*first2++ < (int)*first1++) return false;
S    }
S    return first1 == last1 && first2 != last2;
S  }
N#endif
N
N#ifndef _RWSTD_NO_FUNC_PARTIAL_SPEC
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N  template <class _Allocator>
N#endif
N  inline bool operator!= (const vector<bool,_Allocator >& __x, 
N                          const vector<bool,_Allocator >& __y)
N  {
N    return !(__x == __y);
N  }
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N  template <class _Allocator>
N#endif
N  inline bool operator> (const vector<bool,_Allocator >& __x, 
N                         const vector<bool,_Allocator >& __y)
N  {
N    return __y < __x;
N  }
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N  template <class _Allocator>
N#endif
N  inline bool operator>= (const vector<bool,_Allocator >& __x, 
N                          const vector<bool,_Allocator >& __y)
N  {
N    return !(__x < __y);
N  }
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N  template <class _Allocator>
N#endif
N  inline bool operator<= (const vector<bool,_Allocator >& __x, 
N                          const vector<bool,_Allocator >& __y)
N  {
N    return !(__y <  __x);
N  }
N
N#ifndef _RWSTD_NO_PART_SPEC_OVERLOAD
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N  template <class _Allocator>
N#endif
N  inline void swap(vector<bool,_Allocator >& __a, vector<bool,_Allocator >& __b)
N  {
N    __a.swap(__b);
N  }
N#endif
N
N#else //_RWSTD_NO_FUNC_PART_SPEC
S
S_RWSTD_SPECIALIZED_FUNCTION
S  inline bool operator!= (const vector<bool,allocator<bool> >& __x, 
S                          const vector<bool,allocator<bool> >& __y)
S  {
S    return !(__x == __y);
S  }
S
S_RWSTD_SPECIALIZED_FUNCTION
S  inline bool operator> (const vector<bool,allocator<bool> >& __x, 
S                         const vector<bool,allocator<bool> >& __y)
S  {
S    return __y < __x;
S  }
S
S_RWSTD_SPECIALIZED_FUNCTION
S  inline bool operator>= (const vector<bool,allocator<bool> >& __x, 
S                          const vector<bool,allocator<bool> >& __y)
S  {
S    return !(__x < __y);
S  }
S
S_RWSTD_SPECIALIZED_FUNCTION
S  inline bool operator<= (const vector<bool,allocator<bool> >& __x, 
S                          const vector<bool,allocator<bool> >& __y)
S  {
S    return !(__y <  __x);
S  }
S
S_RWSTD_SPECIALIZED_FUNCTION
Sinline void swap (vector<bool, allocator<bool> >& __a,
S                  vector<bool, allocator<bool> >& __b)
S  {
S    __a.swap(__b);
S  }
S
N#endif
N
N#undef _Allocator 
N
N#endif   // _RWSTD_NO_BOOL
N
N#endif   // _RWSTD_NO_VECTOR_BOOL
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N#if defined (_RWSTD_COMPILE_INSTANTIATE)
X#if 0L
S#  include <vector.cc>
N#endif
N
N
N#ifndef _RWSTD_NO_STL_SPECIALIZATION
S#include "vector_spec.h"
N#endif   // _RWSTD_NO_STL_SPECIALIZATION
N
N
N#endif   // _RWSTD_VECTOR_INCLUDED
N
L 5 ".\misc\inc\List.h" 2
N
Ntemplate <class T, typename K>
N	class List_Node {
N		public:
N			T *rlink, *llink;
N		  K key;
N		  //virtual bool TestWith (K &);
N	};
N
Ntemplate <class Object>
N  class ArrayList {
N	  public:
N	  	ArrayList ();
N	    bool add (Object &);
N		  bool add (Object *);
N		  int32_t add (Object &, uint32_t index);
N		template <typename Array>
N		  void addAll (Array &);
N		template <typename Array>
N		  void addAll (Array *);
N    template <typename A>
N		  A &add(A &);
N		template <typename A>
N		  A &add (A *);
N	    Object &remove (Object &);
N	    Object &remove (Object *);
N		  Object &remove (uint32_t index);
N
N		template <typename A>
N		  A &addAll (A &);
N		template <typename A>
N		  A &addAll (A *);
N		
N	    Object &get (uint32_t index);
N	    Object &getLast ();
N      Object &getFirst ();
N		  Object &removeLast ();
N      Object &removeFirst ();
N      Object &getNext (Object *);
N		  Object &getNext (Object &);
N	    uint32_t size ();
N		  bool isEmpty ();
N	  private:
N		  Object *First, *Last;
N	    uint32_t Elements;
N  };
N
Ntemplate <class Object>
NArrayList<Object>::ArrayList()
N{
N}
Ntemplate <class Object>
Nbool ArrayList<Object>::add(Object &item)
N{
N	this->Elements++;
N		Object *i,*j;
N		if (!this->First) {
N			this->First = &item;
N			this->Last = &item;
N			item.rlink = (T *)0;
N			item.llink = (T *)0;
N			return true;
N		}
N		i = this->First;
N		j = (Object *)0;
N		while (i != (Object *)0) {
N			if (i->key > item.key) {
N				j = i;
N				i = i->rlink;
N				continue;
N			}
N			if (i->llink) {
N				i->llink->rlink = &item;
N				item.rlink = i;
N				item.llink = i->llink;
N				i->llink = &item;
N				return true;
N			}
N			item.rlink = i;
N			item.llink = (T *)0;
N			i->llink = &item;
N			this->First = &item;
N			return true;
N		}
N		j->rlink = &item;
N		item.rlink = (Object *)0;
N		this->Last = &item;
N		item.llink = j;
N		return true;	
E ".\misc\inc\List.h" 64 18 identifier "T" is undefined
E ".\misc\inc\List.h" 64 21 expected an expression
E ".\misc\inc\List.h" 64 22 expected a ";"
E ".\misc\inc\List.h" 65 21 expected an expression
E ".\misc\inc\List.h" 65 22 expected a ";"
E ".\misc\inc\List.h" 84 18 identifier "T" is undefined
E ".\misc\inc\List.h" 84 21 expected an expression
E ".\misc\inc\List.h" 84 22 expected a ";"
N}
Ntemplate <class Object>
NObject &ArrayList<Object>::remove (Object &item)
N{
N	if (this->Elements == 0)return (Object *)0;
N	this->Elements--;
N	Object *l = item.llink,*r = item.rlink;
N		if (!l&&!r) {
N			this->First = (Object *)0;
N			this->Last = (Object *)0;
N			return (Object *)0;
N		}
N		if (!l) {
N			this->First = r;
N			r->llink = (T *)0;
N		}
N		else    l->rlink = r;
N		
N		if (!r) {
N   			l->rlink = (T *)0;
N			  this->Last = l;
N		}
N		else    r->llink = l;
N		return item;	
E ".\misc\inc\List.h" 108 16 identifier "T" is undefined
E ".\misc\inc\List.h" 108 19 expected an expression
E ".\misc\inc\List.h" 108 20 expected a ";"
E ".\misc\inc\List.h" 113 19 identifier "T" is undefined
E ".\misc\inc\List.h" 113 22 expected an expression
E ".\misc\inc\List.h" 113 23 expected a ";"
N}
N
Ntemplate <class Object>
Nbool ArrayList<Object>::add(Object *item)
N{
N	return *this + *item;
N}
N
N
Ntemplate <class Object>
N	template <typename Array>
NArray &ArrayList<Object>::add(Array *array)
N{
N	Array &a = *array;
N	return (*this) + a;
N}
N
Ntemplate <class Object>
N	template <typename Array>
Nvoid ArrayList<Object>::addAll (Array &array)
N{
N	while (t--) {
N		(*this) + array[t];
N	}
N	return *this;
E ".\misc\inc\List.h" 139 9 identifier "t" is undefined
E ".\misc\inc\List.h" 142 9 return value type does not match the function type
N}
N
Ntemplate <class Object>
N	template <typename Array>
Nvoid ArrayList<Object>::addAll (Array *array)
N{
N	for (Object o : array.getUserObject) {
N		
N	}
N	Array &a = *array;
N	return this->Array(a, t);
E ".\misc\inc\List.h" 149 18 expression must have class type
E ".\misc\inc\List.h" 153 15 class template "ArrayList<Object>" has no member "Array"
E ".\misc\inc\List.h" 153 24 identifier "t" is undefined
N}
N
N		  
N
Ntemplate <class Object>
NObject &ArrayList<Object>::remove (Object *item)
N{
N	return *this - *item;
N}
N/*
Ntemplate <class T>
Nbool List_Iterator<T>::operator << (T &item)
N{
N	return 0;
N}
Ntemplate <class T>
Nbool List_Iterator<T>::operator >> (T &item)
N{
N	return 0;
N}
N*/
N
Ntemplate <class Object>
NObject &ArrayList<Object>::get (uint32_t index)
N{
N	if (this->Elements < index) return (T *)0;
N	
N	T *item = this->First;
N	while (index--)
N		  item = item->rlink;
N	return item;
E ".\misc\inc\List.h" 179 38 identifier "T" is undefined
E ".\misc\inc\List.h" 179 41 expected an expression
E ".\misc\inc\List.h" 179 42 expected a ";"
E ".\misc\inc\List.h" 181 2 identifier "T" is undefined
E ".\misc\inc\List.h" 181 5 identifier "item" is undefined
N}
Ntemplate <class Object>
NObject &ArrayList<Object>::getLast ()
N{
N	return this->Last;
N}
N
Ntemplate <class Object>
NObject &ArrayList<Object>::getFirst ()
N{
N	return this->First;
N}
N
Ntemplate <class Object>
NObject &ArrayList<Object>::getNext (Object &item)
N{
N    if (item != (Object *)0)
N        if (item->rlink != (Object *)0) return item->rlink;
N    return (Object *)0;
N}
N
Ntemplate <class Object>
NObject &ArrayList<Object>::remove (uint32_t index)
N{
N	if (this->Elements < index) return (T *)0;
N	
N	T *item = this->First;
N	while (index--)
N		  item = item->rlink;
N	*(this) - item;
N	return item;
E ".\misc\inc\List.h" 209 38 identifier "T" is undefined
E ".\misc\inc\List.h" 209 41 expected an expression
E ".\misc\inc\List.h" 209 42 expected a ";"
E ".\misc\inc\List.h" 211 2 identifier "T" is undefined
E ".\misc\inc\List.h" 211 5 identifier "item" is undefined
N}
N
N
Ntemplate <class Object>
Nuint32_t ArrayList<Object>::size ()
N{
N	return this->Elements;
N}
N
N#endif /*__LIST*/
L 7 ".\memory\inc\memory_alloc.h" 2
N#include "locker.h"
L 1 ".\misc\inc\locker.h" 1
N#ifndef __LOCKER
N#define __LOCKER
N#include <stdint.h>
N
Nclass Locker {
N	public: 
N		Locker ();
N	  void Unlock (uint32_t = 0);
N	  void Lock (uint32_t = 0);
N	  bool Test ();
N  private:
N    bool lock;		
N};
N
N
N
N#endif
N
L 8 ".\memory\inc\memory_alloc.h" 2
N#include "Terminal_Interface.h"
L 1 ".\device\GUI\inc\Terminal_Interface.h" 1
N#ifndef TERMINAL_INTERFACE_H
N#define TERMINAL_INTERFACE_H
N
N#include <stdint.h>
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5050106
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
S  #define __STRING_DECLS
S
S    #undef __CLIBNS
S
S    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
S    #else
S      #define __CLIBNS
S    #endif  /* __cplusplus */
S
S#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
S /* unconditional in C++ and non-strict C for consistency of debug info */
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S#endif
S
S#undef NULL
S#define NULL 0                   /* see <stddef.h> */
S
Sextern _ARMABI void *memcpy(void * __restrict /*s1*/,
S                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * copies n characters from the object pointed to by s2 into the object
S    * pointed to by s1. If copying takes place between objects that overlap,
S    * the behaviour is undefined.
S    * Returns: the value of s1.
S    */
Sextern _ARMABI void *memmove(void * /*s1*/,
S                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * copies n characters from the object pointed to by s2 into the object
S    * pointed to by s1. Copying takes place as if the n characters from the
S    * object pointed to by s2 are first copied into a temporary array of n
S    * characters that does not overlap the objects pointed to by s1 and s2,
S    * and then the n characters from the temporary array are copied into the
S    * object pointed to by s1.
S    * Returns: the value of s1.
S    */
Sextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * copies the string pointed to by s2 (including the terminating nul
S    * character) into the array pointed to by s1. If copying takes place
S    * between objects that overlap, the behaviour is undefined.
S    * Returns: the value of s1.
S    */
Sextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * copies not more than n characters (characters that follow a null
S    * character are not copied) from the array pointed to by s2 into the array
S    * pointed to by s1. If copying takes place between objects that overlap,
S    * the behaviour is undefined.
S    * Returns: the value of s1.
S    */
S
Sextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * appends a copy of the string pointed to by s2 (including the terminating
S    * null character) to the end of the string pointed to by s1. The initial
S    * character of s2 overwrites the null character at the end of s1.
S    * Returns: the value of s1.
S    */
Sextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * appends not more than n characters (a null character and characters that
S    * follow it are not appended) from the array pointed to by s2 to the end of
S    * the string pointed to by s1. The initial character of s2 overwrites the
S    * null character at the end of s1. A terminating null character is always
S    * appended to the result.
S    * Returns: the value of s1.
S    */
S
S/*
S * The sign of a nonzero value returned by the comparison functions is
S * determined by the sign of the difference between the values of the first
S * pair of characters (both interpreted as unsigned char) that differ in the
S * objects being compared.
S */
S
Sextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * compares the first n characters of the object pointed to by s1 to the
S    * first n characters of the object pointed to by s2.
S    * Returns: an integer greater than, equal to, or less than zero, according
S    *          as the object pointed to by s1 is greater than, equal to, or
S    *          less than the object pointed to by s2.
S    */
Sextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * compares the string pointed to by s1 to the string pointed to by s2.
S    * Returns: an integer greater than, equal to, or less than zero, according
S    *          as the string pointed to by s1 is greater than, equal to, or
S    *          less than the string pointed to by s2.
S    */
Sextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * compares not more than n characters (characters that follow a null
S    * character are not compared) from the array pointed to by s1 to the array
S    * pointed to by s2.
S    * Returns: an integer greater than, equal to, or less than zero, according
S    *          as the string pointed to by s1 is greater than, equal to, or
S    *          less than the string pointed to by s2.
S    */
Sextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * compares the string pointed to by s1 to the string pointed to by s2,
S    * case-insensitively as defined by the current locale.
S    * Returns: an integer greater than, equal to, or less than zero, according
S    *          as the string pointed to by s1 is greater than, equal to, or
S    *          less than the string pointed to by s2.
S    */
Sextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * compares not more than n characters (characters that follow a null
S    * character are not compared) from the array pointed to by s1 to the array
S    * pointed to by s2, case-insensitively as defined by the current locale.
S    * Returns: an integer greater than, equal to, or less than zero, according
S    *          as the string pointed to by s1 is greater than, equal to, or
S    *          less than the string pointed to by s2.
S    */
Sextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * compares the string pointed to by s1 to the string pointed to by s2, both
S    * interpreted as appropriate to the LC_COLLATE category of the current
S    * locale.
S    * Returns: an integer greater than, equal to, or less than zero, according
S    *          as the string pointed to by s1 is greater than, equal to, or
S    *          less than the string pointed to by s2 when both are interpreted
S    *          as appropriate to the current locale.
S    */
S
Sextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
S   /*
S    * transforms the string pointed to by s2 and places the resulting string
S    * into the array pointed to by s1. The transformation function is such that
S    * if the strcmp function is applied to two transformed strings, it returns
S    * a value greater than, equal to or less than zero, corresponding to the
S    * result of the strcoll function applied to the same two original strings.
S    * No more than n characters are placed into the resulting array pointed to
S    * by s1, including the terminating null character. If n is zero, s1 is
S    * permitted to be a null pointer. If copying takes place between objects
S    * that overlap, the behaviour is undefined.
S    * Returns: The length of the transformed string is returned (not including
S    *          the terminating null character). If the value returned is n or
S    *          more, the contents of the array pointed to by s1 are
S    *          indeterminate.
S    */
S
S
S#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
S#else
Sextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
S#endif
S   /*
S    * locates the first occurence of c (converted to an unsigned char) in the
S    * initial n characters (each interpreted as unsigned char) of the object
S    * pointed to by s.
S    * Returns: a pointer to the located character, or a null pointer if the
S    *          character does not occur in the object.
S    */
S
S#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
S#else
Sextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
S#endif
S   /*
S    * locates the first occurence of c (converted to an char) in the string
S    * pointed to by s (including the terminating null character).
S    * Returns: a pointer to the located character, or a null pointer if the
S    *          character does not occur in the string.
S    */
S
Sextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * computes the length of the initial segment of the string pointed to by s1
S    * which consists entirely of characters not from the string pointed to by
S    * s2. The terminating null character is not considered part of s2.
S    * Returns: the length of the segment.
S    */
S
S#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
S#else
Sextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
S#endif
S   /*
S    * locates the first occurence in the string pointed to by s1 of any
S    * character from the string pointed to by s2.
S    * Returns: returns a pointer to the character, or a null pointer if no
S    *          character form s2 occurs in s1.
S    */
S
S#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
S#else
Sextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
S#endif
S   /*
S    * locates the last occurence of c (converted to a char) in the string
S    * pointed to by s. The terminating null character is considered part of
S    * the string.
S    * Returns: returns a pointer to the character, or a null pointer if c does
S    *          not occur in the string.
S    */
S
Sextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * computes the length of the initial segment of the string pointed to by s1
S    * which consists entirely of characters from the string pointed to by S2
S    * Returns: the length of the segment.
S    */
S
S#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
S#else
Sextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
S#endif
S   /*
S    * locates the first occurence in the string pointed to by s1 of the
S    * sequence of characters (excluding the terminating null character) in the
S    * string pointed to by s2.
S    * Returns: a pointer to the located string, or a null pointer if the string
S    *          is not found.
S    */
S
Sextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Sextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
S#ifndef __STRICT_ANSI__
Sextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
S#endif
S   /*
S    * A sequence of calls to the strtok function breaks the string pointed to
S    * by s1 into a sequence of tokens, each of which is delimited by a
S    * character from the string pointed to by s2. The first call in the
S    * sequence has s1 as its first argument, and is followed by calls with a
S    * null pointer as their first argument. The separator string pointed to by
S    * s2 may be different from call to call.
S    * The first call in the sequence searches for the first character that is
S    * not contained in the current separator string s2. If no such character
S    * is found, then there are no tokens in s1 and the strtok function returns
S    * a null pointer. If such a character is found, it is the start of the
S    * first token.
S    * The strtok function then searches from there for a character that is
S    * contained in the current separator string. If no such character is found,
S    * the current token extends to the end of the string pointed to by s1, and
S    * subsequent searches for a token will fail. If such a character is found,
S    * it is overwritten by a null character, which terminates the current
S    * token. The strtok function saves a pointer to the following character,
S    * from which the next search for a token will start.
S    * Each subsequent call, with a null pointer as the value for the first
S    * argument, starts searching from the saved pointer and behaves as
S    * described above.
S    * Returns: pointer to the first character of a token, or a null pointer if
S    *          there is no token.
S    *
S    * strtok_r() is a common extension which works exactly like
S    * strtok(), but instead of storing its state in a hidden
S    * library variable, requires the user to pass in a pointer to a
S    * char * variable which will be used instead. Any sequence of
S    * calls to strtok_r() passing the same char ** pointer should
S    * behave exactly like the corresponding sequence of calls to
S    * strtok(). This means that strtok_r() can safely be used in
S    * multi-threaded programs, and also that you can tokenise two
S    * strings in parallel.
S    */
S
Sextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
S   /*
S    * copies the value of c (converted to an unsigned char) into each of the
S    * first n charactes of the object pointed to by s.
S    * Returns: the value of s.
S    */
Sextern _ARMABI char *strerror(int /*errnum*/);
S   /*
S    * maps the error number in errnum to an error message string.
S    * Returns: a pointer to the string, the contents of which are
S    *          implementation-defined. The array pointed to shall not be
S    *          modified by the program, but may be overwritten by a
S    *          subsequent call to the strerror function.
S    */
Sextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
S   /*
S    * computes the length of the string pointed to by s.
S    * Returns: the number of characters that precede the terminating null
S    *          character.
S    */
S
Sextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * copies the string src into the string dst, using no more than
S    * len bytes of dst. Always null-terminates dst _within the
S    * length len (i.e. will copy at most len-1 bytes of string plus
S    * a NUL), unless len is actually zero.
S    * 
S    * Return value is the length of the string that _would_ have
S    * been written, i.e. the length of src. Thus, the operation
S    * succeeded without truncation if and only if ret < len;
S    * otherwise, the value in ret tells you how big to make dst if
S    * you decide to reallocate it. (That value does _not_ include
S    * the NUL.)
S    * 
S    * This is a BSD-derived library extension, which we are
S    * permitted to declare in a standard header because ISO defines
S    * function names beginning with 'str' as reserved for future
S    * expansion of <string.h>.
S    */
S
Sextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * concatenates the string src to the string dst, using no more
S    * than len bytes of dst. Always null-terminates dst _within the
S    * length len (i.e. will copy at most len-1 bytes of string plus
S    * a NUL), unless len is actually zero.
S    * 
S    * Return value is the length of the string that _would_ have
S    * been written, i.e. the length of src plus the original length
S    * of dst. Thus, the operation succeeded without truncation if
S    * and only if ret < len; otherwise, the value in ret tells you
S    * how big to make dst if you decide to reallocate it. (That
S    * value does _not_ include the NUL.)
S    * 
S    * If no NUL is encountered within the first len bytes of dst,
S    * then the length of dst is considered to have been equal to
S    * len for the purposes of the return value (as if there were a
S    * NUL at dst[len]). Thus, the return value in this case is len
S    * + strlen(src).
S    * 
S    * This is a BSD-derived library extension, which we are
S    * permitted to declare in a standard header because ISO defines
S    * function names beginning with 'str' as reserved for future
S    * expansion of <string.h>.
S    */
S
Sextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
S    /*
S     * Copies or moves a piece of memory from one place to another,
S     * with one-bit granularity. So you can start or finish a copy
S     * part way through a byte, and you can copy between regions
S     * with different alignment within a byte.
S     * 
S     * All these functions have the same prototype: two void *
S     * pointers for destination and source, then two integers
S     * giving the bit offset from those pointers, and finally the
S     * number of bits to copy.
S     * 
S     * Just like memcpy and memmove, the "cpy" functions copy as
S     * fast as they can in the assumption that the memory regions
S     * do not overlap, while the "move" functions cope correctly
S     * with overlap.
S     *
S     * Treating memory as a stream of individual bits requires
S     * defining a convention about what order those bits are
S     * considered to be arranged in. The above functions support
S     * multiple conventions:
S     * 
S     *  - the "bl" functions consider the unit of memory to be the
S     *    byte, and consider the bits within each byte to be
S     *    arranged in little-endian fashion, so that the LSB comes
S     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
S     *    the MSB of the byte at b to the LSB of the byte at a.)
S     * 
S     *  - the "bb" functions consider the unit of memory to be the
S     *    byte, and consider the bits within each byte to be
S     *    arranged in big-endian fashion, so that the MSB comes
S     *    first.
S     * 
S     *  - the "hl" functions consider the unit of memory to be the
S     *    16-bit halfword, and consider the bits within each word
S     *    to be arranged in little-endian fashion.
S     * 
S     *  - the "hb" functions consider the unit of memory to be the
S     *    16-bit halfword, and consider the bits within each word
S     *    to be arranged in big-endian fashion.
S     * 
S     *  - the "wl" functions consider the unit of memory to be the
S     *    32-bit word, and consider the bits within each word to be
S     *    arranged in little-endian fashion.
S     * 
S     *  - the "wb" functions consider the unit of memory to be the
S     *    32-bit word, and consider the bits within each word to be
S     *    arranged in big-endian fashion.
S     */
S
S    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
S    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
N    #ifndef __STRING_NO_EXPORTS
N      using ::std::size_t;
N      using ::std::memcpy;
N      using ::std::memmove;
N      using ::std::strcpy;
N      using ::std::strncpy;
N      using ::std::strcat;
N      using ::std::strncat;
N      using ::std::memcmp;
N      using ::std::strcmp;
N      using ::std::strncmp;
N      using ::std::strcasecmp;
N      using ::std::strncasecmp;
N      using ::std::strcoll;
N      using ::std::strxfrm;
N      using ::std::memchr;
N      using ::std::strchr;
N      using ::std::strcspn;
N      using ::std::strpbrk;
N      using ::std::strrchr;
N      using ::std::strspn;
N      using ::std::strstr;
N      using ::std::strtok;
N#ifndef __STRICT_ANSI__
N      using ::std::strtok_r;
N#endif
N      using ::std::_strtok_r;
N      using ::std::memset;
N      using ::std::strerror;
N      using ::std::strlen;
N      using ::std::strlcpy;
N      using ::std::strlcat;
N      using ::std::_membitcpybl;
N      using ::std::_membitcpybb;
N      using ::std::_membitcpyhl;
N      using ::std::_membitcpyhb;
N      using ::std::_membitcpywl;
N      using ::std::_membitcpywb;
N      using ::std::_membitmovebl;
N      using ::std::_membitmovebb;
N      using ::std::_membitmovehl;
N      using ::std::_membitmovehb;
N      using ::std::_membitmovewl;
N      using ::std::_membitmovewb;
N    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 6 ".\device\GUI\inc\Terminal_Interface.h" 2
N#include "dtostr.h"
L 1 ".\device\GUI\inc\dtostr.h" 1
N#ifndef DTOSTR__H
N#define DTOSTR__H
N#include <stdint.h>
N#include "string.h"
N#include <math.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\math.h" 1
N/*
N * math.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.5
N * Copyright (C) Codemist Ltd., 1988
N * Copyright 1991-1998,2004-2006,2014 ARM Limited. All rights reserved
N */
N
N/*
N * RCS $Revision: 185525 $ Codemist 0.03
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: statham $
N */
N
N/*
N * Parts of this file are based upon fdlibm:
N *
N * ====================================================
N * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
N *
N * Developed at SunSoft, a Sun Microsystems, Inc. business.
N * Permission to use, copy, modify, and distribute this
N * software is freely granted, provided that this notice
N * is preserved.
N * ====================================================
N */
N
N#ifndef __math_h
N#define __math_h
N#define __ARMCLIB_VERSION 5050106
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N/*
N * Some of these declarations are new in C99.  To access them in C++
N * you can use -D__USE_C99_MATH (or -D__USE_C99_ALL).
N */
N#ifndef __USE_C99_MATH
N  #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X  #if 0L || (0L && 199901L <= __STDC_VERSION__)
S    #define __USE_C99_MATH 1
N  #endif
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#ifdef __TARGET_ARCH_AARCH64
S# define _ARMABI_SOFTFP __declspec(__nothrow)
N#else
N# define _ARMABI_SOFTFP __declspec(__nothrow) __attribute__((__pcs__("aapcs")))
N# define __HAVE_LONGDOUBLE 1
N#endif
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#ifdef __FP_FENV_EXCEPTIONS
S# define _ARMABI_FPEXCEPT _ARMABI
N#else
N# define _ARMABI_FPEXCEPT _ARMABI __attribute__((const))
N#endif
N
N#ifdef __cplusplus
N#define _ARMABI_INLINE inline
N#define _ARMABI_INLINE_DEF inline
N#elif defined __GNUC__ || defined _USE_STATIC_INLINE
S#define _ARMABI_INLINE static __inline
S#define _ARMABI_INLINE_DEF static __inline
S#elif (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF static inline
S#else
S#define _ARMABI_INLINE __inline
S#define _ARMABI_INLINE_DEF __inline
N#endif
N
N#ifdef __TARGET_ARCH_AARCH64
S#  define _SOFTFP
N#else
N#  define _SOFTFP __attribute__((__pcs__("aapcs")))
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain the nans function, as well as the
N    * FP_NANS and FP_NANQ classification macros.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
N/*
N * Macros for our inline functions down below.
N * unsigned& __FLT(float x) - returns the bit pattern of x
N * unsigned& __HI(double x) - returns the bit pattern of the high part of x
N *                            (high part has exponent & sign bit in it)
N * unsigned& __LO(double x) - returns the bit pattern of the low part of x
N *
N * We can assign to __FLT, __HI, and __LO and the appropriate bits get set in
N * the floating point variable used.
N *
N * __HI & __LO are affected by the endianness and the target FPU.
N */
N#define __FLT(x) (*(unsigned *)&(x))
N#if defined(__ARM_BIG_ENDIAN) || defined(__BIG_ENDIAN)
X#if 0L || 0L
S#  define __LO(x) (*(1 + (unsigned *)&(x)))
S#  define __HI(x) (*(unsigned *)&(x))
N#else /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N#  define __HI(x) (*(1 + (unsigned *)&(x)))
N#  define __LO(x) (*(unsigned *)&(x))
N#endif /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N
N#   ifndef __MATH_DECLS
S#   define __MATH_DECLS
S
S
S/*
S * A set of functions that we don't actually want to put in the standard
S * namespace ever.  These are all called by the C99 macros.  As they're
S * not specified by any standard they can't belong in ::std::.  The
S * macro #defines are below amongst the standard function declarations.
S * We only include these if we actually need them later on
S */
S#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S#   ifdef __cplusplus
S      extern "C" {
S#   endif /* __cplusplus */
S
Sextern _SOFTFP unsigned __ARM_dcmp4(double /*x*/, double /*y*/);
Sextern _SOFTFP unsigned __ARM_fcmp4(float /*x*/, float /*y*/);
S    /*
S     * Compare x and y and return the CPSR in r0.  These means we can test for
S     * result types with bit pattern matching.
S     *
S     * These are a copy of the declarations in rt_fp.h keep in sync.
S     */
S
Sextern _ARMABI_SOFTFP int __ARM_fpclassifyf(float /*x*/);
Sextern _ARMABI_SOFTFP int __ARM_fpclassify(double /*x*/);
S    /* Classify x into NaN, infinite, normal, subnormal, zero */
S    /* Used by fpclassify macro */
S
S_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinitef(float __x)
S{
S    return ((__FLT(__x) >> 23) & 0xff) != 0xff;
S}
S_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinite(double __x)
S{
S    return ((__HI(__x) >> 20) & 0x7ff) != 0x7ff;
S}
S    /* Return 1 if __x is finite, 0 otherwise */
S    /* Used by isfinite macro */
S
S_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinff(float __x)
S{
S    return (__FLT(__x) << 1) == 0xff000000;
S}
S_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinf(double __x)
S{
S    return ((__HI(__x) << 1) == 0xffe00000) && (__LO(__x) == 0);
S}
S    /* Return 1 if __x is infinite, 0 otherwise */
S    /* Used by isinf macro */
S
S_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreaterf(float __x, float __y)
S{
S    unsigned __f = __ARM_fcmp4(__x, __y) >> 28;
S    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
S}
S_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreater(double __x, double __y)
S{
S    unsigned __f = __ARM_dcmp4(__x, __y) >> 28;
S    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
S}
S    /*
S     * Compare __x and __y and return 1 if __x < __y or __x > __y, 0 otherwise
S     * Used by islessgreater macro
S     */
S
S_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnanf(float __x)
S{
S    return (0x7f800000 - (__FLT(__x) & 0x7fffffff)) >> 31;
S}
S_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnan(double __x)
S{
S    unsigned __xf = __HI(__x) | ((__LO(__x) == 0) ? 0 : 1);
S    return (0x7ff00000 - (__xf & 0x7fffffff)) >> 31;
S}
S    /* Return 1 if __x is a NaN, 0 otherwise */
S    /* Used by isnan macro */
S
S_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormalf(float __x)
S{
S    unsigned __xe = (__FLT(__x) >> 23) & 0xff;
S    return (__xe != 0xff) && (__xe != 0);
S}
S_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormal(double __x)
S{
S    unsigned __xe = (__HI(__x) >> 20) & 0x7ff;
S    return (__xe != 0x7ff) && (__xe != 0);
S}
S    /* Return 1 if __x is a normalised number, 0 otherwise */
S    /* used by isnormal macro */
S
S_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbitf(float __x)
S{
S    return __FLT(__x) >> 31;
S}
S_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbit(double __x)
S{
S    return __HI(__x) >> 31;
S}
S    /* Return signbit of __x */
S    /* Used by signbit macro */
S
S#   ifdef __cplusplus
S      } /* extern "C" */
S#   endif /* __cplusplus */
S#endif /* Strict ANSI */
S
S#   undef __CLIBNS
S
S#   ifdef __cplusplus
S      namespace std {
S#       define __CLIBNS ::std::
S        extern "C" {
S#   else
S#       define __CLIBNS
S#   endif  /* __cplusplus */
S
S
S#ifndef __has_builtin
S  #define __has_builtin(x) 0
S#endif
S
S#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S  /* C99 additions */
S  typedef float float_t;
S  typedef double double_t;
S#if __has_builtin(__builtin_inf)
S#   define HUGE_VALF __builtin_inff()
S#   define HUGE_VALL __builtin_infl()
S#   define INFINITY __builtin_inff()
S#   define NAN __builtin_nanf("")
S# else
S#   define HUGE_VALF ((float)__INFINITY__)
S#   define HUGE_VALL ((long double)__INFINITY__)
S#   define INFINITY ((float)__INFINITY__)
S#   define NAN (__ESCAPE__(0f_7FC00000))
S#endif
S
S#   define MATH_ERRNO 1
S#   define MATH_ERREXCEPT 2
Sextern const int math_errhandling;
S#endif
S#if __has_builtin(__builtin_inf)
S# define HUGE_VAL __builtin_inf()
S#else
S# define HUGE_VAL ((double)__INFINITY__)
S#endif
S
Sextern _ARMABI double acos(double /*x*/);
S   /* computes the principal value of the arc cosine of x */
S   /* a domain error occurs for arguments not in the range -1 to 1 */
S   /* Returns: the arc cosine in the range 0 to Pi. */
Sextern _ARMABI double asin(double /*x*/);
S   /* computes the principal value of the arc sine of x */
S   /* a domain error occurs for arguments not in the range -1 to 1 */
S   /* and -HUGE_VAL is returned. */
S   /* Returns: the arc sine in the range -Pi/2 to Pi/2. */
S
Sextern _ARMABI_PURE double atan(double /*x*/);
S   /* computes the principal value of the arc tangent of x */
S   /* Returns: the arc tangent in the range -Pi/2 to Pi/2. */
S
Sextern _ARMABI double atan2(double /*y*/, double /*x*/);
S   /* computes the principal value of the arc tangent of y/x, using the */
S   /* signs of both arguments to determine the quadrant of the return value */
S   /* a domain error occurs if both args are zero, and -HUGE_VAL returned. */
S   /* Returns: the arc tangent of y/x, in the range -Pi to Pi. */
S
Sextern _ARMABI double cos(double /*x*/);
S   /* computes the cosine of x (measured in radians). A large magnitude */
S   /* argument may yield a result with little or no significance. */
S   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
S   /* Returns: the cosine value. */
Sextern _ARMABI double sin(double /*x*/);
S   /* computes the sine of x (measured in radians). A large magnitude */
S   /* argument may yield a result with little or no significance. */
S   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
S   /* Returns: the sine value. */
S
Sextern void __use_accurate_range_reduction(void);
S   /* reference this to select the larger, slower, but more accurate */
S   /* range reduction in sin, cos and tan */
S
Sextern _ARMABI double tan(double /*x*/);
S   /* computes the tangent of x (measured in radians). A large magnitude */
S   /* argument may yield a result with little or no significance */
S   /* Returns: the tangent value. */
S   /*          if range error; returns HUGE_VAL. */
S
Sextern _ARMABI double cosh(double /*x*/);
S   /* computes the hyperbolic cosine of x. A range error occurs if the */
S   /* magnitude of x is too large. */
S   /* Returns: the hyperbolic cosine value. */
S   /*          if range error; returns HUGE_VAL. */
Sextern _ARMABI double sinh(double /*x*/);
S   /* computes the hyperbolic sine of x. A range error occurs if the */
S   /* magnitude of x is too large. */
S   /* Returns: the hyperbolic sine value. */
S   /*          if range error; returns -HUGE_VAL or HUGE_VAL depending */
S   /*          on the sign of the argument */
S
Sextern _ARMABI_PURE double tanh(double /*x*/);
S   /* computes the hyperbolic tangent of x. */
S   /* Returns: the hyperbolic tangent value. */
S
Sextern _ARMABI double exp(double /*x*/);
S   /* computes the exponential function of x. A range error occurs if the */
S   /* magnitude of x is too large. */
S   /* Returns: the exponential value. */
S   /*          if underflow range error; 0 is returned. */
S   /*          if overflow range error; HUGE_VAL is returned. */
S
Sextern _ARMABI double frexp(double /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
S   /* breaks a floating-point number into a normalised fraction and an */
S   /* integral power of 2. It stores the integer in the int object pointed */
S   /* to by exp. */
S   /* Returns: the value x, such that x is a double with magnitude in the */
S   /* interval 0.5 to 1.0 or zero, and value equals x times 2 raised to the */
S   /* power *exp. If value is zero, both parts of the result are zero. */
S
Sextern _ARMABI double ldexp(double /*x*/, int /*exp*/);
S   /* multiplies a floating-point number by an integral power of 2. */
S   /* A range error may occur. */
S   /* Returns: the value of x times 2 raised to the power of exp. */
S   /*          if range error; HUGE_VAL is returned. */
Sextern _ARMABI double log(double /*x*/);
S   /* computes the natural logarithm of x. A domain error occurs if the */
S   /* argument is negative, and -HUGE_VAL is returned. A range error occurs */
S   /* if the argument is zero. */
S   /* Returns: the natural logarithm. */
S   /*          if range error; -HUGE_VAL is returned. */
Sextern _ARMABI double log10(double /*x*/);
S   /* computes the base-ten logarithm of x. A domain error occurs if the */
S   /* argument is negative. A range error occurs if the argument is zero. */
S   /* Returns: the base-ten logarithm. */
Sextern _ARMABI double modf(double /*value*/, double * /*iptr*/) __attribute__((__nonnull__(2)));
S   /* breaks the argument value into integral and fraction parts, each of */
S   /* which has the same sign as the argument. It stores the integral part */
S   /* as a double in the object pointed to by iptr. */
S   /* Returns: the signed fractional part of value. */
S
Sextern _ARMABI double pow(double /*x*/, double /*y*/);
S   /* computes x raised to the power of y. A domain error occurs if x is */
S   /* zero and y is less than or equal to zero, or if x is negative and y */
S   /* is not an integer, and -HUGE_VAL returned. A range error may occur. */
S   /* Returns: the value of x raised to the power of y. */
S   /*          if underflow range error; 0 is returned. */
S   /*          if overflow range error; HUGE_VAL is returned. */
Sextern _ARMABI double sqrt(double /*x*/);
S   /* computes the non-negative square root of x. A domain error occurs */
S   /* if the argument is negative, and -HUGE_VAL returned. */
S   /* Returns: the value of the square root. */
S
S#if defined(__TARGET_FPU_VFP_DOUBLE) && !defined(__TARGET_FPU_SOFTVFP)
S    _ARMABI_INLINE double _sqrt(double __x) { return __sqrt(__x); }
S#else
S    _ARMABI_INLINE double _sqrt(double __x) { return sqrt(__x); }
S#endif
S#if defined(__TARGET_FPU_VFP_SINGLE) && !defined(__TARGET_FPU_SOFTVFP)
S    _ARMABI_INLINE float _sqrtf(float __x) { return __sqrtf(__x); }
S#else
S    _ARMABI_INLINE float _sqrtf(float __x) { return (float)sqrt(__x); }
S#endif
S    /* With VFP, _sqrt and _sqrtf should expand inline as the native VFP square root
S     * instructions. They will not behave like the C sqrt() function, because
S     * they will report unusual values as IEEE exceptions (in fpmodes which
S     * support IEEE exceptions) rather than in errno. These function names
S     * are not specified in any standard. */
S
Sextern _ARMABI_PURE double ceil(double /*x*/);
S   /* computes the smallest integer not less than x. */
S   /* Returns: the smallest integer not less than x, expressed as a double. */
Sextern _ARMABI_PURE double fabs(double /*x*/);
S   /* computes the absolute value of the floating-point number x. */
S   /* Returns: the absolute value of x. */
S
Sextern _ARMABI_PURE double floor(double /*d*/);
S   /* computes the largest integer not greater than x. */
S   /* Returns: the largest integer not greater than x, expressed as a double */
S
Sextern _ARMABI double fmod(double /*x*/, double /*y*/);
S   /* computes the floating-point remainder of x/y. */
S   /* Returns: the value x - i * y, for some integer i such that, if y is */
S   /*          nonzero, the result has the same sign as x and magnitude */
S   /*          less than the magnitude of y. If y is zero, a domain error */
S   /*          occurs and -HUGE_VAL is returned. */
S
S    /* Additional Mathlib functions not defined by the ANSI standard.
S     * Not guaranteed, and not necessarily very well tested.
S     * C99 requires the user to include <math.h> to use these functions
S     * declaring them "by hand" is not sufficient
S     *
S     * The above statement is not completely true now.  Some of the above
S     * C99 functionality has been added as per the Standard, and (where
S     * necessary) old Mathlib functionality withdrawn/changed.  Before
S     * including this header #define __ENABLE_MATHLIB_LEGACY if you want to
S     * re-enable the legacy functionality.
S     */
S
S#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S
Sextern _ARMABI double acosh(double /*x*/);
S    /*
S     * Inverse cosh. EDOM if argument < 1.0
S     */
Sextern _ARMABI double asinh(double /*x*/);
S    /*
S     * Inverse sinh.
S     */
Sextern _ARMABI double atanh(double /*x*/);
S    /*
S     * Inverse tanh. EDOM if |argument| > 1.0
S     */
Sextern _ARMABI double cbrt(double /*x*/);
S    /*
S     * Cube root.
S     */
S_ARMABI_INLINE _ARMABI_PURE double copysign(double __x, double __y)
S    /*
S     * Returns x with sign bit replaced by sign of y.
S     */
S{
S    __HI(__x) = (__HI(__x) & 0x7fffffff) | (__HI(__y) & 0x80000000);
S    return __x;
S}
S_ARMABI_INLINE _ARMABI_PURE float copysignf(float __x, float __y)
S    /*
S     * Returns x with sign bit replaced by sign of y.
S     */
S{
S    __FLT(__x) = (__FLT(__x) & 0x7fffffff) | (__FLT(__y) & 0x80000000);
S    return __x;
S}
Sextern _ARMABI double erf(double /*x*/);
S    /*
S     * Error function. (2/sqrt(pi)) * integral from 0 to x of exp(-t*t) dt.
S     */
Sextern _ARMABI double erfc(double /*x*/);
S    /*
S     * 1-erf(x). (More accurate than just coding 1-erf(x), for large x.)
S     */
Sextern _ARMABI double expm1(double /*x*/);
S    /*
S     * exp(x)-1. (More accurate than just coding exp(x)-1, for small x.)
S     */
S#define fpclassify(x) \
S    ((sizeof(x) == sizeof(float)) ? \
S        __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
X#define fpclassify(x)     ((sizeof(x) == sizeof(float)) ?         __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
S    /*
S     * Classify a floating point number into one of the following values:
S     */
S#define FP_ZERO         (0)
S#define FP_SUBNORMAL    (4)
S#define FP_NORMAL       (5)
S#define FP_INFINITE     (3)
S#define FP_NAN          (7)
S
S#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
S/* 
S * Note that we'll never classify a number as FP_NAN, as all NaNs will 
S * be either FP_NANQ or FP_NANS
S */
S#  define FP_NANQ       (8)
S#  define FP_NANS       (9)
S#endif
S
S
Sextern _ARMABI double hypot(double /*x*/, double /*y*/);
S    /*
S     * sqrt(x*x+y*y), ie the length of the vector (x,y) or the
S     * hypotenuse of a right triangle whose other two sides are x
S     * and y. Won't overflow unless the _answer_ is too big, even
S     * if the intermediate x*x+y*y is too big.
S     */
Sextern _ARMABI int ilogb(double /*x*/);
S    /*
S     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
S     */
Sextern _ARMABI int ilogbf(float /*x*/);
S    /*
S     * Like ilogb but takes a float
S     */
Sextern _ARMABI int ilogbl(long double /*x*/);
S    /*
S     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
S     */
S#define FP_ILOGB0   (-0x7fffffff) /* ilogb(0) == -INT_MAX */
S#define FP_ILOGBNAN ( 0x80000000) /* ilogb(NAN) == INT_MIN */
S
S#define isfinite(x) \
S    ((sizeof(x) == sizeof(float)) \
S        ? __ARM_isfinitef(x) \
S        : __ARM_isfinite(x))
X#define isfinite(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isfinitef(x)         : __ARM_isfinite(x))
S    /*
S     * Returns true if x is a finite number, size independent.
S     */
S
S#define isgreater(x, y) \
S    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
S        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000) \
S        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
X#define isgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
S    /*
S     * Returns true if x > y, throws no exceptions except on Signaling NaNs
S     *
S     * We want the C not set but the Z bit clear, V must be clear
S     */
S
S#define isgreaterequal(x, y) \
S    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
S        ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000) \
S        : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
X#define isgreaterequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
S    /*
S     * Returns true if x >= y, throws no exceptions except on Signaling NaNs
S     *
S     * We just need to see if the C bit is set or not and ensure V clear
S     */
S
S#define isinf(x) \
S    ((sizeof(x) == sizeof(float)) \
S        ? __ARM_isinff(x) \
S        : __ARM_isinf(x))
X#define isinf(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isinff(x)         : __ARM_isinf(x))
S    /*
S     * Returns true if x is an infinity, size independent.
S     */
S
S#define isless(x, y)  \
S    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
S        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000) \
S        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
X#define isless(x, y)      (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
S    /*
S     * Returns true if x < y, throws no exceptions except on Signaling NaNs
S     *
S     * We're less than if N is set, V clear
S     */
S
S#define islessequal(x, y) \
S    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
S        ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0) \
S        : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
X#define islessequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0)         : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
S    /*
S     * Returns true if x <= y, throws no exceptions except on Signaling NaNs
S     *
S     * We're less than or equal if one of N or Z is set, V clear
S     */
S
S#define islessgreater(x, y) \
S    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
S        ? __ARM_islessgreaterf((x), (y)) \
S        : __ARM_islessgreater((x), (y)))
X#define islessgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? __ARM_islessgreaterf((x), (y))         : __ARM_islessgreater((x), (y)))
S    /*
S     * Returns true if x <> y, throws no exceptions except on Signaling NaNs
S     * Unfortunately this test is too complicated to do in a macro without
S     * evaluating x & y twice.  Shame really...
S     */
S
S#define isnan(x) \
S    ((sizeof(x) == sizeof(float)) \
S        ? __ARM_isnanf(x) \
S        : __ARM_isnan(x))
X#define isnan(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnanf(x)         : __ARM_isnan(x))
S    /*
S     * Returns TRUE if x is a NaN.
S     */
S
S#define isnormal(x) \
S    ((sizeof(x) == sizeof(float)) \
S        ? __ARM_isnormalf(x) \
S        : __ARM_isnormal(x))
X#define isnormal(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnormalf(x)         : __ARM_isnormal(x))
S    /*
S     * Returns TRUE if x is a NaN.
S     */
S
S#define isunordered(x, y) \
S    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
S        ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000) \
S        : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
X#define isunordered(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000)         : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
S    /*
S     * Returns true if x ? y, throws no exceptions except on Signaling NaNs
S     * Unordered occurs if and only if the V bit is set
S     */
S
Sextern _ARMABI double lgamma (double /*x*/);
S    /*
S     * The log of the absolute value of the gamma function of x. The sign
S     * of the gamma function of x is returned in the global `signgam'.
S     */
Sextern _ARMABI double log1p(double /*x*/);
S    /*
S     * log(1+x). (More accurate than just coding log(1+x), for small x.)
S     */
Sextern _ARMABI double logb(double /*x*/);
S    /*
S     * Like ilogb but returns a double.
S     */
Sextern _ARMABI float logbf(float /*x*/);
S    /*
S     * Like logb but takes and returns float
S     */
Sextern _ARMABI long double logbl(long double /*x*/);
S    /*
S     * Like logb but takes and returns long double
S     */
Sextern _ARMABI double nextafter(double /*x*/, double /*y*/);
S    /*
S     * Returns the next representable number after x, in the
S     * direction toward y.
S     */
Sextern _ARMABI float nextafterf(float /*x*/, float /*y*/);
S    /*
S     * Returns the next representable number after x, in the
S     * direction toward y.
S     */
Sextern _ARMABI long double nextafterl(long double /*x*/, long double /*y*/);
S    /*
S     * Returns the next representable number after x, in the
S     * direction toward y.
S     */
Sextern _ARMABI double nexttoward(double /*x*/, long double /*y*/);
S    /*
S     * Returns the next representable number after x, in the
S     * direction toward y.
S     */
Sextern _ARMABI float nexttowardf(float /*x*/, long double /*y*/);
S    /*
S     * Returns the next representable number after x, in the
S     * direction toward y.
S     */
Sextern _ARMABI long double nexttowardl(long double /*x*/, long double /*y*/);
S    /*
S     * Returns the next representable number after x, in the
S     * direction toward y.
S     */
Sextern _ARMABI double remainder(double /*x*/, double /*y*/);
S    /*
S     * Returns the remainder of x by y, in the IEEE 754 sense.
S     */
Sextern _ARMABI_FPEXCEPT double rint(double /*x*/);
S    /*
S     * Rounds x to an integer, in the IEEE 754 sense.
S     */
Sextern _ARMABI double scalbln(double /*x*/, long int /*n*/);
S    /*
S     * Compute x times 2^n quickly.
S     */
Sextern _ARMABI float scalblnf(float /*x*/, long int /*n*/);
S    /*
S     * Compute x times 2^n quickly.
S     */
Sextern _ARMABI long double scalblnl(long double /*x*/, long int /*n*/);
S    /*
S     * Compute x times 2^n quickly.
S     */
Sextern _ARMABI double scalbn(double /*x*/, int /*n*/);
S    /*
S     * Compute x times 2^n quickly.
S     */
Sextern _ARMABI float scalbnf(float /*x*/, int /*n*/);
S    /*
S     * Compute x times 2^n quickly.
S     */
Sextern _ARMABI long double scalbnl(long double /*x*/, int /*n*/);
S    /*
S     * Compute x times 2^n quickly.
S     */
S#define signbit(x) \
S    ((sizeof(x) == sizeof(float)) \
S        ? __ARM_signbitf(x) \
S        : __ARM_signbit(x))
X#define signbit(x)     ((sizeof(x) == sizeof(float))         ? __ARM_signbitf(x)         : __ARM_signbit(x))
S    /*
S     * Returns the signbit of x, size independent macro
S     */
S#endif
S
S/* C99 float versions of functions.  math.h has always reserved these
S   identifiers for this purpose (7.13.4). */
Sextern _ARMABI_PURE float _fabsf(float); /* old ARM name */
S_ARMABI_INLINE _ARMABI_PURE float fabsf(float __f) { return _fabsf(__f); }
Sextern _ARMABI float sinf(float /*x*/);
Sextern _ARMABI float cosf(float /*x*/);
Sextern _ARMABI float tanf(float /*x*/);
Sextern _ARMABI float acosf(float /*x*/);
Sextern _ARMABI float asinf(float /*x*/);
Sextern _ARMABI float atanf(float /*x*/);
Sextern _ARMABI float atan2f(float /*y*/, float /*x*/);
Sextern _ARMABI float sinhf(float /*x*/);
Sextern _ARMABI float coshf(float /*x*/);
Sextern _ARMABI float tanhf(float /*x*/);
Sextern _ARMABI float expf(float /*x*/);
Sextern _ARMABI float logf(float /*x*/);
Sextern _ARMABI float log10f(float /*x*/);
Sextern _ARMABI float powf(float /*x*/, float /*y*/);
Sextern _ARMABI float sqrtf(float /*x*/);
Sextern _ARMABI float ldexpf(float /*x*/, int /*exp*/);
Sextern _ARMABI float frexpf(float /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Sextern _ARMABI_PURE float ceilf(float /*x*/);
Sextern _ARMABI_PURE float floorf(float /*x*/);
Sextern _ARMABI float fmodf(float /*x*/, float /*y*/);
Sextern _ARMABI float modff(float /*value*/, float * /*iptr*/) __attribute__((__nonnull__(2)));
S
S/* C99 long double versions of functions. */
S/* (also need to have 'using' declarations below) */
S#define _ARMDEFLD1(f) \
S    _ARMABI long double f##l(long double /*x*/)
X#define _ARMDEFLD1(f)     _ARMABI long double f##l(long double  )
S
S#define _ARMDEFLD1P(f, T) \
S    _ARMABI long double f##l(long double /*x*/, T /*p*/)
X#define _ARMDEFLD1P(f, T)     _ARMABI long double f##l(long double  , T  )
S
S#define _ARMDEFLD2(f) \
S    _ARMABI long double f##l(long double /*x*/, long double /*y*/)
X#define _ARMDEFLD2(f)     _ARMABI long double f##l(long double  , long double  )
S
S/*
S * Long double versions of C89 functions can be defined
S * unconditionally, because C89 reserved these names in "future
S * library directions".
S */
S_ARMDEFLD1(acos);
S_ARMDEFLD1(asin);
S_ARMDEFLD1(atan);
S_ARMDEFLD2(atan2);
S_ARMDEFLD1(ceil);
S_ARMDEFLD1(cos);
S_ARMDEFLD1(cosh);
S_ARMDEFLD1(exp);
S_ARMDEFLD1(fabs);
S_ARMDEFLD1(floor);
S_ARMDEFLD2(fmod);
S_ARMDEFLD1P(frexp, int*) __attribute__((__nonnull__(2)));
S_ARMDEFLD1P(ldexp, int);
S_ARMDEFLD1(log);
S_ARMDEFLD1(log10);
S_ARMABI long double modfl(long double /*x*/, long double * /*p*/) __attribute__((__nonnull__(2)));
S_ARMDEFLD2(pow);
S_ARMDEFLD1(sin);
S_ARMDEFLD1(sinh);
S_ARMDEFLD1(sqrt);
S_ARMDEFLD1(tan);
S_ARMDEFLD1(tanh);
S
S#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S
S/*
S * C99 float and long double versions of extra-C89 functions.
S */
Sextern _ARMABI float acoshf(float /*x*/);
S_ARMDEFLD1(acosh);
Sextern _ARMABI float asinhf(float /*x*/);
S_ARMDEFLD1(asinh);
Sextern _ARMABI float atanhf(float /*x*/);
S_ARMDEFLD1(atanh);
S_ARMDEFLD2(copysign);
Sextern _ARMABI float cbrtf(float /*x*/);
S_ARMDEFLD1(cbrt);
Sextern _ARMABI float erff(float /*x*/);
S_ARMDEFLD1(erf);
Sextern _ARMABI float erfcf(float /*x*/);
S_ARMDEFLD1(erfc);
Sextern _ARMABI float expm1f(float /*x*/);
S_ARMDEFLD1(expm1);
Sextern _ARMABI float log1pf(float /*x*/);
S_ARMDEFLD1(log1p);
Sextern _ARMABI float hypotf(float /*x*/, float /*y*/);
S_ARMDEFLD2(hypot);
Sextern _ARMABI float lgammaf(float /*x*/);
S_ARMDEFLD1(lgamma);
Sextern _ARMABI float remainderf(float /*x*/, float /*y*/);
S_ARMDEFLD2(remainder);
Sextern _ARMABI float rintf(float /*x*/);
S_ARMDEFLD1(rint);
S
S#endif
S
S#ifdef __USE_C99_MATH
S/*
S * Functions new in C99.
S */
Sextern _ARMABI double exp2(double /*x*/); /* * 2.^x. */
Sextern _ARMABI float exp2f(float /*x*/);
S_ARMDEFLD1(exp2);
Sextern _ARMABI double fdim(double /*x*/, double /*y*/);
Sextern _ARMABI float fdimf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fdim);
S#ifdef __FP_FAST_FMA
S#define FP_FAST_FMA
S#endif
S#ifdef __FP_FAST_FMAF
S#define FP_FAST_FMAF
S#endif
S#ifdef __FP_FAST_FMAL
S#define FP_FAST_FMAL
S#endif
Sextern _ARMABI double fma(double /*x*/, double /*y*/, double /*z*/);
Sextern _ARMABI float fmaf(float /*x*/, float /*y*/, float /*z*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z) \
S    { return (long double)fma((double)__x, (double)__y, (double)__z); }
X_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z)     { return (long double)fma((double)__x, (double)__y, (double)__z); }
S#endif
Sextern _ARMABI_FPEXCEPT double fmax(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fmaxf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmax);
Sextern _ARMABI_FPEXCEPT double fmin(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fminf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmin);
Sextern _ARMABI double log2(double /*x*/); /* * log base 2 of x. */
Sextern _ARMABI float log2f(float /*x*/);
S_ARMDEFLD1(log2);
Sextern _ARMABI long lrint(double /*x*/);
Sextern _ARMABI long lrintf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI long lrintl(long double __x) \
S    { return lrint((double)__x); }
X_ARMABI_INLINE _ARMABI long lrintl(long double __x)     { return lrint((double)__x); }
S#endif
Sextern _ARMABI __LONGLONG llrint(double /*x*/);
Sextern _ARMABI __LONGLONG llrintf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x) \
S    { return llrint((double)__x); }
X_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x)     { return llrint((double)__x); }
S#endif
Sextern _ARMABI long lround(double /*x*/);
Sextern _ARMABI long lroundf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI long lroundl(long double __x) \
S    { return lround((double)__x); }
X_ARMABI_INLINE _ARMABI long lroundl(long double __x)     { return lround((double)__x); }
S#endif
Sextern _ARMABI __LONGLONG llround(double /*x*/);
Sextern _ARMABI __LONGLONG llroundf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x) \
S    { return llround((double)__x); }
X_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x)     { return llround((double)__x); }
S#endif
Sextern _ARMABI_PURE double nan(const char */*tagp*/);
Sextern _ARMABI_PURE float nanf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t) \
S    { return (long double)nan(__t); }
X_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t)     { return (long double)nan(__t); }
S#endif
S#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
Sextern _ARMABI_PURE double nans(const char */*tagp*/);
Sextern _ARMABI_PURE float nansf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t) \
S    { return (long double)nans(__t); }
X_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t)     { return (long double)nans(__t); }
S#endif
S#endif 
Sextern _ARMABI_FPEXCEPT double nearbyint(double /*x*/);
Sextern _ARMABI_FPEXCEPT float nearbyintf(float /*x*/);
S_ARMDEFLD1(nearbyint);
Sextern  double remquo(double /*x*/, double /*y*/, int */*quo*/);
Sextern  float remquof(float /*x*/, float /*y*/, int */*quo*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q) \
S    { return (long double)remquo((double)__x, (double)__y, __q); }
X_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q)     { return (long double)remquo((double)__x, (double)__y, __q); }
S#endif
Sextern _ARMABI_FPEXCEPT double round(double /*x*/);
Sextern _ARMABI_FPEXCEPT float roundf(float /*x*/);
S_ARMDEFLD1(round);
Sextern _ARMABI double tgamma(double /*x*/); /* * The gamma function of x. */
Sextern _ARMABI float tgammaf(float /*x*/);
S_ARMDEFLD1(tgamma);
Sextern _ARMABI_FPEXCEPT double trunc(double /*x*/);
Sextern _ARMABI_FPEXCEPT float truncf(float /*x*/);
S_ARMDEFLD1(trunc);
S#endif
S
S#undef _ARMDEFLD1
S#undef _ARMDEFLD1P
S#undef _ARMDEFLD2
S
S#ifdef __cplusplus
S  extern "C++" {
S    inline float abs(float __x)   { return fabsf(__x); }
S    inline float acos(float __x)  { return acosf(__x); }
S    inline float asin(float __x)  { return asinf(__x); }
S    inline float atan(float __x)  { return atanf(__x); }
S    inline float atan2(float __y, float __x)    { return atan2f(__y,__x); }
S    inline float ceil(float __x)  { return ceilf(__x); }
S    inline float cos(float __x)   { return cosf(__x); }
S    inline float cosh(float __x)  { return coshf(__x); }
S    inline float exp(float __x)   { return expf(__x); }
S    inline float fabs(float __x)  { return fabsf(__x); }
S    inline float floor(float __x) { return floorf(__x); }
S    inline float fmod(float __x, float __y)     { return fmodf(__x, __y); }
S    float frexp(float __x, int* __exp) __attribute__((__nonnull__(2)));
S    inline float frexp(float __x, int* __exp)   { return frexpf(__x, __exp); }
S    inline float ldexp(float __x, int __exp)    { return ldexpf(__x, __exp);}
S    inline float log(float __x)   { return logf(__x); }
S    inline float log10(float __x) { return log10f(__x); }
S    float modf(float __x, float* __iptr) __attribute__((__nonnull__(2)));
S    inline float modf(float __x, float* __iptr) { return modff(__x, __iptr); }
S    inline float pow(float __x, float __y)      { return powf(__x,__y); }
S    inline float pow(float __x, int __y)     { return powf(__x, (float)__y); }
S    inline float sin(float __x)   { return sinf(__x); }
S    inline float sinh(float __x)  { return sinhf(__x); }
S    inline float sqrt(float __x)  { return sqrtf(__x); }
S    inline float _sqrt(float __x) { return _sqrtf(__x); }
S    inline float tan(float __x)   { return tanf(__x); }
S    inline float tanh(float __x)  { return tanhf(__x); }
S
S    inline double abs(double __x) { return fabs(__x); }
S    inline double pow(double __x, int __y)
S                { return pow(__x, (double) __y); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double abs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double acos(long double __x)
S                { return (long double)acosl(__x); }
S    inline long double asin(long double __x)
S                { return (long double)asinl(__x); }
S    inline long double atan(long double __x)
S                { return (long double)atanl(__x); }
S    inline long double atan2(long double __y, long double __x)
S                { return (long double)atan2l(__y, __x); }
S    inline long double ceil(long double __x)
S                { return (long double)ceill( __x); }
S    inline long double cos(long double __x)
S                { return (long double)cosl(__x); }
S    inline long double cosh(long double __x)
S                { return (long double)coshl(__x); }
S    inline long double exp(long double __x)
S                { return (long double)expl(__x); }
S    inline long double fabs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double floor(long double __x)
S                { return (long double)floorl(__x); }
S    inline long double fmod(long double __x, long double __y)
S                { return (long double)fmodl(__x, __y); }
S    long double frexp(long double __x, int* __p) __attribute__((__nonnull__(2)));
S    inline long double frexp(long double __x, int* __p)
S                { return (long double)frexpl(__x, __p); }
S    inline long double ldexp(long double __x, int __exp)
S                { return (long double)ldexpl(__x, __exp); }
S    inline long double log(long double __x)
S                { return (long double)logl(__x); }
S    inline long double log10(long double __x)
S                { return (long double)log10l(__x); }
S    long double modf(long double __x, long double* __p) __attribute__((__nonnull__(2)));
S    inline long double modf(long double __x, long double* __p)
S                { return (long double)modfl(__x, __p); }
S    inline long double pow(long double __x, long double __y)
S                { return (long double)powl(__x, __y); }
S    inline long double pow(long double __x, int __y)
S                { return (long double)powl(__x, __y); }
S    inline long double sin(long double __x)
S                { return (long double)sinl(__x); }
S    inline long double sinh(long double __x)
S                { return (long double)sinhl(__x); }
S    inline long double sqrt(long double __x)
S                { return (long double)sqrtl(__x); }
S    inline long double _sqrt(long double __x)
S                { return (long double)_sqrt((double) __x); }
S    inline long double tan(long double __x)
S                { return (long double)tanl(__x); }
S    inline long double tanh(long double __x)
S                { return (long double)tanhl(__x); }
S#endif
S
S#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S    inline float acosh(float __x) { return acoshf(__x); }
S    inline float asinh(float __x) { return asinhf(__x); }
S    inline float atanh(float __x) { return atanhf(__x); }
S    inline float cbrt(float __x) { return cbrtf(__x); }
S    inline float erf(float __x) { return erff(__x); }
S    inline float erfc(float __x) { return erfcf(__x); }
S    inline float expm1(float __x) { return expm1f(__x); }
S    inline float log1p(float __x) { return log1pf(__x); }
S    inline float hypot(float __x, float __y) { return hypotf(__x, __y); }
S    inline float lgamma(float __x) { return lgammaf(__x); }
S    inline float remainder(float __x, float __y) { return remainderf(__x, __y); }
S    inline float rint(float __x) { return rintf(__x); }
S#endif
S
S#ifdef __USE_C99_MATH
S    inline float exp2(float __x) { return exp2f(__x); }
S    inline float fdim(float __x, float __y) { return fdimf(__x, __y); }
S    inline float fma(float __x, float __y, float __z) { return fmaf(__x, __y, __z); }
S    inline float fmax(float __x, float __y) { return fmaxf(__x, __y); }
S    inline float fmin(float __x, float __y) { return fminf(__x, __y); }
S    inline float log2(float __x) { return log2f(__x); }
S    inline _ARMABI long lrint(float __x) { return lrintf(__x); }
S    inline _ARMABI __LONGLONG llrint(float __x) { return llrintf(__x); }
S    inline _ARMABI long lround(float __x) { return lroundf(__x); }
S    inline _ARMABI __LONGLONG llround(float __x) { return llroundf(__x); }
S    inline _ARMABI_FPEXCEPT float nearbyint(float __x) { return nearbyintf(__x); }
S    inline float remquo(float __x, float __y, int *__q) { return remquof(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT float round(float __x) { return roundf(__x); }
S    inline float tgamma(float __x) { return tgammaf(__x); }
S    inline _ARMABI_FPEXCEPT float trunc(float __x) { return truncf(__x); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double acosh(long double __x) { return acoshl(__x); }
S    inline long double asinh(long double __x) { return asinhl(__x); }
S    inline long double atanh(long double __x) { return atanhl(__x); }
S    inline long double cbrt(long double __x) { return cbrtl(__x); }
S    inline long double erf(long double __x) { return erfl(__x); }
S    inline long double erfc(long double __x) { return erfcl(__x); }
S    inline long double expm1(long double __x) { return expm1l(__x); }
S    inline long double log1p(long double __x) { return log1pl(__x); }
S    inline long double hypot(long double __x, long double __y) { return hypotl(__x, __y); }
S    inline long double lgamma(long double __x) { return lgammal(__x); }
S    inline long double remainder(long double __x, long double __y) { return remainderl(__x, __y); }
S    inline long double rint(long double __x) { return rintl(__x); }
S    inline long double exp2(long double __x) { return exp2l(__x); }
S    inline long double fdim(long double __x, long double __y) { return fdiml(__x, __y); }
S    inline long double fma(long double __x, long double __y, long double __z) { return fmal(__x, __y, __z); }
S    inline long double fmax(long double __x, long double __y) { return fmaxl(__x, __y); }
S    inline long double fmin(long double __x, long double __y) { return fminl(__x, __y); }
S    inline long double log2(long double __x) { return log2l(__x); }
S    inline _ARMABI long lrint(long double __x) { return lrintl(__x); }
S    inline _ARMABI __LONGLONG llrint(long double __x) { return llrintl(__x); }
S    inline _ARMABI long lround(long double __x) { return lroundl(__x); }
S    inline _ARMABI __LONGLONG llround(long double __x) { return llroundl(__x); }
S    inline _ARMABI_FPEXCEPT long double nearbyint(long double __x) { return nearbyintl(__x); }
S    inline long double remquo(long double __x, long double __y, int *__q) { return remquol(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT long double round(long double __x) { return roundl(__x); }
S    inline long double tgamma(long double __x) { return tgammal(__x); }
S    inline _ARMABI_FPEXCEPT long double trunc(long double __x) { return truncl(__x); }
S#endif
S#endif
S
S  }
S#endif
S
S    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
S    #endif
N  #endif /* __MATH_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__MATH_NO_EXPORTS)
X  #if 1L && !0L
N    using ::std::__use_accurate_range_reduction;
N    using ::std::abs;
N    using ::std::acos;
N    using ::std::asin;
N    using ::std::atan2;
N    using ::std::atan;
N    using ::std::ceil;
N    using ::std::cos;
N    using ::std::cosh;
N    using ::std::exp;
N    using ::std::fabs;
N    using ::std::floor;
N    using ::std::fmod;
N    using ::std::frexp;
N    using ::std::ldexp;
N    using ::std::log10;
N    using ::std::log;
N    using ::std::modf;
N    using ::std::pow;
N    using ::std::sin;
N    using ::std::sinh;
N    using ::std::sqrt;
N    using ::std::_sqrt;
N    using ::std::_sqrtf;
N    using ::std::tan;
N    using ::std::tanh;
N    using ::std::_fabsf;
N    /* C99 float and long double versions in already-C89-reserved namespace */
N    using ::std::acosf;
N    using ::std::acosl;
N    using ::std::asinf;
N    using ::std::asinl;
N    using ::std::atan2f;
N    using ::std::atan2l;
N    using ::std::atanf;
N    using ::std::atanl;
N    using ::std::ceilf;
N    using ::std::ceill;
N    using ::std::cosf;
N    using ::std::coshf;
N    using ::std::coshl;
N    using ::std::cosl;
N    using ::std::expf;
N    using ::std::expl;
N    using ::std::fabsf;
N    using ::std::fabsl;
N    using ::std::floorf;
N    using ::std::floorl;
N    using ::std::fmodf;
N    using ::std::fmodl;
N    using ::std::frexpf;
N    using ::std::frexpl;
N    using ::std::ldexpf;
N    using ::std::ldexpl;
N    using ::std::log10f;
N    using ::std::log10l;
N    using ::std::logf;
N    using ::std::logl;
N    using ::std::modff;
N    using ::std::modfl;
N    using ::std::powf;
N    using ::std::powl;
N    using ::std::sinf;
N    using ::std::sinhf;
N    using ::std::sinhl;
N    using ::std::sinl;
N    using ::std::sqrtf;
N    using ::std::sqrtl;
N    using ::std::tanf;
N    using ::std::tanhf;
N    using ::std::tanhl;
N    using ::std::tanl;
N    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X    #if !0L || 0L
N      /* C99 additions which for historical reasons appear in non-strict mode */
N      using ::std::acosh;
N      using ::std::asinh;
N      using ::std::atanh;
N      using ::std::cbrt;
N      using ::std::copysign;
N      using ::std::copysignf;
N      using ::std::erf;
N      using ::std::erfc;
N      using ::std::expm1;
N      using ::std::hypot;
N      using ::std::ilogb;
N      using ::std::ilogbf;
N      using ::std::ilogbl;
N      using ::std::lgamma;
N      using ::std::log1p;
N      using ::std::logb;
N      using ::std::logbf;
N      using ::std::logbl;
N      using ::std::nextafter;
N      using ::std::nextafterf;
N      using ::std::nextafterl;
N      using ::std::nexttoward;
N      using ::std::nexttowardf;
N      using ::std::nexttowardl;
N      using ::std::remainder;
N      using ::std::rint;
N      using ::std::scalbln;
N      using ::std::scalblnf;
N      using ::std::scalblnl;
N      using ::std::scalbn;
N      using ::std::scalbnf;
N      using ::std::scalbnl;
N      using ::std::math_errhandling;
N      using ::std::acoshf;
N      using ::std::acoshl;
N      using ::std::asinhf;
N      using ::std::asinhl;
N      using ::std::atanhf;
N      using ::std::atanhl;
N      using ::std::copysignl;
N      using ::std::cbrtf;
N      using ::std::cbrtl;
N      using ::std::erff;
N      using ::std::erfl;
N      using ::std::erfcf;
N      using ::std::erfcl;
N      using ::std::expm1f;
N      using ::std::expm1l;
N      using ::std::log1pf;
N      using ::std::log1pl;
N      using ::std::hypotf;
N      using ::std::hypotl;
N      using ::std::lgammaf;
N      using ::std::lgammal;
N      using ::std::remainderf;
N      using ::std::remainderl;
N      using ::std::rintf;
N      using ::std::rintl;
N    #endif
N    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X    #if !0L || 0L
N      /* C99 additions which appear in C99 or non-strict mode */
N      using ::std::float_t;
N      using ::std::double_t;
N    #endif
N    #ifdef __USE_C99_MATH
S      /* Functions new in C99. */
S      using ::std::exp2;
S      using ::std::exp2f;
S      using ::std::exp2l;
S      using ::std::fdim;
S      using ::std::fdimf;
S      using ::std::fdiml;
S      using ::std::fma;
S      using ::std::fmaf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::fmal;
S#endif
S      using ::std::fmax;
S      using ::std::fmaxf;
S      using ::std::fmaxl;
S      using ::std::fmin;
S      using ::std::fminf;
S      using ::std::fminl;
S      using ::std::log2;
S      using ::std::log2f;
S      using ::std::log2l;
S      using ::std::lrint;
S      using ::std::lrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lrintl;
S#endif
S      using ::std::llrint;
S      using ::std::llrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llrintl;
S#endif
S      using ::std::lround;
S      using ::std::lroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lroundl;
S#endif
S      using ::std::llround;
S      using ::std::llroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llroundl;
S#endif
S      using ::std::nan;
S      using ::std::nanf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::nanl;
S#endif
S      using ::std::nearbyint;
S      using ::std::nearbyintf;
S      using ::std::nearbyintl;
S      using ::std::remquo;
S      using ::std::remquof;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::remquol;
S#endif
S      using ::std::round;
S      using ::std::roundf;
S      using ::std::roundl;
S      using ::std::tgamma;
S      using ::std::tgammaf;
S      using ::std::tgammal;
S      using ::std::trunc;
S      using ::std::truncf;
S      using ::std::truncl;
N    #endif
N  #endif
N
N#undef __LONGLONG
N
N#endif /* __math_h */
N
N/* end of math.h */
L 6 ".\device\GUI\inc\dtostr.h" 2
N
Nnamespace STR {
N
Nstatic char *Reverse (char *);	
N	
Nchar *itoa (int32_t, char *, uint32_t);
N	
N	
N	
N};
N#endif /*DTOSTR__H*/
N
N/*End Of File*/
N
L 7 ".\device\GUI\inc\Terminal_Interface.h" 2
N#include "String_Defs.h"
L 1 ".\device\GUI\inc\String_Defs.h" 1
N#ifndef STRING_DEFS_H
N#define STRING_DEFS_H
N#include <stdint.h>
N
Nstruct bar_t {
N  const char* __string;
N  uint16_t __len;    
N};
N
Ntypedef struct {
N	union __Buff {
N		const char *Const;
N		char       *Ram;    
N	} Buff;
N	uint32_t Size;
N} __TEXT;
N
N#endif /*STRING_DEFS_H*/
N
N/*End Of File*/
L 8 ".\device\GUI\inc\Terminal_Interface.h" 2
N
N#ifndef T_CHAR
N#define T_CHAR 
Ntypedef char tchar_t; 
N#endif
N
Ntypedef struct {
N	uint8_t Tab;
N} tab_t;
N
Nclass __TTY {
N	public:
N	  __TTY ();
N	  void operator () (void *, uint32_t);
N	  __TTY &Print (int32_t, char *str, uint32_t);
N	  __TTY &Print (char *str, uint32_t);
N	  __TTY &Print (int32_t, char *str);
N	  __TTY &Print (char *str);
N	  __TTY &Char (int32_t, char);
N	  __TTY &Char (char);
N	  __TTY &operator << (char *);
N	  __TTY &operator << (int32_t);
N	  __TTY &operator << (float);
N	  __TTY &operator << (double);
N	  __TTY &operator << (char);
N	  __TTY &operator << (tab_t);
N	  __TTY &operator + (char *);
N	  __TTY &operator + (int32_t);
N	  __TTY &operator + (float);
N	  __TTY &operator + (double);
N	  __TTY &operator + (char);
N	  __TTY &operator + (tab_t);
N	
N	  __TEXT Print ();
N	private:
N		void Clear ();
N		char *Buff;
N	  uint32_t Size;
N	  uint32_t Cursor;
N};
N
N#endif /*TERMINAL_INTERFACE_H*/
N
N/*End Of File*/
N
L 9 ".\memory\inc\memory_alloc.h" 2
N#include "String_Defs.h"
N
N#ifndef Heap_Print_Alloc
N#define Heap_Print_Alloc 200
N#endif
N
Ntypedef uint32_t memory_size_t;
Ntypedef uint32_t alloc_addr_t; 
N
Nclass MemoryChunk : public List_Node <MemoryChunk, alloc_addr_t> {
N  public:
N	  MemoryChunk () {}
N	private:
N	  memory_size_t size;
N	
N	friend class MemoryAllocator;
N};
N
N#define __m sizeof(MemoryChunk)
N
Nclass MemoryAllocator : public Locker ,
N	                      public __TTY {
N	public:
N	  MemoryAllocator () {}
N	  void operator () (void *, memory_size_t);
N	  void *New (memory_size_t);
N	  int32_t Delete (void *);
N			
N	  int32_t Check ();	
N	  __TEXT PrintTable ();
N	private:
N	  MemoryChunk *Separate (MemoryChunk *P, memory_size_t Size);
N	  int32_t Sanitize (ArrayList <MemoryChunk> &List);
N	  ArrayList <MemoryChunk> PoolFree, PoolInUse;
N      uint32_t Success, Errors, Sanitized;
N};
N
N
N#endif /*__ALLOCATOR*/
N
L 2 "memory\src\memory_alloc.cpp" 2
N
Nvoid MemoryAllocator::operator () (void *__heap, memory_size_t __size) 
N{
N	MemoryChunk *chunk = (MemoryChunk *)__heap;
N	for (memory_size_t i = 0; i < __size; i++) {
N	    *((uint8_t *)__heap + i) = 0;
N	}
N	chunk->size = __size;
N	chunk->key  = (alloc_addr_t)chunk;
E "memory\src\memory_alloc.cpp" 11 17 no operator "+" matches these operands
e "memory\src\memory_alloc.cpp" 11 17 operand types are: ArrayList<MemoryChunk> + MemoryChunk *
C "" 0 0 error limit reached
N	this->PoolFree + chunk;
