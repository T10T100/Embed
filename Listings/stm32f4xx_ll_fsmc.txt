; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--cpp --list --debug -c --asm --interleave -o.\objects\stm32f4xx_ll_fsmc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_ll_fsmc.d --cpu=Cortex-M4.fp --apcs=interwork -O1 -Otime --diag_suppress=9931 -I.\device\GUI\inc -I.\device\hardware\inc -I.\device\init\inc -I.\misc\inc -I.\user\inc -I..\tester_1.03 -I.\memory\inc -I.\drivers\inc -IE:\KeilProj\tester_1_03\Embed\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.4.0 -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.4.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=514 -D_RTE_ -DSTM32F417xx -DSTM32F417xx -DColorDepthBpp16 -Dtftili9486 -DSOFTWARE_GL -DGUI_ALLIGN_LAYSIZE_TO_POW2 --omf_browse=.\objects\stm32f4xx_ll_fsmc.crf drivers\src\stm32f4xx_ll_fsmc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAM_Init PROC
;;;145      */
;;;146    HAL_StatusTypeDef  FSMC_NORSRAM_Init(FSMC_NORSRAM_TypeDef *Device, FSMC_NORSRAM_InitTypeDef* Init)
000000  b470              PUSH     {r4-r6}
;;;147    { 
;;;148      uint32_t tmpr = 0;
;;;149        
;;;150      /* Check the parameters */
;;;151      assert_param(IS_FSMC_NORSRAM_BANK(Init->NSBank));
;;;152      assert_param(IS_FSMC_MUX(Init->DataAddressMux));
;;;153      assert_param(IS_FSMC_MEMORY(Init->MemoryType));
;;;154      assert_param(IS_FSMC_NORSRAM_MEMORY_WIDTH(Init->MemoryDataWidth));
;;;155      assert_param(IS_FSMC_BURSTMODE(Init->BurstAccessMode));
;;;156      assert_param(IS_FSMC_WAIT_POLARITY(Init->WaitSignalPolarity));
;;;157      assert_param(IS_FSMC_WRAP_MODE(Init->WrapMode));
;;;158      assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(Init->WaitSignalActive));
;;;159      assert_param(IS_FSMC_WRITE_OPERATION(Init->WriteOperation));
;;;160      assert_param(IS_FSMC_WAITE_SIGNAL(Init->WaitSignal));
;;;161      assert_param(IS_FSMC_EXTENDED_MODE(Init->ExtendedMode));
;;;162      assert_param(IS_FSMC_ASYNWAIT(Init->AsynchronousWait));
;;;163      assert_param(IS_FSMC_WRITE_BURST(Init->WriteBurst));
;;;164      
;;;165      /* Get the BTCR register value */
;;;166      tmpr = Device->BTCR[Init->NSBank];
000002  680a              LDR      r2,[r1,#0]
000004  f8503022          LDR      r3,[r0,r2,LSL #2]
;;;167    
;;;168      /* Clear MBKEN, MUXEN, MTYP, MWID, FACCEN, BURSTEN, WAITPOL, WRAPMOD, WAITCFG, WREN,
;;;169               WAITEN, EXTMOD, ASYNCWAIT, CBURSTRW and CCLKEN bits */
;;;170      tmpr &= ((uint32_t)~(FSMC_BCR1_MBKEN     | FSMC_BCR1_MUXEN    | FSMC_BCR1_MTYP     | \
000008  f8dfc360          LDR      r12,|L1.876|
00000c  ea030c0c          AND      r12,r3,r12
;;;171                           FSMC_BCR1_MWID      | FSMC_BCR1_FACCEN   | FSMC_BCR1_BURSTEN  | \
;;;172                           FSMC_BCR1_WAITPOL   | FSMC_BCR1_WRAPMOD  | FSMC_BCR1_WAITCFG  | \
;;;173                           FSMC_BCR1_WREN      | FSMC_BCR1_WAITEN   | FSMC_BCR1_EXTMOD   | \
;;;174                           FSMC_BCR1_ASYNCWAIT | FSMC_BCR1_CBURSTRW));
;;;175      /* Set NORSRAM device control parameters */
;;;176      tmpr |= (uint32_t)(Init->DataAddressMux       |\
000010  684c              LDR      r4,[r1,#4]
000012  688b              LDR      r3,[r1,#8]
000014  690e              LDR      r6,[r1,#0x10]
000016  68cd              LDR      r5,[r1,#0xc]
000018  431c              ORRS     r4,r4,r3
00001a  4335              ORRS     r5,r5,r6
00001c  432c              ORRS     r4,r4,r5
00001e  694d              LDR      r5,[r1,#0x14]
000020  432c              ORRS     r4,r4,r5
000022  698d              LDR      r5,[r1,#0x18]
000024  432c              ORRS     r4,r4,r5
000026  69cd              LDR      r5,[r1,#0x1c]
000028  432c              ORRS     r4,r4,r5
00002a  6a0d              LDR      r5,[r1,#0x20]
00002c  432c              ORRS     r4,r4,r5
00002e  6a4d              LDR      r5,[r1,#0x24]
000030  432c              ORRS     r4,r4,r5
000032  6a8d              LDR      r5,[r1,#0x28]
000034  432c              ORRS     r4,r4,r5
000036  6acd              LDR      r5,[r1,#0x2c]
000038  6b09              LDR      r1,[r1,#0x30]
00003a  432c              ORRS     r4,r4,r5
00003c  4321              ORRS     r1,r1,r4
00003e  ea41010c          ORR      r1,r1,r12
;;;177                         Init->MemoryType           |\
;;;178                         Init->MemoryDataWidth      |\
;;;179                         Init->BurstAccessMode      |\
;;;180                         Init->WaitSignalPolarity   |\
;;;181                         Init->WrapMode             |\
;;;182                         Init->WaitSignalActive     |\
;;;183                         Init->WriteOperation       |\
;;;184                         Init->WaitSignal           |\
;;;185                         Init->ExtendedMode         |\
;;;186                         Init->AsynchronousWait     |\
;;;187                         Init->WriteBurst
;;;188                         );
;;;189                        
;;;190      if(Init->MemoryType == FSMC_MEMORY_TYPE_NOR)
000042  2b08              CMP      r3,#8
000044  d101              BNE      |L1.74|
;;;191      {
;;;192        tmpr |= (uint32_t)FSMC_NORSRAM_FLASH_ACCESS_ENABLE;
000046  f0410140          ORR      r1,r1,#0x40
                  |L1.74|
;;;193      }
;;;194      
;;;195      Device->BTCR[Init->NSBank] = tmpr;                   
00004a  f8401022          STR      r1,[r0,r2,LSL #2]
;;;196      
;;;197      return HAL_OK;
;;;198    }
00004e  bc70              POP      {r4-r6}
000050  2000              MOVS     r0,#0                 ;197
000052  4770              BX       lr
;;;199    
                          ENDP

                  FSMC_NORSRAM_DeInit PROC
;;;206      */
;;;207    HAL_StatusTypeDef FSMC_NORSRAM_DeInit(FSMC_NORSRAM_TypeDef *Device, FSMC_NORSRAM_EXTENDED_TypeDef *ExDevice, uint32_t Bank)
000054  f8503022          LDR      r3,[r0,r2,LSL #2]
;;;208    {
;;;209      /* Check the parameters */
;;;210      assert_param(IS_FSMC_NORSRAM_DEVICE(Device));
;;;211      assert_param(IS_FSMC_NORSRAM_EXTENDED_DEVICE(ExDevice));
;;;212    
;;;213      /* Disable the FSMC_NORSRAM device */
;;;214      __FSMC_NORSRAM_DISABLE(Device, Bank);
000058  f0230301          BIC      r3,r3,#1
00005c  f8403022          STR      r3,[r0,r2,LSL #2]
;;;215      
;;;216      /* De-initialize the FSMC_NORSRAM device */
;;;217      /* FSMC_NORSRAM_BANK1 */
;;;218      if(Bank == FSMC_NORSRAM_BANK1)
000060  2a00              CMP      r2,#0
000062  d00d              BEQ      |L1.128|
;;;219      {
;;;220        Device->BTCR[Bank] = 0x000030DB;    
;;;221      }
;;;222      /* FSMC_NORSRAM_BANK2, FSMC_NORSRAM_BANK3 or FSMC_NORSRAM_BANK4 */
;;;223      else
;;;224      {   
;;;225        Device->BTCR[Bank] = 0x000030D2; 
000064  f24303d2          MOV      r3,#0x30d2
000068  f8403022          STR      r3,[r0,r2,LSL #2]
                  |L1.108|
;;;226      }
;;;227      
;;;228      Device->BTCR[Bank + 1] = 0x0FFFFFFF;
00006c  f1020c01          ADD      r12,r2,#1
000070  f06f4370          MVN      r3,#0xf0000000
000074  f840302c          STR      r3,[r0,r12,LSL #2]
;;;229      ExDevice->BWTR[Bank]   = 0x0FFFFFFF;
000078  f8413022          STR      r3,[r1,r2,LSL #2]
;;;230       
;;;231      return HAL_OK;
00007c  2000              MOVS     r0,#0
;;;232    }
00007e  4770              BX       lr
                  |L1.128|
000080  f24303db          MOV      r3,#0x30db            ;220
000084  6003              STR      r3,[r0,#0]            ;220
000086  e7f1              B        |L1.108|
;;;233    
                          ENDP

                  FSMC_NORSRAM_Timing_Init PROC
;;;242      */
;;;243    HAL_StatusTypeDef FSMC_NORSRAM_Timing_Init(FSMC_NORSRAM_TypeDef *Device, FSMC_NORSRAM_TimingTypeDef *Timing, uint32_t Bank)
000088  b430              PUSH     {r4,r5}
;;;244    {
;;;245      uint32_t tmpr = 0;
;;;246      
;;;247      /* Check the parameters */
;;;248      assert_param(IS_FSMC_ADDRESS_SETUP_TIME(Timing->AddressSetupTime));
;;;249      assert_param(IS_FSMC_ADDRESS_HOLD_TIME(Timing->AddressHoldTime));
;;;250      assert_param(IS_FSMC_DATASETUP_TIME(Timing->DataSetupTime));
;;;251      assert_param(IS_FSMC_TURNAROUND_TIME(Timing->BusTurnAroundDuration));
;;;252      assert_param(IS_FSMC_CLK_DIV(Timing->CLKDivision));
;;;253      assert_param(IS_FSMC_DATA_LATENCY(Timing->DataLatency));
;;;254      assert_param(IS_FSMC_ACCESS_MODE(Timing->AccessMode));
;;;255      
;;;256      /* Get the BTCR register value */
;;;257      tmpr = Device->BTCR[Bank + 1];
00008a  1c52              ADDS     r2,r2,#1
00008c  f8503022          LDR      r3,[r0,r2,LSL #2]
;;;258    
;;;259      /* Clear ADDSET, ADDHLD, DATAST, BUSTURN, CLKDIV, DATLAT and ACCMOD bits */
;;;260      tmpr &= ((uint32_t)~(FSMC_BTR1_ADDSET  | FSMC_BTR1_ADDHLD | FSMC_BTR1_DATAST | \
000090  f0034340          AND      r3,r3,#0xc0000000
;;;261                           FSMC_BTR1_BUSTURN | FSMC_BTR1_CLKDIV | FSMC_BTR1_DATLAT | \
;;;262                           FSMC_BTR1_ACCMOD));
;;;263      
;;;264      /* Set FSMC_NORSRAM device timing parameters */  
;;;265      tmpr |= (uint32_t)(Timing->AddressSetupTime                 |\
000094  f8d1c000          LDR      r12,[r1,#0]
000098  684c              LDR      r4,[r1,#4]
00009a  898d              LDRH     r5,[r1,#0xc]
00009c  ea4c1c04          ORR      r12,r12,r4,LSL #4
0000a0  688c              LDR      r4,[r1,#8]
0000a2  0224              LSLS     r4,r4,#8
0000a4  ea444405          ORR      r4,r4,r5,LSL #16
0000a8  ea4c0c04          ORR      r12,r12,r4
0000ac  8a0c              LDRH     r4,[r1,#0x10]
0000ae  1e64              SUBS     r4,r4,#1
0000b0  ea4c5c04          ORR      r12,r12,r4,LSL #20
0000b4  7d0c              LDRB     r4,[r1,#0x14]
0000b6  6989              LDR      r1,[r1,#0x18]
0000b8  1ea4              SUBS     r4,r4,#2
0000ba  ea4c6c04          ORR      r12,r12,r4,LSL #24
0000be  ea4c0101          ORR      r1,r12,r1
0000c2  4319              ORRS     r1,r1,r3
;;;266                        ((Timing->AddressHoldTime) << 4)          |\
;;;267                        ((Timing->DataSetupTime) << 8)            |\
;;;268                        ((Timing->BusTurnAroundDuration) << 16)   |\
;;;269                        (((Timing->CLKDivision)-1) << 20)         |\
;;;270                        (((Timing->DataLatency)-2) << 24)         |\
;;;271                        (Timing->AccessMode));
;;;272      
;;;273      Device->BTCR[Bank + 1] = tmpr; 
0000c4  f8401022          STR      r1,[r0,r2,LSL #2]
;;;274      
;;;275      return HAL_OK;   
0000c8  2000              MOVS     r0,#0
;;;276    }
0000ca  bc30              POP      {r4,r5}
0000cc  4770              BX       lr
;;;277    
                          ENDP

                  FSMC_NORSRAM_Extended_Timing_Init PROC
;;;285      */
;;;286    HAL_StatusTypeDef  FSMC_NORSRAM_Extended_Timing_Init(FSMC_NORSRAM_EXTENDED_TypeDef *Device, FSMC_NORSRAM_TimingTypeDef *Timing, uint32_t Bank, uint32_t ExtendedMode)
0000ce  b430              PUSH     {r4,r5}
;;;287    {
;;;288      uint32_t tmpr = 0;
;;;289      
;;;290      /* Set NORSRAM device timing register for write configuration, if extended mode is used */
;;;291      if(ExtendedMode == FSMC_EXTENDED_MODE_ENABLE)
0000d0  f5b34f80          CMP      r3,#0x4000
0000d4  d006              BEQ      |L1.228|
;;;292      {
;;;293        /* Check the parameters */  
;;;294        assert_param(IS_FSMC_ADDRESS_SETUP_TIME(Timing->AddressSetupTime));
;;;295        assert_param(IS_FSMC_ADDRESS_HOLD_TIME(Timing->AddressHoldTime));
;;;296        assert_param(IS_FSMC_DATASETUP_TIME(Timing->DataSetupTime));
;;;297        assert_param(IS_FSMC_TURNAROUND_TIME(Timing->BusTurnAroundDuration));
;;;298        assert_param(IS_FSMC_CLK_DIV(Timing->CLKDivision));
;;;299        assert_param(IS_FSMC_DATA_LATENCY(Timing->DataLatency));
;;;300        assert_param(IS_FSMC_ACCESS_MODE(Timing->AccessMode));
;;;301      
;;;302        /* Get the BWTR register value */
;;;303        tmpr = Device->BWTR[Bank];
;;;304        
;;;305        /* Clear ADDSET, ADDHLD, DATAST, BUSTURN, CLKDIV, DATLAT and ACCMOD bits */
;;;306        tmpr &= ((uint32_t)~(FSMC_BWTR1_ADDSET  | FSMC_BWTR1_ADDHLD | FSMC_BWTR1_DATAST | \
;;;307                             FSMC_BWTR1_BUSTURN | FSMC_BWTR1_CLKDIV | FSMC_BWTR1_DATLAT | \
;;;308                             FSMC_BWTR1_ACCMOD));
;;;309    
;;;310        tmpr |= (uint32_t)(Timing->AddressSetupTime                 |\
;;;311                         ((Timing->AddressHoldTime) << 4)          |\
;;;312                         ((Timing->DataSetupTime) << 8)            |\
;;;313                         ((Timing->BusTurnAroundDuration) << 16)   |\
;;;314                         (((Timing->CLKDivision)-1) << 20)         |\
;;;315                         (((Timing->DataLatency)-2) << 24)         |\
;;;316                         (Timing->AccessMode));
;;;317        
;;;318        Device->BWTR[Bank] = tmpr; 
;;;319      }
;;;320      else                                        
;;;321      {
;;;322        Device->BWTR[Bank] = 0x0FFFFFFF;
0000d6  f06f4170          MVN      r1,#0xf0000000
0000da  f8401022          STR      r1,[r0,r2,LSL #2]
                  |L1.222|
;;;323      }   
;;;324      
;;;325      return HAL_OK;  
;;;326    }
0000de  bc30              POP      {r4,r5}
0000e0  2000              MOVS     r0,#0                 ;325
0000e2  4770              BX       lr
                  |L1.228|
0000e4  f8503022          LDR      r3,[r0,r2,LSL #2]     ;303
0000e8  f0034340          AND      r3,r3,#0xc0000000     ;306
0000ec  f8d1c000          LDR      r12,[r1,#0]           ;310
0000f0  684c              LDR      r4,[r1,#4]            ;310
0000f2  898d              LDRH     r5,[r1,#0xc]          ;310
0000f4  ea4c1c04          ORR      r12,r12,r4,LSL #4     ;310
0000f8  688c              LDR      r4,[r1,#8]            ;310
0000fa  0224              LSLS     r4,r4,#8              ;310
0000fc  ea444405          ORR      r4,r4,r5,LSL #16      ;310
000100  ea4c0c04          ORR      r12,r12,r4            ;310
000104  8a0c              LDRH     r4,[r1,#0x10]         ;310
000106  1e64              SUBS     r4,r4,#1              ;310
000108  ea4c5c04          ORR      r12,r12,r4,LSL #20    ;310
00010c  7d0c              LDRB     r4,[r1,#0x14]         ;310
00010e  6989              LDR      r1,[r1,#0x18]         ;310
000110  1ea4              SUBS     r4,r4,#2              ;310
000112  ea4c6c04          ORR      r12,r12,r4,LSL #24    ;310
000116  ea4c0101          ORR      r1,r12,r1             ;310
00011a  4319              ORRS     r1,r1,r3              ;310
00011c  f8401022          STR      r1,[r0,r2,LSL #2]     ;318
000120  e7dd              B        |L1.222|
;;;327    /**
                          ENDP

                  FSMC_NORSRAM_WriteOperation_Enable PROC
;;;351      */
;;;352    HAL_StatusTypeDef FSMC_NORSRAM_WriteOperation_Enable(FSMC_NORSRAM_TypeDef *Device, uint32_t Bank)
000122  f8502021          LDR      r2,[r0,r1,LSL #2]
;;;353    {
;;;354      /* Enable write operation */
;;;355      Device->BTCR[Bank] |= FSMC_WRITE_OPERATION_ENABLE; 
000126  f4425280          ORR      r2,r2,#0x1000
00012a  f8402021          STR      r2,[r0,r1,LSL #2]
;;;356    
;;;357      return HAL_OK;  
00012e  2000              MOVS     r0,#0
;;;358    }
000130  4770              BX       lr
;;;359    
                          ENDP

                  FSMC_NORSRAM_WriteOperation_Disable PROC
;;;365      */
;;;366    HAL_StatusTypeDef FSMC_NORSRAM_WriteOperation_Disable(FSMC_NORSRAM_TypeDef *Device, uint32_t Bank)
000132  f8502021          LDR      r2,[r0,r1,LSL #2]
;;;367    { 
;;;368      /* Disable write operation */
;;;369      Device->BTCR[Bank] &= ~FSMC_WRITE_OPERATION_ENABLE; 
000136  f4225280          BIC      r2,r2,#0x1000
00013a  f8402021          STR      r2,[r0,r1,LSL #2]
;;;370    
;;;371      return HAL_OK;  
00013e  2000              MOVS     r0,#0
;;;372    }
000140  4770              BX       lr
;;;373    /**
                          ENDP

                  FSMC_NAND_Init PROC
;;;429      */
;;;430    HAL_StatusTypeDef FSMC_NAND_Init(FSMC_NAND_TypeDef *Device, FSMC_NAND_InitTypeDef *Init)
000142  b410              PUSH     {r4}
;;;431    {
;;;432      uint32_t tmpr  = 0; 
;;;433        
;;;434      /* Check the parameters */
;;;435      assert_param(IS_FSMC_NAND_BANK(Init->NandBank));
;;;436      assert_param(IS_FSMC_WAIT_FEATURE(Init->Waitfeature));
;;;437      assert_param(IS_FSMC_NAND_MEMORY_WIDTH(Init->MemoryDataWidth));
;;;438      assert_param(IS_FSMC_ECC_STATE(Init->EccComputation));
;;;439      assert_param(IS_FSMC_ECCPAGE_SIZE(Init->ECCPageSize));
;;;440      assert_param(IS_FSMC_TCLR_TIME(Init->TCLRSetupTime));
;;;441      assert_param(IS_FSMC_TAR_TIME(Init->TARSetupTime));   
;;;442    
;;;443        if(Init->NandBank == FSMC_NAND_BANK2)
000144  680a              LDR      r2,[r1,#0]
000146  2a10              CMP      r2,#0x10
000148  d01d              BEQ      |L1.390|
;;;444      {
;;;445        /* Get the NAND bank 2 register value */
;;;446        tmpr = Device->PCR2;
;;;447      }
;;;448      else
;;;449      {
;;;450        /* Get the NAND bank 3 register value */
;;;451        tmpr = Device->PCR3;
00014a  6a02              LDR      r2,[r0,#0x20]
                  |L1.332|
;;;452      }
;;;453      
;;;454      /* Clear PWAITEN, PBKEN, PTYP, PWID, ECCEN, TCLR, TAR and ECCPS bits */
;;;455      tmpr &= ((uint32_t)~(FSMC_PCR2_PWAITEN  | FSMC_PCR2_PBKEN | FSMC_PCR2_PTYP | \
00014c  4b88              LDR      r3,|L1.880|
00014e  ea020203          AND      r2,r2,r3
;;;456                           FSMC_PCR2_PWID | FSMC_PCR2_ECCEN | FSMC_PCR2_TCLR | \
;;;457                           FSMC_PCR2_TAR | FSMC_PCR2_ECCPS));  
;;;458      
;;;459      /* Set NAND device control parameters */
;;;460      tmpr |= (uint32_t)(Init->Waitfeature                |\
000152  f8d1c008          LDR      r12,[r1,#8]
000156  684b              LDR      r3,[r1,#4]
000158  690c              LDR      r4,[r1,#0x10]
00015a  ea43030c          ORR      r3,r3,r12
00015e  f8d1c00c          LDR      r12,[r1,#0xc]
000162  ea4c0c04          ORR      r12,r12,r4
000166  ea43030c          ORR      r3,r3,r12
00016a  f8d1c014          LDR      r12,[r1,#0x14]
00016e  6989              LDR      r1,[r1,#0x18]
000170  ea43234c          ORR      r3,r3,r12,LSL #9
000174  ea433141          ORR      r1,r3,r1,LSL #13
000178  ea410102          ORR      r1,r1,r2
00017c  f0410108          ORR      r1,r1,#8
;;;461                         FSMC_PCR_MEMORY_TYPE_NAND         |\
;;;462                         Init->MemoryDataWidth            |\
;;;463                         Init->EccComputation             |\
;;;464                         Init->ECCPageSize                |\
;;;465                         ((Init->TCLRSetupTime) << 9)     |\
;;;466                         ((Init->TARSetupTime) << 13));   
;;;467      
;;;468      if(Init->NandBank == FSMC_NAND_BANK2)
000180  d103              BNE      |L1.394|
;;;469      {
;;;470        /* NAND bank 2 registers configuration */
;;;471        Device->PCR2  = tmpr;
000182  6001              STR      r1,[r0,#0]
000184  e002              B        |L1.396|
                  |L1.390|
000186  6802              LDR      r2,[r0,#0]            ;446
000188  e7e0              B        |L1.332|
                  |L1.394|
;;;472      }
;;;473      else
;;;474      {
;;;475        /* NAND bank 3 registers configuration */
;;;476        Device->PCR3  = tmpr;
00018a  6201              STR      r1,[r0,#0x20]
                  |L1.396|
;;;477      }
;;;478      
;;;479      return HAL_OK;
;;;480    }
00018c  bc10              POP      {r4}
00018e  f04f0000          MOV      r0,#0                 ;479
000192  4770              BX       lr
;;;481    
                          ENDP

                  FSMC_NAND_CommonSpace_Timing_Init PROC
;;;489      */
;;;490    HAL_StatusTypeDef FSMC_NAND_CommonSpace_Timing_Init(FSMC_NAND_TypeDef *Device, FSMC_NAND_PCC_TimingTypeDef *Timing, uint32_t Bank)
000194  2a10              CMP      r2,#0x10
;;;491    {
;;;492      uint32_t tmpr = 0;  
;;;493      
;;;494      /* Check the parameters */
;;;495      assert_param(IS_FSMC_SETUP_TIME(Timing->SetupTime));
;;;496      assert_param(IS_FSMC_WAIT_TIME(Timing->WaitSetupTime));
;;;497      assert_param(IS_FSMC_HOLD_TIME(Timing->HoldSetupTime));
;;;498      assert_param(IS_FSMC_HIZ_TIME(Timing->HiZSetupTime));
;;;499      
;;;500      if(Bank == FSMC_NAND_BANK2)
000196  d00f              BEQ      |L1.440|
;;;501      {
;;;502        /* Get the NAND bank 2 register value */
;;;503        tmpr = Device->PMEM2;
;;;504      }
;;;505      else
;;;506      {
;;;507        /* Get the NAND bank 3 register value */
;;;508        tmpr = Device->PMEM3;
000198  6a82              LDR      r2,[r0,#0x28]
                  |L1.410|
;;;509      } 
;;;510      
;;;511      /* Clear MEMSETx, MEMWAITx, MEMHOLDx and MEMHIZx bits */
;;;512      tmpr &= ((uint32_t)~(FSMC_PMEM2_MEMSET2  | FSMC_PMEM2_MEMWAIT2 | FSMC_PMEM2_MEMHOLD2 | \
;;;513                           FSMC_PMEM2_MEMHIZ2));
;;;514      
;;;515      /* Set FSMC_NAND device timing parameters */
;;;516      tmpr |= (uint32_t)(Timing->SetupTime                  |\
00019a  684b              LDR      r3,[r1,#4]
00019c  680a              LDR      r2,[r1,#0]
00019e  ea422203          ORR      r2,r2,r3,LSL #8
0001a2  890b              LDRH     r3,[r1,#8]
0001a4  7b09              LDRB     r1,[r1,#0xc]
0001a6  ea4f4303          LSL      r3,r3,#16
0001aa  ea436101          ORR      r1,r3,r1,LSL #24
0001ae  ea420101          ORR      r1,r2,r1
;;;517                           ((Timing->WaitSetupTime) << 8)     |\
;;;518                           ((Timing->HoldSetupTime) << 16)    |\
;;;519                           ((Timing->HiZSetupTime) << 24)
;;;520                           );
;;;521                                
;;;522      if(Bank == FSMC_NAND_BANK2)
0001b2  d103              BNE      |L1.444|
;;;523      {
;;;524        /* NAND bank 2 registers configuration */
;;;525        Device->PMEM2 = tmpr;
0001b4  6081              STR      r1,[r0,#8]
0001b6  e002              B        |L1.446|
                  |L1.440|
0001b8  6882              LDR      r2,[r0,#8]            ;503
0001ba  e7ee              B        |L1.410|
                  |L1.444|
;;;526      }
;;;527      else
;;;528      {
;;;529        /* NAND bank 3 registers configuration */
;;;530        Device->PMEM3 = tmpr;
0001bc  6281              STR      r1,[r0,#0x28]
                  |L1.446|
;;;531      }  
;;;532      
;;;533      return HAL_OK;  
0001be  f04f0000          MOV      r0,#0
;;;534    }
0001c2  4770              BX       lr
;;;535    
                          ENDP

                  FSMC_NAND_AttributeSpace_Timing_Init PROC
;;;543      */
;;;544    HAL_StatusTypeDef FSMC_NAND_AttributeSpace_Timing_Init(FSMC_NAND_TypeDef *Device, FSMC_NAND_PCC_TimingTypeDef *Timing, uint32_t Bank)
0001c4  2a10              CMP      r2,#0x10
;;;545    {
;;;546      uint32_t tmpr = 0;  
;;;547      
;;;548      /* Check the parameters */  
;;;549      assert_param(IS_FSMC_SETUP_TIME(Timing->SetupTime));
;;;550      assert_param(IS_FSMC_WAIT_TIME(Timing->WaitSetupTime));
;;;551      assert_param(IS_FSMC_HOLD_TIME(Timing->HoldSetupTime));
;;;552      assert_param(IS_FSMC_HIZ_TIME(Timing->HiZSetupTime));
;;;553      
;;;554      if(Bank == FSMC_NAND_BANK2)
0001c6  d00f              BEQ      |L1.488|
;;;555      {
;;;556        /* Get the NAND bank 2 register value */
;;;557        tmpr = Device->PATT2;
;;;558      }
;;;559      else
;;;560      {
;;;561        /* Get the NAND bank 3 register value */
;;;562        tmpr = Device->PATT3;
0001c8  6ac2              LDR      r2,[r0,#0x2c]
                  |L1.458|
;;;563      } 
;;;564      
;;;565      /* Clear ATTSETx, ATTWAITx, ATTHOLDx and ATTHIZx bits */
;;;566      tmpr &= ((uint32_t)~(FSMC_PATT2_ATTSET2  | FSMC_PATT2_ATTWAIT2 | FSMC_PATT2_ATTHOLD2 | \
;;;567                           FSMC_PATT2_ATTHIZ2));
;;;568      
;;;569      /* Set FSMC_NAND device timing parameters */
;;;570      tmpr |= (uint32_t)(Timing->SetupTime                  |\
0001ca  684b              LDR      r3,[r1,#4]
0001cc  680a              LDR      r2,[r1,#0]
0001ce  ea422203          ORR      r2,r2,r3,LSL #8
0001d2  890b              LDRH     r3,[r1,#8]
0001d4  7b09              LDRB     r1,[r1,#0xc]
0001d6  ea4f4303          LSL      r3,r3,#16
0001da  ea436101          ORR      r1,r3,r1,LSL #24
0001de  ea420101          ORR      r1,r2,r1
;;;571                           ((Timing->WaitSetupTime) << 8)     |\
;;;572                           ((Timing->HoldSetupTime) << 16)    |\
;;;573                           ((Timing->HiZSetupTime) << 24)
;;;574                           );
;;;575                           
;;;576      if(Bank == FSMC_NAND_BANK2)
0001e2  d103              BNE      |L1.492|
;;;577      {
;;;578        /* NAND bank 2 registers configuration */
;;;579        Device->PATT2 = tmpr;
0001e4  60c1              STR      r1,[r0,#0xc]
0001e6  e002              B        |L1.494|
                  |L1.488|
0001e8  68c2              LDR      r2,[r0,#0xc]          ;557
0001ea  e7ee              B        |L1.458|
                  |L1.492|
;;;580      }
;;;581      else
;;;582      {
;;;583        /* NAND bank 3 registers configuration */
;;;584        Device->PATT3 = tmpr;
0001ec  62c1              STR      r1,[r0,#0x2c]
                  |L1.494|
;;;585      }   
;;;586      
;;;587      return HAL_OK;
0001ee  f04f0000          MOV      r0,#0
;;;588    }
0001f2  4770              BX       lr
;;;589    
                          ENDP

                  FSMC_NAND_DeInit PROC
;;;595      */
;;;596    HAL_StatusTypeDef FSMC_NAND_DeInit(FSMC_NAND_TypeDef *Device, uint32_t Bank)
0001f4  2318              MOVS     r3,#0x18
;;;597    {
;;;598      /* Disable the NAND Bank */
;;;599      __FSMC_NAND_DISABLE(Device, Bank);
;;;600     
;;;601      /* De-initialize the NAND Bank */
;;;602      if(Bank == FSMC_NAND_BANK2)
;;;603      {
;;;604        /* Set the FSMC_NAND_BANK2 registers to their reset values */
;;;605        Device->PCR2  = 0x00000018;
;;;606        Device->SR2   = 0x00000040;
0001f6  f04f0c40          MOV      r12,#0x40
;;;607        Device->PMEM2 = 0xFCFCFCFC;
0001fa  f04f32fc          MOV      r2,#0xfcfcfcfc
0001fe  2910              CMP      r1,#0x10              ;599
000200  d00a              BEQ      |L1.536|
000202  6a01              LDR      r1,[r0,#0x20]         ;599
000204  f0210104          BIC      r1,r1,#4              ;599
000208  6201              STR      r1,[r0,#0x20]         ;599
                  |L1.522|
00020a  d10a              BNE      |L1.546|
00020c  6003              STR      r3,[r0,#0]            ;605
00020e  f8c0c004          STR      r12,[r0,#4]           ;606
000212  6082              STR      r2,[r0,#8]
;;;608        Device->PATT2 = 0xFCFCFCFC;  
000214  60c2              STR      r2,[r0,#0xc]
000216  e009              B        |L1.556|
                  |L1.536|
000218  6801              LDR      r1,[r0,#0]            ;599
00021a  f0210104          BIC      r1,r1,#4              ;599
00021e  6001              STR      r1,[r0,#0]            ;599
000220  e7f3              B        |L1.522|
                  |L1.546|
;;;609      }
;;;610      /* FSMC_Bank3_NAND */  
;;;611      else
;;;612      {
;;;613        /* Set the FSMC_NAND_BANK3 registers to their reset values */
;;;614        Device->PCR3  = 0x00000018;
000222  6203              STR      r3,[r0,#0x20]
;;;615        Device->SR3   = 0x00000040;
000224  f8c0c024          STR      r12,[r0,#0x24]
;;;616        Device->PMEM3 = 0xFCFCFCFC;
000228  6282              STR      r2,[r0,#0x28]
;;;617        Device->PATT3 = 0xFCFCFCFC; 
00022a  62c2              STR      r2,[r0,#0x2c]
                  |L1.556|
;;;618      }
;;;619      
;;;620      return HAL_OK;
00022c  f04f0000          MOV      r0,#0
;;;621    }
000230  4770              BX       lr
;;;622    /**
                          ENDP

                  FSMC_NAND_ECC_Enable PROC
;;;646      */    
;;;647    HAL_StatusTypeDef  FSMC_NAND_ECC_Enable(FSMC_NAND_TypeDef *Device, uint32_t Bank)
000232  2910              CMP      r1,#0x10
;;;648    {
000234  d005              BEQ      |L1.578|
;;;649      /* Enable ECC feature */
;;;650      if(Bank == FSMC_NAND_BANK2)
;;;651      {
;;;652        Device->PCR2 |= FSMC_PCR2_ECCEN;
;;;653      }
;;;654      else
;;;655      {
;;;656        Device->PCR3 |= FSMC_PCR3_ECCEN;
000236  6a01              LDR      r1,[r0,#0x20]
000238  f0410140          ORR      r1,r1,#0x40
00023c  6201              STR      r1,[r0,#0x20]
                  |L1.574|
;;;657      } 
;;;658      
;;;659      return HAL_OK;  
00023e  2000              MOVS     r0,#0
;;;660    }
000240  4770              BX       lr
                  |L1.578|
000242  6801              LDR      r1,[r0,#0]            ;652
000244  f0410140          ORR      r1,r1,#0x40           ;652
000248  6001              STR      r1,[r0,#0]            ;652
00024a  e7f8              B        |L1.574|
;;;661    
                          ENDP

                  FSMC_NAND_ECC_Disable PROC
;;;667      */  
;;;668    HAL_StatusTypeDef FSMC_NAND_ECC_Disable(FSMC_NAND_TypeDef *Device, uint32_t Bank)  
00024c  2910              CMP      r1,#0x10
;;;669    {  
00024e  d005              BEQ      |L1.604|
;;;670      /* Disable ECC feature */
;;;671      if(Bank == FSMC_NAND_BANK2)
;;;672      {
;;;673        Device->PCR2 &= ~FSMC_PCR2_ECCEN;
;;;674      }
;;;675      else
;;;676      {
;;;677        Device->PCR3 &= ~FSMC_PCR3_ECCEN;
000250  6a01              LDR      r1,[r0,#0x20]
000252  f0210140          BIC      r1,r1,#0x40
000256  6201              STR      r1,[r0,#0x20]
                  |L1.600|
;;;678      } 
;;;679    
;;;680      return HAL_OK;  
000258  2000              MOVS     r0,#0
;;;681    }
00025a  4770              BX       lr
                  |L1.604|
00025c  6801              LDR      r1,[r0,#0]            ;673
00025e  f0210140          BIC      r1,r1,#0x40           ;673
000262  6001              STR      r1,[r0,#0]            ;673
000264  e7f8              B        |L1.600|
;;;682    
                          ENDP

                  FSMC_NAND_GetECC PROC
;;;690      */
;;;691    HAL_StatusTypeDef FSMC_NAND_GetECC(FSMC_NAND_TypeDef *Device, uint32_t *ECCval, uint32_t Bank, uint32_t Timeout)
000266  e92d41f0          PUSH     {r4-r8,lr}
;;;692    {
00026a  4604              MOV      r4,r0
00026c  4688              MOV      r8,r1
00026e  4616              MOV      r6,r2
000270  461d              MOV      r5,r3
;;;693      uint32_t tickstart = 0;
;;;694      
;;;695      /* Check the parameters */ 
;;;696      assert_param(IS_FSMC_NAND_DEVICE(Device)); 
;;;697      assert_param(IS_FSMC_NAND_BANK(Bank));
;;;698    
;;;699      /* Get tick */ 
;;;700      tickstart = HAL_GetTick();
000272  f7fffffe          BL       HAL_GetTick
000276  4607              MOV      r7,r0
;;;701    
;;;702      /* Wait until FIFO is empty */
;;;703      while(__FSMC_NAND_GET_FLAG(Device, Bank, FSMC_FLAG_FEMPT) == RESET)
000278  2e10              CMP      r6,#0x10
00027a  d004              BEQ      |L1.646|
00027c  6a60              LDR      r0,[r4,#0x24]
00027e  f3c01080          UBFX     r0,r0,#6,#1
                  |L1.642|
000282  b120              CBZ      r0,|L1.654|
000284  e016              B        |L1.692|
                  |L1.646|
000286  6860              LDR      r0,[r4,#4]
000288  f3c01080          UBFX     r0,r0,#6,#1
00028c  e7f9              B        |L1.642|
                  |L1.654|
;;;704      {
;;;705        /* Check for the Timeout */
;;;706        if(Timeout != HAL_MAX_DELAY)
00028e  f1b53fff          CMP      r5,#0xffffffff
000292  d008              BEQ      |L1.678|
;;;707        {
;;;708          if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
000294  b125              CBZ      r5,|L1.672|
000296  f7fffffe          BL       HAL_GetTick
00029a  1bc0              SUBS     r0,r0,r7
00029c  42a8              CMP      r0,r5
00029e  d902              BLS      |L1.678|
                  |L1.672|
;;;709          {
;;;710            return HAL_TIMEOUT;
0002a0  2003              MOVS     r0,#3
;;;711          }
;;;712        }   
;;;713      }
;;;714         
;;;715      if(Bank == FSMC_NAND_BANK2)
;;;716      {    
;;;717        /* Get the ECCR2 register value */
;;;718        *ECCval = (uint32_t)Device->ECCR2;
;;;719      }
;;;720      else
;;;721      {    
;;;722        /* Get the ECCR3 register value */
;;;723        *ECCval = (uint32_t)Device->ECCR3;
;;;724      }
;;;725    
;;;726      return HAL_OK;  
;;;727    }
0002a2  e8bd81f0          POP      {r4-r8,pc}
                  |L1.678|
0002a6  2e10              CMP      r6,#0x10              ;703
0002a8  d00c              BEQ      |L1.708|
0002aa  6a60              LDR      r0,[r4,#0x24]         ;703
0002ac  f3c01080          UBFX     r0,r0,#6,#1           ;703
                  |L1.688|
0002b0  2800              CMP      r0,#0                 ;703
0002b2  d0ec              BEQ      |L1.654|
                  |L1.692|
0002b4  2e10              CMP      r6,#0x10              ;715
0002b6  d009              BEQ      |L1.716|
0002b8  6b60              LDR      r0,[r4,#0x34]         ;723
0002ba  f8c80000          STR      r0,[r8,#0]            ;723
                  |L1.702|
0002be  2000              MOVS     r0,#0                 ;726
0002c0  e8bd81f0          POP      {r4-r8,pc}
                  |L1.708|
0002c4  6860              LDR      r0,[r4,#4]            ;703
0002c6  f3c01080          UBFX     r0,r0,#6,#1           ;703
0002ca  e7f1              B        |L1.688|
                  |L1.716|
0002cc  6960              LDR      r0,[r4,#0x14]         ;718
0002ce  f8c80000          STR      r0,[r8,#0]            ;718
0002d2  e7f4              B        |L1.702|
;;;728    
                          ENDP

                  FSMC_PCCARD_Init PROC
;;;784      */
;;;785    HAL_StatusTypeDef FSMC_PCCARD_Init(FSMC_PCCARD_TypeDef *Device, FSMC_PCCARD_InitTypeDef *Init)
0002d4  6802              LDR      r2,[r0,#0]
;;;786    {
;;;787      uint32_t tmpr = 0;
;;;788      
;;;789      /* Check the parameters */ 
;;;790      assert_param(IS_FSMC_WAIT_FEATURE(Init->Waitfeature));
;;;791      assert_param(IS_FSMC_TCLR_TIME(Init->TCLRSetupTime));
;;;792      assert_param(IS_FSMC_TAR_TIME(Init->TARSetupTime));     
;;;793      
;;;794      /* Get PCCARD control register value */
;;;795      tmpr = Device->PCR4;
;;;796      
;;;797      /* Clear TAR, TCLR, PWAITEN and PWID bits */
;;;798      tmpr &= ((uint32_t)~(FSMC_PCR4_TAR  | FSMC_PCR4_TCLR | FSMC_PCR4_PWAITEN | \
0002d6  f0220232          BIC      r2,r2,#0x32
0002da  f42232ff          BIC      r2,r2,#0x1fe00
;;;799                           FSMC_PCR4_PWID));
;;;800      
;;;801      /* Set FSMC_PCCARD device control parameters */
;;;802      tmpr |= (uint32_t)(Init->Waitfeature               |\
0002de  684b              LDR      r3,[r1,#4]
0002e0  f8d1c008          LDR      r12,[r1,#8]
0002e4  6809              LDR      r1,[r1,#0]
0002e6  025b              LSLS     r3,r3,#9
0002e8  ea43334c          ORR      r3,r3,r12,LSL #13
0002ec  4311              ORRS     r1,r1,r2
0002ee  4319              ORRS     r1,r1,r3
0002f0  f0410110          ORR      r1,r1,#0x10
;;;803                         FSMC_NAND_PCC_MEM_BUS_WIDTH_16  |\
;;;804                         (Init->TCLRSetupTime << 9)      |\
;;;805                         (Init->TARSetupTime << 13));
;;;806      
;;;807      Device->PCR4 = tmpr;
0002f4  6001              STR      r1,[r0,#0]
;;;808      
;;;809      return HAL_OK;
0002f6  2000              MOVS     r0,#0
;;;810    }
0002f8  4770              BX       lr
;;;811    
                          ENDP

                  FSMC_PCCARD_CommonSpace_Timing_Init PROC
;;;818      */
;;;819    HAL_StatusTypeDef FSMC_PCCARD_CommonSpace_Timing_Init(FSMC_PCCARD_TypeDef *Device, FSMC_NAND_PCC_TimingTypeDef *Timing)
0002fa  6882              LDR      r2,[r0,#8]
;;;820    {
;;;821      uint32_t tmpr = 0;
;;;822      
;;;823      /* Check the parameters */
;;;824      assert_param(IS_FSMC_SETUP_TIME(Timing->SetupTime));
;;;825      assert_param(IS_FSMC_WAIT_TIME(Timing->WaitSetupTime));
;;;826      assert_param(IS_FSMC_HOLD_TIME(Timing->HoldSetupTime));
;;;827      assert_param(IS_FSMC_HIZ_TIME(Timing->HiZSetupTime));
;;;828    
;;;829      /* Get PCCARD common space timing register value */
;;;830      tmpr = Device->PMEM4;
;;;831      
;;;832      /* Clear MEMSETx, MEMWAITx, MEMHOLDx and MEMHIZx bits */
;;;833      tmpr &= ((uint32_t)~(FSMC_PMEM4_MEMSET4  | FSMC_PMEM4_MEMWAIT4 | FSMC_PMEM4_MEMHOLD4 | \
;;;834                           FSMC_PMEM4_MEMHIZ4));
;;;835      /* Set PCCARD timing parameters */
;;;836      tmpr |= (uint32_t)((Timing->SetupTime                 |\
0002fc  684b              LDR      r3,[r1,#4]
0002fe  680a              LDR      r2,[r1,#0]
000300  ea422203          ORR      r2,r2,r3,LSL #8
000304  890b              LDRH     r3,[r1,#8]
000306  7b09              LDRB     r1,[r1,#0xc]
000308  041b              LSLS     r3,r3,#16
00030a  ea436101          ORR      r1,r3,r1,LSL #24
00030e  4311              ORRS     r1,r1,r2
;;;837                        ((Timing->WaitSetupTime) << 8)     |\
;;;838                        (Timing->HoldSetupTime) << 16)    |\
;;;839                        ((Timing->HiZSetupTime) << 24));
;;;840      
;;;841      Device->PMEM4 = tmpr;
000310  6081              STR      r1,[r0,#8]
;;;842      
;;;843      return HAL_OK;  
000312  2000              MOVS     r0,#0
;;;844    }
000314  4770              BX       lr
;;;845    
                          ENDP

                  FSMC_PCCARD_AttributeSpace_Timing_Init PROC
;;;852      */
;;;853    HAL_StatusTypeDef FSMC_PCCARD_AttributeSpace_Timing_Init(FSMC_PCCARD_TypeDef *Device, FSMC_NAND_PCC_TimingTypeDef *Timing)
000316  68c2              LDR      r2,[r0,#0xc]
;;;854    {
;;;855      uint32_t tmpr = 0;
;;;856    
;;;857      /* Check the parameters */  
;;;858      assert_param(IS_FSMC_SETUP_TIME(Timing->SetupTime));
;;;859      assert_param(IS_FSMC_WAIT_TIME(Timing->WaitSetupTime));
;;;860      assert_param(IS_FSMC_HOLD_TIME(Timing->HoldSetupTime));
;;;861      assert_param(IS_FSMC_HIZ_TIME(Timing->HiZSetupTime));
;;;862    
;;;863      /* Get PCCARD timing parameters */
;;;864      tmpr = Device->PATT4;
;;;865    
;;;866      /* Clear ATTSETx, ATTWAITx, ATTHOLDx and ATTHIZx bits */
;;;867      tmpr &= ((uint32_t)~(FSMC_PATT4_ATTSET4  | FSMC_PATT4_ATTWAIT4 | FSMC_PATT4_ATTHOLD4 | \
;;;868                           FSMC_PATT4_ATTHIZ4));
;;;869      
;;;870      /* Set PCCARD timing parameters */
;;;871      tmpr |= (uint32_t)(Timing->SetupTime                |\
000318  684b              LDR      r3,[r1,#4]
00031a  680a              LDR      r2,[r1,#0]
00031c  ea422203          ORR      r2,r2,r3,LSL #8
000320  890b              LDRH     r3,[r1,#8]
000322  7b09              LDRB     r1,[r1,#0xc]
000324  041b              LSLS     r3,r3,#16
000326  ea436101          ORR      r1,r3,r1,LSL #24
00032a  4311              ORRS     r1,r1,r2
;;;872                       ((Timing->WaitSetupTime) << 8)     |\
;;;873                       ((Timing->HoldSetupTime) << 16)    |\
;;;874                       ((Timing->HiZSetupTime) << 24));
;;;875      Device->PATT4 = tmpr; 
00032c  60c1              STR      r1,[r0,#0xc]
;;;876                                            
;;;877      return HAL_OK;
00032e  2000              MOVS     r0,#0
;;;878    }
000330  4770              BX       lr
;;;879    
                          ENDP

                  FSMC_PCCARD_IOSpace_Timing_Init PROC
;;;886      */
;;;887    HAL_StatusTypeDef FSMC_PCCARD_IOSpace_Timing_Init(FSMC_PCCARD_TypeDef *Device, FSMC_NAND_PCC_TimingTypeDef *Timing)
000332  6902              LDR      r2,[r0,#0x10]
;;;888    {
;;;889      uint32_t tmpr = 0;
;;;890      
;;;891      /* Check the parameters */  
;;;892      assert_param(IS_FSMC_SETUP_TIME(Timing->SetupTime));
;;;893      assert_param(IS_FSMC_WAIT_TIME(Timing->WaitSetupTime));
;;;894      assert_param(IS_FSMC_HOLD_TIME(Timing->HoldSetupTime));
;;;895      assert_param(IS_FSMC_HIZ_TIME(Timing->HiZSetupTime));
;;;896    
;;;897      /* Get FSMC_PCCARD device timing parameters */
;;;898      tmpr = Device->PIO4;
;;;899    
;;;900      /* Clear IOSET4, IOWAIT4, IOHOLD4 and IOHIZ4 bits */
;;;901      tmpr &= ((uint32_t)~(FSMC_PIO4_IOSET4  | FSMC_PIO4_IOWAIT4 | FSMC_PIO4_IOHOLD4 | \
;;;902                           FSMC_PIO4_IOHIZ4));
;;;903      
;;;904      /* Set FSMC_PCCARD device timing parameters */
;;;905      tmpr |= (uint32_t)(Timing->SetupTime                  |\
000334  684b              LDR      r3,[r1,#4]
000336  680a              LDR      r2,[r1,#0]
000338  ea422203          ORR      r2,r2,r3,LSL #8
00033c  890b              LDRH     r3,[r1,#8]
00033e  7b09              LDRB     r1,[r1,#0xc]
000340  041b              LSLS     r3,r3,#16
000342  ea436101          ORR      r1,r3,r1,LSL #24
000346  4311              ORRS     r1,r1,r2
;;;906                         ((Timing->WaitSetupTime) << 8)     |\
;;;907                         ((Timing->HoldSetupTime) << 16)    |\
;;;908                         ((Timing->HiZSetupTime) << 24));   
;;;909      
;;;910      Device->PIO4 = tmpr;
000348  6101              STR      r1,[r0,#0x10]
;;;911      
;;;912      return HAL_OK;
00034a  2000              MOVS     r0,#0
;;;913    }
00034c  4770              BX       lr
;;;914                                               
                          ENDP

                  FSMC_PCCARD_DeInit PROC
;;;919      */
;;;920    HAL_StatusTypeDef FSMC_PCCARD_DeInit(FSMC_PCCARD_TypeDef *Device)
00034e  6801              LDR      r1,[r0,#0]
;;;921    {
;;;922      /* Disable the FSMC_PCCARD device */
;;;923      __FSMC_PCCARD_DISABLE(Device);
000350  f0210104          BIC      r1,r1,#4
000354  6001              STR      r1,[r0,#0]
;;;924      
;;;925      /* De-initialize the FSMC_PCCARD device */
;;;926      Device->PCR4    = 0x00000018; 
000356  2118              MOVS     r1,#0x18
000358  6001              STR      r1,[r0,#0]
;;;927      Device->SR4     = 0x00000000;	
00035a  2100              MOVS     r1,#0
00035c  6041              STR      r1,[r0,#4]
;;;928      Device->PMEM4   = 0xFCFCFCFC;
00035e  f04f31fc          MOV      r1,#0xfcfcfcfc
000362  6081              STR      r1,[r0,#8]
;;;929      Device->PATT4   = 0xFCFCFCFC;
000364  60c1              STR      r1,[r0,#0xc]
;;;930      Device->PIO4    = 0xFCFCFCFC;
000366  6101              STR      r1,[r0,#0x10]
;;;931      
;;;932      return HAL_OK;
000368  2000              MOVS     r0,#0
;;;933    }
00036a  4770              BX       lr
;;;934    /**
                          ENDP

                  |L1.876|
                          DCD      0xfff70080
                  |L1.880|
                          DCD      0xfff00181

                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001

;*** Start embedded assembler ***

#line 1 "drivers\\src\\stm32f4xx_ll_fsmc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_ll_fsmc_c_26ff9b41___Z7__REV16j|
#line 138 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.3.0\\CMSIS\\Include\\core_cmInstr.h"
|__asm___19_stm32f4xx_ll_fsmc_c_26ff9b41___Z7__REV16j| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_ll_fsmc_c_26ff9b41___Z7__REVSHi|
#line 153
|__asm___19_stm32f4xx_ll_fsmc_c_26ff9b41___Z7__REVSHi| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_ll_fsmc_c_26ff9b41___Z5__RRXj|
#line 328
|__asm___19_stm32f4xx_ll_fsmc_c_26ff9b41___Z5__RRXj| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
