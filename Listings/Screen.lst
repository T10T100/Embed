L 1 "device\GUI\src\Screen.cpp"
N#include "Screen.h"
L 1 ".\device\GUI\inc\Screen.h" 1
N#ifndef SCREEN_H
N#define SCREEN_H
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5050106
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
N      namespace std {
N          #define __CLIBNS std::
N          extern "C" {
N    #else
S      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !1L || 0L
S
S    /* 7.18.2.1 */
S
S    /* minimum values of exact-width signed integer types */
S#define INT8_MIN                   -128
S#define INT16_MIN                -32768
S#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
S#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
S
S    /* maximum values of exact-width signed integer types */
S#define INT8_MAX                    127
S#define INT16_MAX                 32767
S#define INT32_MAX            2147483647
S#define INT64_MAX  __INT64_C(9223372036854775807)
S
S    /* maximum values of exact-width unsigned integer types */
S#define UINT8_MAX                   255
S#define UINT16_MAX                65535
S#define UINT32_MAX           4294967295u
S#define UINT64_MAX __UINT64_C(18446744073709551615)
S
S    /* 7.18.2.2 */
S
S    /* minimum values of minimum-width signed integer types */
S#define INT_LEAST8_MIN                   -128
S#define INT_LEAST16_MIN                -32768
S#define INT_LEAST32_MIN          (~0x7fffffff)
S#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
S
S    /* maximum values of minimum-width signed integer types */
S#define INT_LEAST8_MAX                    127
S#define INT_LEAST16_MAX                 32767
S#define INT_LEAST32_MAX            2147483647
S#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
S
S    /* maximum values of minimum-width unsigned integer types */
S#define UINT_LEAST8_MAX                   255
S#define UINT_LEAST16_MAX                65535
S#define UINT_LEAST32_MAX           4294967295u
S#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
S
S    /* 7.18.2.3 */
S
S    /* minimum values of fastest minimum-width signed integer types */
S#define INT_FAST8_MIN           (~0x7fffffff)
S#define INT_FAST16_MIN          (~0x7fffffff)
S#define INT_FAST32_MIN          (~0x7fffffff)
S#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
S
S    /* maximum values of fastest minimum-width signed integer types */
S#define INT_FAST8_MAX             2147483647
S#define INT_FAST16_MAX            2147483647
S#define INT_FAST32_MAX            2147483647
S#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
S
S    /* maximum values of fastest minimum-width unsigned integer types */
S#define UINT_FAST8_MAX            4294967295u
S#define UINT_FAST16_MAX           4294967295u
S#define UINT_FAST32_MAX           4294967295u
S#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
S
S    /* 7.18.2.4 */
S
S    /* minimum value of pointer-holding signed integer type */
S#if __sizeof_ptr == 8
S#define INTPTR_MIN INT64_MIN
S#else
S#define INTPTR_MIN INT32_MIN
S#endif
S
S    /* maximum value of pointer-holding signed integer type */
S#if __sizeof_ptr == 8
S#define INTPTR_MAX INT64_MAX
S#else
S#define INTPTR_MAX INT32_MAX
S#endif
S
S    /* maximum value of pointer-holding unsigned integer type */
S#if __sizeof_ptr == 8
S#define UINTPTR_MAX INT64_MAX
S#else
S#define UINTPTR_MAX INT32_MAX
S#endif
S
S    /* 7.18.2.5 */
S
S    /* minimum value of greatest-width signed integer type */
S#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
S
S    /* maximum value of greatest-width signed integer type */
S#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
S
S    /* maximum value of greatest-width unsigned integer type */
S#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
S
S    /* 7.18.3 */
S
S    /* limits of ptrdiff_t */
S#if __sizeof_ptr == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
S#else
S#define PTRDIFF_MIN INT32_MIN
S#define PTRDIFF_MAX INT32_MAX
S#endif
S
S    /* limits of sig_atomic_t */
S#define SIG_ATOMIC_MIN (~0x7fffffff)
S#define SIG_ATOMIC_MAX   2147483647
S
S    /* limit of size_t */
S#if __sizeof_ptr == 8
S#define SIZE_MAX UINT64_MAX
S#else
S#define SIZE_MAX UINT32_MAX
S#endif
S
S    /* limits of wchar_t */
S    /* NB we have to undef and redef because they're defined in both
S     * stdint.h and wchar.h */
S#undef WCHAR_MIN
S#undef WCHAR_MAX
S
S#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
S#else
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   65535
S#endif
S
S    /* limits of wint_t */
S#define WINT_MIN (~0x7fffffff)
S#define WINT_MAX 2147483647
S
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !1L || 0L
S
S    /* 7.18.4.1 macros for minimum-width integer constants */
S#define INT8_C(x)   (x)
S#define INT16_C(x)  (x)
S#define INT32_C(x)  (x)
S#define INT64_C(x)  __INT64_C(x)
S
S#define UINT8_C(x)  (x ## u)
S#define UINT16_C(x) (x ## u)
S#define UINT32_C(x) (x ## u)
S#define UINT64_C(x) __UINT64_C(x)
S
S    /* 7.18.4.2 macros for greatest-width integer constants */
S#define INTMAX_C(x)  __ESCAPE__(x ## ll)
S#define UINTMAX_C(x) __ESCAPE__(x ## ull)
S
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
N         }  /* extern "C" */
N      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
N    #ifndef __STDINT_NO_EXPORTS
N      using ::std::int8_t;
N      using ::std::int16_t;
N      using ::std::int32_t;
N      using ::std::int64_t;
N      using ::std::uint8_t;
N      using ::std::uint16_t;
N      using ::std::uint32_t;
N      using ::std::uint64_t;
N      using ::std::int_least8_t;
N      using ::std::int_least16_t;
N      using ::std::int_least32_t;
N      using ::std::int_least64_t;
N      using ::std::uint_least8_t;
N      using ::std::uint_least16_t;
N      using ::std::uint_least32_t;
N      using ::std::uint_least64_t;
N      using ::std::int_fast8_t;
N      using ::std::int_fast16_t;
N      using ::std::int_fast32_t;
N      using ::std::int_fast64_t;
N      using ::std::uint_fast8_t;
N      using ::std::uint_fast16_t;
N      using ::std::uint_fast32_t;
N      using ::std::uint_fast64_t;
N      using ::std::intptr_t;
N      using ::std::uintptr_t;
N      using ::std::intmax_t;
N      using ::std::uintmax_t;
N    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 5 ".\device\GUI\inc\Screen.h" 2
N#include "memory_template.h"
L 1 ".\memory\inc\memory_template.h" 1
N#ifndef MEMORY_TEMPLATE_CPP
N#define MEMORY_TEMPLATE_CPP
N
N#include <stdint.h>
N
Ntemplate <typename native>
Nclass Allocator {
N  public:
N    /*
N    Allocator ();
N    ~Allocator ();
N    */
N  template <typename Obj>
N    Obj *New ();
N
N  template <typename Obj>
N    Obj *New (uint32_t); 
N	
N	template <typename Obj>
N    Obj *NewArray (uint32_t);
N	
N	template <typename Obj>
N    Obj **NewlArray (uint32_t);
N
N  template <typename Obj>
N    int32_t Delete (Obj *); 
N	
N    native *New ();
N    native *New (uint32_t); 
N	  native *NewArray (uint32_t);
N	  native **NewlArray (uint32_t);
N  
N  private:     
N};
N
Nvoid *Alloc (uint32_t);
Nint32_t Free (void *); 
N
N/*
NAllocator::Allocator () {}
NAllocator::~Allocator() {}
N*/
N
Ntemplate <typename native>
Ntemplate <typename Obj>
N  Obj *Allocator<native>::New ()
N{
N  return (Obj *)Alloc (sizeof(Obj));
N}
N
Ntemplate <typename native>
Ntemplate <typename Obj>
N  Obj *Allocator<native>::New (uint32_t size)
N{
N  return (Obj *)Alloc (sizeof(Obj) + size);
N}
N
Ntemplate <typename native>
Ntemplate <typename Obj>
N  Obj *Allocator<native>::NewArray (uint32_t size)
N{
N  return (Obj *)Alloc (sizeof(Obj) * size);
N}
N
Ntemplate <typename native>
Ntemplate <typename Obj>
N  Obj **Allocator<native>::NewlArray (uint32_t size)
N{
N  return (Obj **)Alloc (sizeof(Obj *) * size);
N}
N
Ntemplate <typename native>
Ntemplate <typename Obj>
N  int32_t Allocator<native>::Delete (Obj *o)
N{
N  return Free(static_cast<void *>(o)); 
N}
N
Ntemplate <typename native>
N  native *Allocator<native>::New ()
N{
N  return (native *)Alloc (sizeof(native));
N}
N
Ntemplate <typename native>
N  native *Allocator<native>::New (uint32_t size)
N{
N  return (native *)Alloc (sizeof(native) + size);
N}
N
Ntemplate <typename native>
N  native *Allocator<native>::NewArray (uint32_t size)
N{
N  return (native *)Alloc (sizeof(native) * size);
N}
N
N
Ntemplate <typename native>
N  native **Allocator<native>::NewlArray (uint32_t size)
N{
N  return (native **)Alloc (sizeof(native *) * size);
N}
N
N
N#endif /*MEMORY_TEMPLATE_CPP*/
N
N//extern Allocator RAM;
N
N/*End Of File*/
N
L 6 ".\device\GUI\inc\Screen.h" 2
N#include "Frame_Class.h"
L 1 ".\device\GUI\inc\Frame_Class.h" 1
N#ifndef FRAME_CLASS_H
N#define FRAME_CLASS_H
N
N#include "GUI_defs.h"
L 1 ".\device\GUI\inc\GUI_defs.h" 1
N
N#ifndef GUI_DEFS_H
N#define GUI_DEFS_H
N
N
N#include <stdint.h>
N
N
N#define labs(x) ((int32_t)(x) < 0 ? -(int32_t)(x) : (int32_t)(x))
N#define GUI_min(x, y) ((x) < (y) ? (x) : (y))
N#define GUI_max(x, y) ((x) > (y) ? (x) : (y))
N
N#ifdef ColorDepthBpp1
Stypedef uint8_t ColorTypeDef;
Senum StdPalette {
S	StdColBlack = 0,
S	StdColWhite = 1,
S};
N#endif
N#ifdef ColorDepthBpp4
Stypedef uint8_t ColorTypeDef;
Senum StdPalette {
S	StdColBlack = 0,
S	StdColWhite = 15,
S};
N#endif
N#ifdef ColorDepthBpp8
Stypedef uint8_t ColorTypeDef;
Senum StdPalette {
S	StdColBlack = 0,
S	StdColWhite = 255,
S};
N#endif
N#ifdef ColorDepthBpp16
Ntypedef uint16_t ColorTypeDef;
Nenum StdPalette {
N	StdColBlack = 0,
N	StdColWhite = 65535,
N};
N#endif
N#ifdef ColorDepthBpp24
Stypedef uint32_t ColorTypeDef;
Senum StdPalette {
S	StdColBlack = 0,
S	StdColWhite = (255) | (255 << 8) | (255 << 16),
S};
N#endif
N#ifdef ColorDepthBpp32
Stypedef uint32_t ColorTypeDef;
Senum StdPalette {
S	StdColBlack = 0,
S	StdColWhite = (255) | (255 << 8) | (255 << 16) | (255 << 24),
S};
N#endif
N
Ntypedef struct {
N    const ColorTypeDef *Image;
N    uint16_t W, H;  
N} tImage;
N
Ntypedef struct {
N    ColorTypeDef *Image;
N    uint16_t W, H;  
N} tTexture;
N
Ntypedef struct {
N    const uint8_t Code;
N    const tImage *Image;       
N}tChar ;
N
Ntypedef struct{
N    const uint8_t Quantity;
N    const tChar *CharArray;   
N    const uint8_t W, H;    
N} tFont;
N
N 
N
N
N
N#endif /*GUI_DEFS_H*/
L 5 ".\device\GUI\inc\Frame_Class.h" 2
N#include "geometry.h"
L 1 ".\misc\inc\geometry.h" 1
N
N
N#ifndef GEOMETRY_H
N#define GEOMETRY_H
N#include <stdint.h>
N#include <math.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\math.h" 1
N/*
N * math.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.5
N * Copyright (C) Codemist Ltd., 1988
N * Copyright 1991-1998,2004-2006,2014 ARM Limited. All rights reserved
N */
N
N/*
N * RCS $Revision: 185525 $ Codemist 0.03
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: statham $
N */
N
N/*
N * Parts of this file are based upon fdlibm:
N *
N * ====================================================
N * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
N *
N * Developed at SunSoft, a Sun Microsystems, Inc. business.
N * Permission to use, copy, modify, and distribute this
N * software is freely granted, provided that this notice
N * is preserved.
N * ====================================================
N */
N
N#ifndef __math_h
N#define __math_h
N#define __ARMCLIB_VERSION 5050106
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N/*
N * Some of these declarations are new in C99.  To access them in C++
N * you can use -D__USE_C99_MATH (or -D__USE_C99_ALL).
N */
N#ifndef __USE_C99_MATH
N  #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X  #if 0L || (0L && 199901L <= __STDC_VERSION__)
S    #define __USE_C99_MATH 1
N  #endif
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#ifdef __TARGET_ARCH_AARCH64
S# define _ARMABI_SOFTFP __declspec(__nothrow)
N#else
N# define _ARMABI_SOFTFP __declspec(__nothrow) __attribute__((__pcs__("aapcs")))
N# define __HAVE_LONGDOUBLE 1
N#endif
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#ifdef __FP_FENV_EXCEPTIONS
S# define _ARMABI_FPEXCEPT _ARMABI
N#else
N# define _ARMABI_FPEXCEPT _ARMABI __attribute__((const))
N#endif
N
N#ifdef __cplusplus
N#define _ARMABI_INLINE inline
N#define _ARMABI_INLINE_DEF inline
N#elif defined __GNUC__ || defined _USE_STATIC_INLINE
S#define _ARMABI_INLINE static __inline
S#define _ARMABI_INLINE_DEF static __inline
S#elif (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF static inline
S#else
S#define _ARMABI_INLINE __inline
S#define _ARMABI_INLINE_DEF __inline
N#endif
N
N#ifdef __TARGET_ARCH_AARCH64
S#  define _SOFTFP
N#else
N#  define _SOFTFP __attribute__((__pcs__("aapcs")))
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain the nans function, as well as the
N    * FP_NANS and FP_NANQ classification macros.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
N/*
N * Macros for our inline functions down below.
N * unsigned& __FLT(float x) - returns the bit pattern of x
N * unsigned& __HI(double x) - returns the bit pattern of the high part of x
N *                            (high part has exponent & sign bit in it)
N * unsigned& __LO(double x) - returns the bit pattern of the low part of x
N *
N * We can assign to __FLT, __HI, and __LO and the appropriate bits get set in
N * the floating point variable used.
N *
N * __HI & __LO are affected by the endianness and the target FPU.
N */
N#define __FLT(x) (*(unsigned *)&(x))
N#if defined(__ARM_BIG_ENDIAN) || defined(__BIG_ENDIAN)
X#if 0L || 0L
S#  define __LO(x) (*(1 + (unsigned *)&(x)))
S#  define __HI(x) (*(unsigned *)&(x))
N#else /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N#  define __HI(x) (*(1 + (unsigned *)&(x)))
N#  define __LO(x) (*(unsigned *)&(x))
N#endif /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N
N#   ifndef __MATH_DECLS
N#   define __MATH_DECLS
N
N
N/*
N * A set of functions that we don't actually want to put in the standard
N * namespace ever.  These are all called by the C99 macros.  As they're
N * not specified by any standard they can't belong in ::std::.  The
N * macro #defines are below amongst the standard function declarations.
N * We only include these if we actually need them later on
N */
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N#   ifdef __cplusplus
N      extern "C" {
N#   endif /* __cplusplus */
N
Nextern _SOFTFP unsigned __ARM_dcmp4(double /*x*/, double /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_dcmp4(double  , double  );
Nextern _SOFTFP unsigned __ARM_fcmp4(float /*x*/, float /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_fcmp4(float  , float  );
N    /*
N     * Compare x and y and return the CPSR in r0.  These means we can test for
N     * result types with bit pattern matching.
N     *
N     * These are a copy of the declarations in rt_fp.h keep in sync.
N     */
N
Nextern _ARMABI_SOFTFP int __ARM_fpclassifyf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassifyf(float  );
Nextern _ARMABI_SOFTFP int __ARM_fpclassify(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassify(double  );
N    /* Classify x into NaN, infinite, normal, subnormal, zero */
N    /* Used by fpclassify macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinitef(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinitef(float __x)
N{
N    return ((__FLT(__x) >> 23) & 0xff) != 0xff;
X    return (((*(unsigned *)&(__x)) >> 23) & 0xff) != 0xff;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinite(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinite(double __x)
N{
N    return ((__HI(__x) >> 20) & 0x7ff) != 0x7ff;
X    return (((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff) != 0x7ff;
N}
N    /* Return 1 if __x is finite, 0 otherwise */
N    /* Used by isfinite macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinff(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinff(float __x)
N{
N    return (__FLT(__x) << 1) == 0xff000000;
X    return ((*(unsigned *)&(__x)) << 1) == 0xff000000;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinf(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinf(double __x)
N{
N    return ((__HI(__x) << 1) == 0xffe00000) && (__LO(__x) == 0);
X    return (((*(1 + (unsigned *)&(__x))) << 1) == 0xffe00000) && ((*(unsigned *)&(__x)) == 0);
N}
N    /* Return 1 if __x is infinite, 0 otherwise */
N    /* Used by isinf macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreaterf(float __x, float __y)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreaterf(float __x, float __y)
N{
N    unsigned __f = __ARM_fcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreater(double __x, double __y)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreater(double __x, double __y)
N{
N    unsigned __f = __ARM_dcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N    /*
N     * Compare __x and __y and return 1 if __x < __y or __x > __y, 0 otherwise
N     * Used by islessgreater macro
N     */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnanf(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnanf(float __x)
N{
N    return (0x7f800000 - (__FLT(__x) & 0x7fffffff)) >> 31;
X    return (0x7f800000 - ((*(unsigned *)&(__x)) & 0x7fffffff)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnan(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnan(double __x)
N{
N    unsigned __xf = __HI(__x) | ((__LO(__x) == 0) ? 0 : 1);
X    unsigned __xf = (*(1 + (unsigned *)&(__x))) | (((*(unsigned *)&(__x)) == 0) ? 0 : 1);
N    return (0x7ff00000 - (__xf & 0x7fffffff)) >> 31;
N}
N    /* Return 1 if __x is a NaN, 0 otherwise */
N    /* Used by isnan macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormalf(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormalf(float __x)
N{
N    unsigned __xe = (__FLT(__x) >> 23) & 0xff;
X    unsigned __xe = ((*(unsigned *)&(__x)) >> 23) & 0xff;
N    return (__xe != 0xff) && (__xe != 0);
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormal(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormal(double __x)
N{
N    unsigned __xe = (__HI(__x) >> 20) & 0x7ff;
X    unsigned __xe = ((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff;
N    return (__xe != 0x7ff) && (__xe != 0);
N}
N    /* Return 1 if __x is a normalised number, 0 otherwise */
N    /* used by isnormal macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbitf(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbitf(float __x)
N{
N    return __FLT(__x) >> 31;
X    return (*(unsigned *)&(__x)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbit(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbit(double __x)
N{
N    return __HI(__x) >> 31;
X    return (*(1 + (unsigned *)&(__x))) >> 31;
N}
N    /* Return signbit of __x */
N    /* Used by signbit macro */
N
N#   ifdef __cplusplus
N      } /* extern "C" */
N#   endif /* __cplusplus */
N#endif /* Strict ANSI */
N
N#   undef __CLIBNS
N
N#   ifdef __cplusplus
N      namespace std {
N#       define __CLIBNS ::std::
N        extern "C" {
N#   else
S#       define __CLIBNS
N#   endif  /* __cplusplus */
N
N
N#ifndef __has_builtin
N  #define __has_builtin(x) 0
N#endif
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N  /* C99 additions */
N  typedef float float_t;
N  typedef double double_t;
N#if __has_builtin(__builtin_inf)
X#if 0
S#   define HUGE_VALF __builtin_inff()
S#   define HUGE_VALL __builtin_infl()
S#   define INFINITY __builtin_inff()
S#   define NAN __builtin_nanf("")
N# else
N#   define HUGE_VALF ((float)__INFINITY__)
N#   define HUGE_VALL ((long double)__INFINITY__)
N#   define INFINITY ((float)__INFINITY__)
N#   define NAN (__ESCAPE__(0f_7FC00000))
N#endif
N
N#   define MATH_ERRNO 1
N#   define MATH_ERREXCEPT 2
Nextern const int math_errhandling;
N#endif
N#if __has_builtin(__builtin_inf)
X#if 0
S# define HUGE_VAL __builtin_inf()
N#else
N# define HUGE_VAL ((double)__INFINITY__)
N#endif
N
Nextern _ARMABI double acos(double /*x*/);
Xextern __declspec(__nothrow) double acos(double  );
N   /* computes the principal value of the arc cosine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* Returns: the arc cosine in the range 0 to Pi. */
Nextern _ARMABI double asin(double /*x*/);
Xextern __declspec(__nothrow) double asin(double  );
N   /* computes the principal value of the arc sine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* and -HUGE_VAL is returned. */
N   /* Returns: the arc sine in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI_PURE double atan(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double atan(double  );
N   /* computes the principal value of the arc tangent of x */
N   /* Returns: the arc tangent in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI double atan2(double /*y*/, double /*x*/);
Xextern __declspec(__nothrow) double atan2(double  , double  );
N   /* computes the principal value of the arc tangent of y/x, using the */
N   /* signs of both arguments to determine the quadrant of the return value */
N   /* a domain error occurs if both args are zero, and -HUGE_VAL returned. */
N   /* Returns: the arc tangent of y/x, in the range -Pi to Pi. */
N
Nextern _ARMABI double cos(double /*x*/);
Xextern __declspec(__nothrow) double cos(double  );
N   /* computes the cosine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the cosine value. */
Nextern _ARMABI double sin(double /*x*/);
Xextern __declspec(__nothrow) double sin(double  );
N   /* computes the sine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the sine value. */
N
Nextern void __use_accurate_range_reduction(void);
N   /* reference this to select the larger, slower, but more accurate */
N   /* range reduction in sin, cos and tan */
N
Nextern _ARMABI double tan(double /*x*/);
Xextern __declspec(__nothrow) double tan(double  );
N   /* computes the tangent of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance */
N   /* Returns: the tangent value. */
N   /*          if range error; returns HUGE_VAL. */
N
Nextern _ARMABI double cosh(double /*x*/);
Xextern __declspec(__nothrow) double cosh(double  );
N   /* computes the hyperbolic cosine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic cosine value. */
N   /*          if range error; returns HUGE_VAL. */
Nextern _ARMABI double sinh(double /*x*/);
Xextern __declspec(__nothrow) double sinh(double  );
N   /* computes the hyperbolic sine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic sine value. */
N   /*          if range error; returns -HUGE_VAL or HUGE_VAL depending */
N   /*          on the sign of the argument */
N
Nextern _ARMABI_PURE double tanh(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double tanh(double  );
N   /* computes the hyperbolic tangent of x. */
N   /* Returns: the hyperbolic tangent value. */
N
Nextern _ARMABI double exp(double /*x*/);
Xextern __declspec(__nothrow) double exp(double  );
N   /* computes the exponential function of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the exponential value. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
N
Nextern _ARMABI double frexp(double /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double frexp(double  , int *  ) __attribute__((__nonnull__(2)));
N   /* breaks a floating-point number into a normalised fraction and an */
N   /* integral power of 2. It stores the integer in the int object pointed */
N   /* to by exp. */
N   /* Returns: the value x, such that x is a double with magnitude in the */
N   /* interval 0.5 to 1.0 or zero, and value equals x times 2 raised to the */
N   /* power *exp. If value is zero, both parts of the result are zero. */
N
Nextern _ARMABI double ldexp(double /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) double ldexp(double  , int  );
N   /* multiplies a floating-point number by an integral power of 2. */
N   /* A range error may occur. */
N   /* Returns: the value of x times 2 raised to the power of exp. */
N   /*          if range error; HUGE_VAL is returned. */
Nextern _ARMABI double log(double /*x*/);
Xextern __declspec(__nothrow) double log(double  );
N   /* computes the natural logarithm of x. A domain error occurs if the */
N   /* argument is negative, and -HUGE_VAL is returned. A range error occurs */
N   /* if the argument is zero. */
N   /* Returns: the natural logarithm. */
N   /*          if range error; -HUGE_VAL is returned. */
Nextern _ARMABI double log10(double /*x*/);
Xextern __declspec(__nothrow) double log10(double  );
N   /* computes the base-ten logarithm of x. A domain error occurs if the */
N   /* argument is negative. A range error occurs if the argument is zero. */
N   /* Returns: the base-ten logarithm. */
Nextern _ARMABI double modf(double /*value*/, double * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double modf(double  , double *  ) __attribute__((__nonnull__(2)));
N   /* breaks the argument value into integral and fraction parts, each of */
N   /* which has the same sign as the argument. It stores the integral part */
N   /* as a double in the object pointed to by iptr. */
N   /* Returns: the signed fractional part of value. */
N
Nextern _ARMABI double pow(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double pow(double  , double  );
N   /* computes x raised to the power of y. A domain error occurs if x is */
N   /* zero and y is less than or equal to zero, or if x is negative and y */
N   /* is not an integer, and -HUGE_VAL returned. A range error may occur. */
N   /* Returns: the value of x raised to the power of y. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
Nextern _ARMABI double sqrt(double /*x*/);
Xextern __declspec(__nothrow) double sqrt(double  );
N   /* computes the non-negative square root of x. A domain error occurs */
N   /* if the argument is negative, and -HUGE_VAL returned. */
N   /* Returns: the value of the square root. */
N
N#if defined(__TARGET_FPU_VFP_DOUBLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !0L
S    _ARMABI_INLINE double _sqrt(double __x) { return __sqrt(__x); }
N#else
N    _ARMABI_INLINE double _sqrt(double __x) { return sqrt(__x); }
X    inline double _sqrt(double __x) { return sqrt(__x); }
N#endif
N#if defined(__TARGET_FPU_VFP_SINGLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 1L && !0L
N    _ARMABI_INLINE float _sqrtf(float __x) { return __sqrtf(__x); }
X    inline float _sqrtf(float __x) { return __sqrtf(__x); }
N#else
S    _ARMABI_INLINE float _sqrtf(float __x) { return (float)sqrt(__x); }
N#endif
N    /* With VFP, _sqrt and _sqrtf should expand inline as the native VFP square root
N     * instructions. They will not behave like the C sqrt() function, because
N     * they will report unusual values as IEEE exceptions (in fpmodes which
N     * support IEEE exceptions) rather than in errno. These function names
N     * are not specified in any standard. */
N
Nextern _ARMABI_PURE double ceil(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double ceil(double  );
N   /* computes the smallest integer not less than x. */
N   /* Returns: the smallest integer not less than x, expressed as a double. */
Nextern _ARMABI_PURE double fabs(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fabs(double  );
N   /* computes the absolute value of the floating-point number x. */
N   /* Returns: the absolute value of x. */
N
Nextern _ARMABI_PURE double floor(double /*d*/);
Xextern __declspec(__nothrow) __attribute__((const)) double floor(double  );
N   /* computes the largest integer not greater than x. */
N   /* Returns: the largest integer not greater than x, expressed as a double */
N
Nextern _ARMABI double fmod(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fmod(double  , double  );
N   /* computes the floating-point remainder of x/y. */
N   /* Returns: the value x - i * y, for some integer i such that, if y is */
N   /*          nonzero, the result has the same sign as x and magnitude */
N   /*          less than the magnitude of y. If y is zero, a domain error */
N   /*          occurs and -HUGE_VAL is returned. */
N
N    /* Additional Mathlib functions not defined by the ANSI standard.
N     * Not guaranteed, and not necessarily very well tested.
N     * C99 requires the user to include <math.h> to use these functions
N     * declaring them "by hand" is not sufficient
N     *
N     * The above statement is not completely true now.  Some of the above
N     * C99 functionality has been added as per the Standard, and (where
N     * necessary) old Mathlib functionality withdrawn/changed.  Before
N     * including this header #define __ENABLE_MATHLIB_LEGACY if you want to
N     * re-enable the legacy functionality.
N     */
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N
Nextern _ARMABI double acosh(double /*x*/);
Xextern __declspec(__nothrow) double acosh(double  );
N    /*
N     * Inverse cosh. EDOM if argument < 1.0
N     */
Nextern _ARMABI double asinh(double /*x*/);
Xextern __declspec(__nothrow) double asinh(double  );
N    /*
N     * Inverse sinh.
N     */
Nextern _ARMABI double atanh(double /*x*/);
Xextern __declspec(__nothrow) double atanh(double  );
N    /*
N     * Inverse tanh. EDOM if |argument| > 1.0
N     */
Nextern _ARMABI double cbrt(double /*x*/);
Xextern __declspec(__nothrow) double cbrt(double  );
N    /*
N     * Cube root.
N     */
N_ARMABI_INLINE _ARMABI_PURE double copysign(double __x, double __y)
Xinline __declspec(__nothrow) __attribute__((const)) double copysign(double __x, double __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __HI(__x) = (__HI(__x) & 0x7fffffff) | (__HI(__y) & 0x80000000);
X    (*(1 + (unsigned *)&(__x))) = ((*(1 + (unsigned *)&(__x))) & 0x7fffffff) | ((*(1 + (unsigned *)&(__y))) & 0x80000000);
N    return __x;
N}
N_ARMABI_INLINE _ARMABI_PURE float copysignf(float __x, float __y)
Xinline __declspec(__nothrow) __attribute__((const)) float copysignf(float __x, float __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __FLT(__x) = (__FLT(__x) & 0x7fffffff) | (__FLT(__y) & 0x80000000);
X    (*(unsigned *)&(__x)) = ((*(unsigned *)&(__x)) & 0x7fffffff) | ((*(unsigned *)&(__y)) & 0x80000000);
N    return __x;
N}
Nextern _ARMABI double erf(double /*x*/);
Xextern __declspec(__nothrow) double erf(double  );
N    /*
N     * Error function. (2/sqrt(pi)) * integral from 0 to x of exp(-t*t) dt.
N     */
Nextern _ARMABI double erfc(double /*x*/);
Xextern __declspec(__nothrow) double erfc(double  );
N    /*
N     * 1-erf(x). (More accurate than just coding 1-erf(x), for large x.)
N     */
Nextern _ARMABI double expm1(double /*x*/);
Xextern __declspec(__nothrow) double expm1(double  );
N    /*
N     * exp(x)-1. (More accurate than just coding exp(x)-1, for small x.)
N     */
N#define fpclassify(x) \
N    ((sizeof(x) == sizeof(float)) ? \
N        __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
X#define fpclassify(x)     ((sizeof(x) == sizeof(float)) ?         __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
N    /*
N     * Classify a floating point number into one of the following values:
N     */
N#define FP_ZERO         (0)
N#define FP_SUBNORMAL    (4)
N#define FP_NORMAL       (5)
N#define FP_INFINITE     (3)
N#define FP_NAN          (7)
N
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
S/* 
S * Note that we'll never classify a number as FP_NAN, as all NaNs will 
S * be either FP_NANQ or FP_NANS
S */
S#  define FP_NANQ       (8)
S#  define FP_NANS       (9)
N#endif
N
N
Nextern _ARMABI double hypot(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double hypot(double  , double  );
N    /*
N     * sqrt(x*x+y*y), ie the length of the vector (x,y) or the
N     * hypotenuse of a right triangle whose other two sides are x
N     * and y. Won't overflow unless the _answer_ is too big, even
N     * if the intermediate x*x+y*y is too big.
N     */
Nextern _ARMABI int ilogb(double /*x*/);
Xextern __declspec(__nothrow) int ilogb(double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
Nextern _ARMABI int ilogbf(float /*x*/);
Xextern __declspec(__nothrow) int ilogbf(float  );
N    /*
N     * Like ilogb but takes a float
N     */
Nextern _ARMABI int ilogbl(long double /*x*/);
Xextern __declspec(__nothrow) int ilogbl(long double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
N#define FP_ILOGB0   (-0x7fffffff) /* ilogb(0) == -INT_MAX */
N#define FP_ILOGBNAN ( 0x80000000) /* ilogb(NAN) == INT_MIN */
N
N#define isfinite(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isfinitef(x) \
N        : __ARM_isfinite(x))
X#define isfinite(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isfinitef(x)         : __ARM_isfinite(x))
N    /*
N     * Returns true if x is a finite number, size independent.
N     */
N
N#define isgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
X#define isgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
N    /*
N     * Returns true if x > y, throws no exceptions except on Signaling NaNs
N     *
N     * We want the C not set but the Z bit clear, V must be clear
N     */
N
N#define isgreaterequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
X#define isgreaterequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
N    /*
N     * Returns true if x >= y, throws no exceptions except on Signaling NaNs
N     *
N     * We just need to see if the C bit is set or not and ensure V clear
N     */
N
N#define isinf(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isinff(x) \
N        : __ARM_isinf(x))
X#define isinf(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isinff(x)         : __ARM_isinf(x))
N    /*
N     * Returns true if x is an infinity, size independent.
N     */
N
N#define isless(x, y)  \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
X#define isless(x, y)      (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
N    /*
N     * Returns true if x < y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than if N is set, V clear
N     */
N
N#define islessequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0) \
N        : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
X#define islessequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0)         : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
N    /*
N     * Returns true if x <= y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than or equal if one of N or Z is set, V clear
N     */
N
N#define islessgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? __ARM_islessgreaterf((x), (y)) \
N        : __ARM_islessgreater((x), (y)))
X#define islessgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? __ARM_islessgreaterf((x), (y))         : __ARM_islessgreater((x), (y)))
N    /*
N     * Returns true if x <> y, throws no exceptions except on Signaling NaNs
N     * Unfortunately this test is too complicated to do in a macro without
N     * evaluating x & y twice.  Shame really...
N     */
N
N#define isnan(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnanf(x) \
N        : __ARM_isnan(x))
X#define isnan(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnanf(x)         : __ARM_isnan(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isnormal(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnormalf(x) \
N        : __ARM_isnormal(x))
X#define isnormal(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnormalf(x)         : __ARM_isnormal(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isunordered(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
X#define isunordered(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000)         : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
N    /*
N     * Returns true if x ? y, throws no exceptions except on Signaling NaNs
N     * Unordered occurs if and only if the V bit is set
N     */
N
Nextern _ARMABI double lgamma (double /*x*/);
Xextern __declspec(__nothrow) double lgamma (double  );
N    /*
N     * The log of the absolute value of the gamma function of x. The sign
N     * of the gamma function of x is returned in the global `signgam'.
N     */
Nextern _ARMABI double log1p(double /*x*/);
Xextern __declspec(__nothrow) double log1p(double  );
N    /*
N     * log(1+x). (More accurate than just coding log(1+x), for small x.)
N     */
Nextern _ARMABI double logb(double /*x*/);
Xextern __declspec(__nothrow) double logb(double  );
N    /*
N     * Like ilogb but returns a double.
N     */
Nextern _ARMABI float logbf(float /*x*/);
Xextern __declspec(__nothrow) float logbf(float  );
N    /*
N     * Like logb but takes and returns float
N     */
Nextern _ARMABI long double logbl(long double /*x*/);
Xextern __declspec(__nothrow) long double logbl(long double  );
N    /*
N     * Like logb but takes and returns long double
N     */
Nextern _ARMABI double nextafter(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double nextafter(double  , double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nextafterf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float nextafterf(float  , float  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nextafterl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nextafterl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double nexttoward(double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) double nexttoward(double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nexttowardf(float /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) float nexttowardf(float  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nexttowardl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nexttowardl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double remainder(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double remainder(double  , double  );
N    /*
N     * Returns the remainder of x by y, in the IEEE 754 sense.
N     */
Nextern _ARMABI_FPEXCEPT double rint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double rint(double  );
N    /*
N     * Rounds x to an integer, in the IEEE 754 sense.
N     */
Nextern _ARMABI double scalbln(double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) double scalbln(double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalblnf(float /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) float scalblnf(float  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalblnl(long double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) long double scalblnl(long double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI double scalbn(double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) double scalbn(double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalbnf(float /*x*/, int /*n*/);
Xextern __declspec(__nothrow) float scalbnf(float  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalbnl(long double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) long double scalbnl(long double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
N#define signbit(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_signbitf(x) \
N        : __ARM_signbit(x))
X#define signbit(x)     ((sizeof(x) == sizeof(float))         ? __ARM_signbitf(x)         : __ARM_signbit(x))
N    /*
N     * Returns the signbit of x, size independent macro
N     */
N#endif
N
N/* C99 float versions of functions.  math.h has always reserved these
N   identifiers for this purpose (7.13.4). */
Nextern _ARMABI_PURE float _fabsf(float); /* old ARM name */
Xextern __declspec(__nothrow) __attribute__((const)) float _fabsf(float);  
N_ARMABI_INLINE _ARMABI_PURE float fabsf(float __f) { return _fabsf(__f); }
Xinline __declspec(__nothrow) __attribute__((const)) float fabsf(float __f) { return _fabsf(__f); }
Nextern _ARMABI float sinf(float /*x*/);
Xextern __declspec(__nothrow) float sinf(float  );
Nextern _ARMABI float cosf(float /*x*/);
Xextern __declspec(__nothrow) float cosf(float  );
Nextern _ARMABI float tanf(float /*x*/);
Xextern __declspec(__nothrow) float tanf(float  );
Nextern _ARMABI float acosf(float /*x*/);
Xextern __declspec(__nothrow) float acosf(float  );
Nextern _ARMABI float asinf(float /*x*/);
Xextern __declspec(__nothrow) float asinf(float  );
Nextern _ARMABI float atanf(float /*x*/);
Xextern __declspec(__nothrow) float atanf(float  );
Nextern _ARMABI float atan2f(float /*y*/, float /*x*/);
Xextern __declspec(__nothrow) float atan2f(float  , float  );
Nextern _ARMABI float sinhf(float /*x*/);
Xextern __declspec(__nothrow) float sinhf(float  );
Nextern _ARMABI float coshf(float /*x*/);
Xextern __declspec(__nothrow) float coshf(float  );
Nextern _ARMABI float tanhf(float /*x*/);
Xextern __declspec(__nothrow) float tanhf(float  );
Nextern _ARMABI float expf(float /*x*/);
Xextern __declspec(__nothrow) float expf(float  );
Nextern _ARMABI float logf(float /*x*/);
Xextern __declspec(__nothrow) float logf(float  );
Nextern _ARMABI float log10f(float /*x*/);
Xextern __declspec(__nothrow) float log10f(float  );
Nextern _ARMABI float powf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float powf(float  , float  );
Nextern _ARMABI float sqrtf(float /*x*/);
Xextern __declspec(__nothrow) float sqrtf(float  );
Nextern _ARMABI float ldexpf(float /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) float ldexpf(float  , int  );
Nextern _ARMABI float frexpf(float /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float frexpf(float  , int *  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI_PURE float ceilf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float ceilf(float  );
Nextern _ARMABI_PURE float floorf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float floorf(float  );
Nextern _ARMABI float fmodf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fmodf(float  , float  );
Nextern _ARMABI float modff(float /*value*/, float * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float modff(float  , float *  ) __attribute__((__nonnull__(2)));
N
N/* C99 long double versions of functions. */
N/* (also need to have 'using' declarations below) */
N#define _ARMDEFLD1(f) \
N    _ARMABI long double f##l(long double /*x*/)
X#define _ARMDEFLD1(f)     _ARMABI long double f##l(long double  )
N
N#define _ARMDEFLD1P(f, T) \
N    _ARMABI long double f##l(long double /*x*/, T /*p*/)
X#define _ARMDEFLD1P(f, T)     _ARMABI long double f##l(long double  , T  )
N
N#define _ARMDEFLD2(f) \
N    _ARMABI long double f##l(long double /*x*/, long double /*y*/)
X#define _ARMDEFLD2(f)     _ARMABI long double f##l(long double  , long double  )
N
N/*
N * Long double versions of C89 functions can be defined
N * unconditionally, because C89 reserved these names in "future
N * library directions".
N */
N_ARMDEFLD1(acos);
X__declspec(__nothrow) long double acosl(long double );
N_ARMDEFLD1(asin);
X__declspec(__nothrow) long double asinl(long double );
N_ARMDEFLD1(atan);
X__declspec(__nothrow) long double atanl(long double );
N_ARMDEFLD2(atan2);
X__declspec(__nothrow) long double atan2l(long double , long double );
N_ARMDEFLD1(ceil);
X__declspec(__nothrow) long double ceill(long double );
N_ARMDEFLD1(cos);
X__declspec(__nothrow) long double cosl(long double );
N_ARMDEFLD1(cosh);
X__declspec(__nothrow) long double coshl(long double );
N_ARMDEFLD1(exp);
X__declspec(__nothrow) long double expl(long double );
N_ARMDEFLD1(fabs);
X__declspec(__nothrow) long double fabsl(long double );
N_ARMDEFLD1(floor);
X__declspec(__nothrow) long double floorl(long double );
N_ARMDEFLD2(fmod);
X__declspec(__nothrow) long double fmodl(long double , long double );
N_ARMDEFLD1P(frexp, int*) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double frexpl(long double , int* ) __attribute__((__nonnull__(2)));
N_ARMDEFLD1P(ldexp, int);
X__declspec(__nothrow) long double ldexpl(long double , int );
N_ARMDEFLD1(log);
X__declspec(__nothrow) long double logl(long double );
N_ARMDEFLD1(log10);
X__declspec(__nothrow) long double log10l(long double );
N_ARMABI long double modfl(long double /*x*/, long double * /*p*/) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double modfl(long double  , long double *  ) __attribute__((__nonnull__(2)));
N_ARMDEFLD2(pow);
X__declspec(__nothrow) long double powl(long double , long double );
N_ARMDEFLD1(sin);
X__declspec(__nothrow) long double sinl(long double );
N_ARMDEFLD1(sinh);
X__declspec(__nothrow) long double sinhl(long double );
N_ARMDEFLD1(sqrt);
X__declspec(__nothrow) long double sqrtl(long double );
N_ARMDEFLD1(tan);
X__declspec(__nothrow) long double tanl(long double );
N_ARMDEFLD1(tanh);
X__declspec(__nothrow) long double tanhl(long double );
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N
N/*
N * C99 float and long double versions of extra-C89 functions.
N */
Nextern _ARMABI float acoshf(float /*x*/);
Xextern __declspec(__nothrow) float acoshf(float  );
N_ARMDEFLD1(acosh);
X__declspec(__nothrow) long double acoshl(long double );
Nextern _ARMABI float asinhf(float /*x*/);
Xextern __declspec(__nothrow) float asinhf(float  );
N_ARMDEFLD1(asinh);
X__declspec(__nothrow) long double asinhl(long double );
Nextern _ARMABI float atanhf(float /*x*/);
Xextern __declspec(__nothrow) float atanhf(float  );
N_ARMDEFLD1(atanh);
X__declspec(__nothrow) long double atanhl(long double );
N_ARMDEFLD2(copysign);
X__declspec(__nothrow) long double copysignl(long double , long double );
Nextern _ARMABI float cbrtf(float /*x*/);
Xextern __declspec(__nothrow) float cbrtf(float  );
N_ARMDEFLD1(cbrt);
X__declspec(__nothrow) long double cbrtl(long double );
Nextern _ARMABI float erff(float /*x*/);
Xextern __declspec(__nothrow) float erff(float  );
N_ARMDEFLD1(erf);
X__declspec(__nothrow) long double erfl(long double );
Nextern _ARMABI float erfcf(float /*x*/);
Xextern __declspec(__nothrow) float erfcf(float  );
N_ARMDEFLD1(erfc);
X__declspec(__nothrow) long double erfcl(long double );
Nextern _ARMABI float expm1f(float /*x*/);
Xextern __declspec(__nothrow) float expm1f(float  );
N_ARMDEFLD1(expm1);
X__declspec(__nothrow) long double expm1l(long double );
Nextern _ARMABI float log1pf(float /*x*/);
Xextern __declspec(__nothrow) float log1pf(float  );
N_ARMDEFLD1(log1p);
X__declspec(__nothrow) long double log1pl(long double );
Nextern _ARMABI float hypotf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float hypotf(float  , float  );
N_ARMDEFLD2(hypot);
X__declspec(__nothrow) long double hypotl(long double , long double );
Nextern _ARMABI float lgammaf(float /*x*/);
Xextern __declspec(__nothrow) float lgammaf(float  );
N_ARMDEFLD1(lgamma);
X__declspec(__nothrow) long double lgammal(long double );
Nextern _ARMABI float remainderf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float remainderf(float  , float  );
N_ARMDEFLD2(remainder);
X__declspec(__nothrow) long double remainderl(long double , long double );
Nextern _ARMABI float rintf(float /*x*/);
Xextern __declspec(__nothrow) float rintf(float  );
N_ARMDEFLD1(rint);
X__declspec(__nothrow) long double rintl(long double );
N
N#endif
N
N#ifdef __USE_C99_MATH
S/*
S * Functions new in C99.
S */
Sextern _ARMABI double exp2(double /*x*/); /* * 2.^x. */
Sextern _ARMABI float exp2f(float /*x*/);
S_ARMDEFLD1(exp2);
Sextern _ARMABI double fdim(double /*x*/, double /*y*/);
Sextern _ARMABI float fdimf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fdim);
S#ifdef __FP_FAST_FMA
S#define FP_FAST_FMA
S#endif
S#ifdef __FP_FAST_FMAF
S#define FP_FAST_FMAF
S#endif
S#ifdef __FP_FAST_FMAL
S#define FP_FAST_FMAL
S#endif
Sextern _ARMABI double fma(double /*x*/, double /*y*/, double /*z*/);
Sextern _ARMABI float fmaf(float /*x*/, float /*y*/, float /*z*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z) \
S    { return (long double)fma((double)__x, (double)__y, (double)__z); }
X_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z)     { return (long double)fma((double)__x, (double)__y, (double)__z); }
S#endif
Sextern _ARMABI_FPEXCEPT double fmax(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fmaxf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmax);
Sextern _ARMABI_FPEXCEPT double fmin(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fminf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmin);
Sextern _ARMABI double log2(double /*x*/); /* * log base 2 of x. */
Sextern _ARMABI float log2f(float /*x*/);
S_ARMDEFLD1(log2);
Sextern _ARMABI long lrint(double /*x*/);
Sextern _ARMABI long lrintf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI long lrintl(long double __x) \
S    { return lrint((double)__x); }
X_ARMABI_INLINE _ARMABI long lrintl(long double __x)     { return lrint((double)__x); }
S#endif
Sextern _ARMABI __LONGLONG llrint(double /*x*/);
Sextern _ARMABI __LONGLONG llrintf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x) \
S    { return llrint((double)__x); }
X_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x)     { return llrint((double)__x); }
S#endif
Sextern _ARMABI long lround(double /*x*/);
Sextern _ARMABI long lroundf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI long lroundl(long double __x) \
S    { return lround((double)__x); }
X_ARMABI_INLINE _ARMABI long lroundl(long double __x)     { return lround((double)__x); }
S#endif
Sextern _ARMABI __LONGLONG llround(double /*x*/);
Sextern _ARMABI __LONGLONG llroundf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x) \
S    { return llround((double)__x); }
X_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x)     { return llround((double)__x); }
S#endif
Sextern _ARMABI_PURE double nan(const char */*tagp*/);
Sextern _ARMABI_PURE float nanf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t) \
S    { return (long double)nan(__t); }
X_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t)     { return (long double)nan(__t); }
S#endif
S#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
Sextern _ARMABI_PURE double nans(const char */*tagp*/);
Sextern _ARMABI_PURE float nansf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t) \
S    { return (long double)nans(__t); }
X_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t)     { return (long double)nans(__t); }
S#endif
S#endif 
Sextern _ARMABI_FPEXCEPT double nearbyint(double /*x*/);
Sextern _ARMABI_FPEXCEPT float nearbyintf(float /*x*/);
S_ARMDEFLD1(nearbyint);
Sextern  double remquo(double /*x*/, double /*y*/, int */*quo*/);
Sextern  float remquof(float /*x*/, float /*y*/, int */*quo*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q) \
S    { return (long double)remquo((double)__x, (double)__y, __q); }
X_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q)     { return (long double)remquo((double)__x, (double)__y, __q); }
S#endif
Sextern _ARMABI_FPEXCEPT double round(double /*x*/);
Sextern _ARMABI_FPEXCEPT float roundf(float /*x*/);
S_ARMDEFLD1(round);
Sextern _ARMABI double tgamma(double /*x*/); /* * The gamma function of x. */
Sextern _ARMABI float tgammaf(float /*x*/);
S_ARMDEFLD1(tgamma);
Sextern _ARMABI_FPEXCEPT double trunc(double /*x*/);
Sextern _ARMABI_FPEXCEPT float truncf(float /*x*/);
S_ARMDEFLD1(trunc);
N#endif
N
N#undef _ARMDEFLD1
N#undef _ARMDEFLD1P
N#undef _ARMDEFLD2
N
N#ifdef __cplusplus
N  extern "C++" {
N    inline float abs(float __x)   { return fabsf(__x); }
N    inline float acos(float __x)  { return acosf(__x); }
N    inline float asin(float __x)  { return asinf(__x); }
N    inline float atan(float __x)  { return atanf(__x); }
N    inline float atan2(float __y, float __x)    { return atan2f(__y,__x); }
N    inline float ceil(float __x)  { return ceilf(__x); }
N    inline float cos(float __x)   { return cosf(__x); }
N    inline float cosh(float __x)  { return coshf(__x); }
N    inline float exp(float __x)   { return expf(__x); }
N    inline float fabs(float __x)  { return fabsf(__x); }
N    inline float floor(float __x) { return floorf(__x); }
N    inline float fmod(float __x, float __y)     { return fmodf(__x, __y); }
N    float frexp(float __x, int* __exp) __attribute__((__nonnull__(2)));
N    inline float frexp(float __x, int* __exp)   { return frexpf(__x, __exp); }
N    inline float ldexp(float __x, int __exp)    { return ldexpf(__x, __exp);}
N    inline float log(float __x)   { return logf(__x); }
N    inline float log10(float __x) { return log10f(__x); }
N    float modf(float __x, float* __iptr) __attribute__((__nonnull__(2)));
N    inline float modf(float __x, float* __iptr) { return modff(__x, __iptr); }
N    inline float pow(float __x, float __y)      { return powf(__x,__y); }
N    inline float pow(float __x, int __y)     { return powf(__x, (float)__y); }
N    inline float sin(float __x)   { return sinf(__x); }
N    inline float sinh(float __x)  { return sinhf(__x); }
N    inline float sqrt(float __x)  { return sqrtf(__x); }
N    inline float _sqrt(float __x) { return _sqrtf(__x); }
N    inline float tan(float __x)   { return tanf(__x); }
N    inline float tanh(float __x)  { return tanhf(__x); }
N
N    inline double abs(double __x) { return fabs(__x); }
N    inline double pow(double __x, int __y)
N                { return pow(__x, (double) __y); }
N
N#ifdef __HAVE_LONGDOUBLE
N    inline long double abs(long double __x)
N                { return (long double)fabsl(__x); }
N    inline long double acos(long double __x)
N                { return (long double)acosl(__x); }
N    inline long double asin(long double __x)
N                { return (long double)asinl(__x); }
N    inline long double atan(long double __x)
N                { return (long double)atanl(__x); }
N    inline long double atan2(long double __y, long double __x)
N                { return (long double)atan2l(__y, __x); }
N    inline long double ceil(long double __x)
N                { return (long double)ceill( __x); }
N    inline long double cos(long double __x)
N                { return (long double)cosl(__x); }
N    inline long double cosh(long double __x)
N                { return (long double)coshl(__x); }
N    inline long double exp(long double __x)
N                { return (long double)expl(__x); }
N    inline long double fabs(long double __x)
N                { return (long double)fabsl(__x); }
N    inline long double floor(long double __x)
N                { return (long double)floorl(__x); }
N    inline long double fmod(long double __x, long double __y)
N                { return (long double)fmodl(__x, __y); }
N    long double frexp(long double __x, int* __p) __attribute__((__nonnull__(2)));
N    inline long double frexp(long double __x, int* __p)
N                { return (long double)frexpl(__x, __p); }
N    inline long double ldexp(long double __x, int __exp)
N                { return (long double)ldexpl(__x, __exp); }
N    inline long double log(long double __x)
N                { return (long double)logl(__x); }
N    inline long double log10(long double __x)
N                { return (long double)log10l(__x); }
N    long double modf(long double __x, long double* __p) __attribute__((__nonnull__(2)));
N    inline long double modf(long double __x, long double* __p)
N                { return (long double)modfl(__x, __p); }
N    inline long double pow(long double __x, long double __y)
N                { return (long double)powl(__x, __y); }
N    inline long double pow(long double __x, int __y)
N                { return (long double)powl(__x, __y); }
N    inline long double sin(long double __x)
N                { return (long double)sinl(__x); }
N    inline long double sinh(long double __x)
N                { return (long double)sinhl(__x); }
N    inline long double sqrt(long double __x)
N                { return (long double)sqrtl(__x); }
N    inline long double _sqrt(long double __x)
N                { return (long double)_sqrt((double) __x); }
N    inline long double tan(long double __x)
N                { return (long double)tanl(__x); }
N    inline long double tanh(long double __x)
N                { return (long double)tanhl(__x); }
N#endif
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N    inline float acosh(float __x) { return acoshf(__x); }
N    inline float asinh(float __x) { return asinhf(__x); }
N    inline float atanh(float __x) { return atanhf(__x); }
N    inline float cbrt(float __x) { return cbrtf(__x); }
N    inline float erf(float __x) { return erff(__x); }
N    inline float erfc(float __x) { return erfcf(__x); }
N    inline float expm1(float __x) { return expm1f(__x); }
N    inline float log1p(float __x) { return log1pf(__x); }
N    inline float hypot(float __x, float __y) { return hypotf(__x, __y); }
N    inline float lgamma(float __x) { return lgammaf(__x); }
N    inline float remainder(float __x, float __y) { return remainderf(__x, __y); }
N    inline float rint(float __x) { return rintf(__x); }
N#endif
N
N#ifdef __USE_C99_MATH
S    inline float exp2(float __x) { return exp2f(__x); }
S    inline float fdim(float __x, float __y) { return fdimf(__x, __y); }
S    inline float fma(float __x, float __y, float __z) { return fmaf(__x, __y, __z); }
S    inline float fmax(float __x, float __y) { return fmaxf(__x, __y); }
S    inline float fmin(float __x, float __y) { return fminf(__x, __y); }
S    inline float log2(float __x) { return log2f(__x); }
S    inline _ARMABI long lrint(float __x) { return lrintf(__x); }
S    inline _ARMABI __LONGLONG llrint(float __x) { return llrintf(__x); }
S    inline _ARMABI long lround(float __x) { return lroundf(__x); }
S    inline _ARMABI __LONGLONG llround(float __x) { return llroundf(__x); }
S    inline _ARMABI_FPEXCEPT float nearbyint(float __x) { return nearbyintf(__x); }
S    inline float remquo(float __x, float __y, int *__q) { return remquof(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT float round(float __x) { return roundf(__x); }
S    inline float tgamma(float __x) { return tgammaf(__x); }
S    inline _ARMABI_FPEXCEPT float trunc(float __x) { return truncf(__x); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double acosh(long double __x) { return acoshl(__x); }
S    inline long double asinh(long double __x) { return asinhl(__x); }
S    inline long double atanh(long double __x) { return atanhl(__x); }
S    inline long double cbrt(long double __x) { return cbrtl(__x); }
S    inline long double erf(long double __x) { return erfl(__x); }
S    inline long double erfc(long double __x) { return erfcl(__x); }
S    inline long double expm1(long double __x) { return expm1l(__x); }
S    inline long double log1p(long double __x) { return log1pl(__x); }
S    inline long double hypot(long double __x, long double __y) { return hypotl(__x, __y); }
S    inline long double lgamma(long double __x) { return lgammal(__x); }
S    inline long double remainder(long double __x, long double __y) { return remainderl(__x, __y); }
S    inline long double rint(long double __x) { return rintl(__x); }
S    inline long double exp2(long double __x) { return exp2l(__x); }
S    inline long double fdim(long double __x, long double __y) { return fdiml(__x, __y); }
S    inline long double fma(long double __x, long double __y, long double __z) { return fmal(__x, __y, __z); }
S    inline long double fmax(long double __x, long double __y) { return fmaxl(__x, __y); }
S    inline long double fmin(long double __x, long double __y) { return fminl(__x, __y); }
S    inline long double log2(long double __x) { return log2l(__x); }
S    inline _ARMABI long lrint(long double __x) { return lrintl(__x); }
S    inline _ARMABI __LONGLONG llrint(long double __x) { return llrintl(__x); }
S    inline _ARMABI long lround(long double __x) { return lroundl(__x); }
S    inline _ARMABI __LONGLONG llround(long double __x) { return llroundl(__x); }
S    inline _ARMABI_FPEXCEPT long double nearbyint(long double __x) { return nearbyintl(__x); }
S    inline long double remquo(long double __x, long double __y, int *__q) { return remquol(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT long double round(long double __x) { return roundl(__x); }
S    inline long double tgamma(long double __x) { return tgammal(__x); }
S    inline _ARMABI_FPEXCEPT long double trunc(long double __x) { return truncl(__x); }
S#endif
N#endif
N
N  }
N#endif
N
N    #ifdef __cplusplus
N        }  /* extern "C" */
N      }  /* namespace std */
N    #endif
N  #endif /* __MATH_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__MATH_NO_EXPORTS)
X  #if 1L && !0L
N    using ::std::__use_accurate_range_reduction;
N    using ::std::abs;
N    using ::std::acos;
N    using ::std::asin;
N    using ::std::atan2;
N    using ::std::atan;
N    using ::std::ceil;
N    using ::std::cos;
N    using ::std::cosh;
N    using ::std::exp;
N    using ::std::fabs;
N    using ::std::floor;
N    using ::std::fmod;
N    using ::std::frexp;
N    using ::std::ldexp;
N    using ::std::log10;
N    using ::std::log;
N    using ::std::modf;
N    using ::std::pow;
N    using ::std::sin;
N    using ::std::sinh;
N    using ::std::sqrt;
N    using ::std::_sqrt;
N    using ::std::_sqrtf;
N    using ::std::tan;
N    using ::std::tanh;
N    using ::std::_fabsf;
N    /* C99 float and long double versions in already-C89-reserved namespace */
N    using ::std::acosf;
N    using ::std::acosl;
N    using ::std::asinf;
N    using ::std::asinl;
N    using ::std::atan2f;
N    using ::std::atan2l;
N    using ::std::atanf;
N    using ::std::atanl;
N    using ::std::ceilf;
N    using ::std::ceill;
N    using ::std::cosf;
N    using ::std::coshf;
N    using ::std::coshl;
N    using ::std::cosl;
N    using ::std::expf;
N    using ::std::expl;
N    using ::std::fabsf;
N    using ::std::fabsl;
N    using ::std::floorf;
N    using ::std::floorl;
N    using ::std::fmodf;
N    using ::std::fmodl;
N    using ::std::frexpf;
N    using ::std::frexpl;
N    using ::std::ldexpf;
N    using ::std::ldexpl;
N    using ::std::log10f;
N    using ::std::log10l;
N    using ::std::logf;
N    using ::std::logl;
N    using ::std::modff;
N    using ::std::modfl;
N    using ::std::powf;
N    using ::std::powl;
N    using ::std::sinf;
N    using ::std::sinhf;
N    using ::std::sinhl;
N    using ::std::sinl;
N    using ::std::sqrtf;
N    using ::std::sqrtl;
N    using ::std::tanf;
N    using ::std::tanhf;
N    using ::std::tanhl;
N    using ::std::tanl;
N    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X    #if !0L || 0L
N      /* C99 additions which for historical reasons appear in non-strict mode */
N      using ::std::acosh;
N      using ::std::asinh;
N      using ::std::atanh;
N      using ::std::cbrt;
N      using ::std::copysign;
N      using ::std::copysignf;
N      using ::std::erf;
N      using ::std::erfc;
N      using ::std::expm1;
N      using ::std::hypot;
N      using ::std::ilogb;
N      using ::std::ilogbf;
N      using ::std::ilogbl;
N      using ::std::lgamma;
N      using ::std::log1p;
N      using ::std::logb;
N      using ::std::logbf;
N      using ::std::logbl;
N      using ::std::nextafter;
N      using ::std::nextafterf;
N      using ::std::nextafterl;
N      using ::std::nexttoward;
N      using ::std::nexttowardf;
N      using ::std::nexttowardl;
N      using ::std::remainder;
N      using ::std::rint;
N      using ::std::scalbln;
N      using ::std::scalblnf;
N      using ::std::scalblnl;
N      using ::std::scalbn;
N      using ::std::scalbnf;
N      using ::std::scalbnl;
N      using ::std::math_errhandling;
N      using ::std::acoshf;
N      using ::std::acoshl;
N      using ::std::asinhf;
N      using ::std::asinhl;
N      using ::std::atanhf;
N      using ::std::atanhl;
N      using ::std::copysignl;
N      using ::std::cbrtf;
N      using ::std::cbrtl;
N      using ::std::erff;
N      using ::std::erfl;
N      using ::std::erfcf;
N      using ::std::erfcl;
N      using ::std::expm1f;
N      using ::std::expm1l;
N      using ::std::log1pf;
N      using ::std::log1pl;
N      using ::std::hypotf;
N      using ::std::hypotl;
N      using ::std::lgammaf;
N      using ::std::lgammal;
N      using ::std::remainderf;
N      using ::std::remainderl;
N      using ::std::rintf;
N      using ::std::rintl;
N    #endif
N    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X    #if !0L || 0L
N      /* C99 additions which appear in C99 or non-strict mode */
N      using ::std::float_t;
N      using ::std::double_t;
N    #endif
N    #ifdef __USE_C99_MATH
S      /* Functions new in C99. */
S      using ::std::exp2;
S      using ::std::exp2f;
S      using ::std::exp2l;
S      using ::std::fdim;
S      using ::std::fdimf;
S      using ::std::fdiml;
S      using ::std::fma;
S      using ::std::fmaf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::fmal;
S#endif
S      using ::std::fmax;
S      using ::std::fmaxf;
S      using ::std::fmaxl;
S      using ::std::fmin;
S      using ::std::fminf;
S      using ::std::fminl;
S      using ::std::log2;
S      using ::std::log2f;
S      using ::std::log2l;
S      using ::std::lrint;
S      using ::std::lrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lrintl;
S#endif
S      using ::std::llrint;
S      using ::std::llrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llrintl;
S#endif
S      using ::std::lround;
S      using ::std::lroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lroundl;
S#endif
S      using ::std::llround;
S      using ::std::llroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llroundl;
S#endif
S      using ::std::nan;
S      using ::std::nanf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::nanl;
S#endif
S      using ::std::nearbyint;
S      using ::std::nearbyintf;
S      using ::std::nearbyintl;
S      using ::std::remquo;
S      using ::std::remquof;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::remquol;
S#endif
S      using ::std::round;
S      using ::std::roundf;
S      using ::std::roundl;
S      using ::std::tgamma;
S      using ::std::tgammaf;
S      using ::std::tgammal;
S      using ::std::trunc;
S      using ::std::truncf;
S      using ::std::truncl;
N    #endif
N  #endif
N
N#undef __LONGLONG
N
N#endif /* __math_h */
N
N/* end of math.h */
L 7 ".\misc\inc\geometry.h" 2
N
N#define PI_const (3.14159265359F)
N#define PI2_const (3.14159265359F / 2.0F)
N#define PI4_const (3.14159265359F / 4.0F)
N#define PI32_const (3.14159265359F * 1.5F)
N
Ntypedef int16_t gbasic_t;
N
N
Ntypedef struct {
N	gbasic_t x, y, w, h;
N} b2D;
N
Ntypedef struct {
N	float x, y, w, h;
N} f2D;
N
Nstruct b2P {
N	gbasic_t x, y;
N};
N
Ntypedef struct {
N	float x, y;
N}f2P ;
N
Nclass Coordinates {
N	public:
N    void Place (b2D);
N	  void Place (gbasic_t, gbasic_t);
N	  void Dispose (b2D);
N	  void Dispose (gbasic_t, gbasic_t, gbasic_t, gbasic_t);
N	  b2D GetRect();
N	  b2D GetxRect ();
N      b2D GetyRect ();
N      b2D GetxyRect ();
N	  int32_t GetH();
N	  int32_t GetW();
N	  b2D AllignLeft (b2D);
N	  b2D AllignRight (b2D);
N	  b2D AllignTop (b2D);
N	  b2D AllignBottom (b2D);
N	  int32_t Trunc (b2D *, b2D);
N	  int32_t Trunc (b2D *);
N	  b2D TruncLine (gbasic_t, gbasic_t, gbasic_t, gbasic_t);
N	  gbasic_t X0, Y0, W, H;	
N    protected:
N};
N
Nnamespace gTest {
N  
N  bool TestLineIntersect (float, float, float, float ,\
N                          float, float, float, float  );   
X  bool TestLineIntersect (float, float, float, float ,                          float, float, float, float  );   
N
N  bool TestBoxBounds (f2D, f2D);  
N  
N  bool TestPointInBox (f2D, float, float);
N    
N    
N    
N};
N
N
N
N
N/*GEOMETRY_H*/
N
N#endif
N
N
N
L 6 ".\device\GUI\inc\Frame_Class.h" 2
N#include "memory_template.h"
N#include "List.h"
L 1 ".\misc\inc\List.h" 1
N#ifndef __LIST
N#define __LIST
N#include <stdint.h>
N
Ntemplate <class T, typename K>
N	class List_Node {
N		public:
N			T *rlink, *llink;
N		  K key;
N		  //virtual bool TestWith (K &);
N	};
N
Ntemplate <class T>
N  class List_Iterator {
N	  public:
N	  	List_Iterator ();
N	    bool operator +  (T &);
N	    T *operator -  (T &);
N		  bool operator +  (T *);
N	    T *operator -  (T *);
N		template <typename A>
N		  List_Iterator &operator + (A &);
N		template <typename A>
N		  List_Iterator &operator + (A *);
N        template <typename A>
N		  List_Iterator &operator + (List_Iterator &);
N		template <typename A>
N		  List_Iterator &operator + (List_Iterator *);
N		template <typename A>
N		  List_Iterator &Array (A &, uint32_t);
N		template <typename A>
N		  List_Iterator &Array (A *, uint32_t);
N		  /*
N	    bool operator << (T &);
N	    bool operator >> (T &);
N		  */
N	    T *Get (uint32_t index);
N	    T *GetLast ();
N      T *GetFirst ();
N      T *GetNext (T *);
N	    int32_t Put (T &, uint32_t index);
N	    T *Remove (uint32_t index);
N		  int32_t Remove (T *);
N		  int32_t Remove (T &);
N	    uint32_t Contain ();
N	  private:
N		  T *First, *Last;
N	    uint32_t Elements;
N  };
N
Ntemplate <class T>
NList_Iterator<T>::List_Iterator()
N{
N}
Ntemplate <class T>
Nbool List_Iterator<T>::operator + (T &item)
N{
N	this->Elements++;
N		T *i,*j;
N		if (!this->First) {
N			this->First = &item;
N			this->Last = &item;
N			item.rlink = (T *)0;
N			item.llink = (T *)0;
N			return true;
N		}
N		i = this->First;
N		j = (T *)0;
N		while (i != (T *)0) {
N			if (i->key > item.key) {
N				j = i;
N				i = i->rlink;
N				continue;
N			}
N			if (i->llink) {
N				i->llink->rlink = &item;
N				item.rlink = i;
N				item.llink = i->llink;
N				i->llink = &item;
N				return true;
N			}
N			item.rlink = i;
N			item.llink = (T *)0;
N			i->llink = &item;
N			this->First = &item;
N			return true;
N		}
N		j->rlink = &item;
N		item.rlink = (T *)0;
N		this->Last = &item;
N		item.llink = j;
N		return true;	
N}
Ntemplate <class T>
NT *List_Iterator<T>::operator - (T &item)
N{
N	if (this->Elements == 0)return (T *)0;
N	this->Elements--;
N	T *l = item.llink,*r = item.rlink;
N		if (!l&&!r) {
N			this->First = (T *)0;
N			this->Last = (T *)0;
N			return (T *)0;
N		}
N		if (!l) {
N			this->First = r;
N			r->llink = (T *)0;
N		}
N		else    l->rlink = r;
N		
N		if (!r) {
N   			l->rlink = (T *)0;
N			  this->Last = l;
N		}
N		else    r->llink = l;
N		return &item;	
N}
N
Ntemplate <class T>
Nbool List_Iterator<T>::operator + (T *item)
N{
N	return *this + *item;
N}
N
Ntemplate <class T>
N	template <typename A>
NList_Iterator<T> &List_Iterator<T>::operator + (A &array)
N{
N	uint32_t t = array.Contain();
N	while (t--) {
N		(*this) + array[t];
N	}
N	return *this;
N}
N
Ntemplate <class T>
N	template <typename A>
NList_Iterator<T> &List_Iterator<T>::operator + (A *array)
N{
N	A &a = *array;
N	return (*this) + a;
N}
N
Ntemplate <class T>
N	template <typename A>
NList_Iterator<T> &List_Iterator<T>::Array (A &array, uint32_t t)
N{
N	while (t--) {
N		(*this) + array[t];
N	}
N	return *this;
N}
N
Ntemplate <class T>
N	template <typename A>
NList_Iterator<T> &List_Iterator<T>::Array (A *array, uint32_t t)
N{
N	A &a = *array;
N	return this->Array(a, t);
N}
N
N		  
N
Ntemplate <class T>
NT *List_Iterator<T>::operator - (T *item)
N{
N	return *this - *item;
N}
N/*
Ntemplate <class T>
Nbool List_Iterator<T>::operator << (T &item)
N{
N	return 0;
N}
Ntemplate <class T>
Nbool List_Iterator<T>::operator >> (T &item)
N{
N	return 0;
N}
N*/
N
Ntemplate <class T>
NT *List_Iterator<T>::Get (uint32_t index)
N{
N	if (this->Elements < index) return (T *)0;
N	
N	T *item = this->First;
N	while (index--)
N		  item = item->rlink;
N	return item;
N}
Ntemplate <class T>
NT *List_Iterator<T>::GetLast ()
N{
N	return this->Last;
N}
N
Ntemplate <class T>
NT *List_Iterator<T>::GetFirst ()
N{
N	return this->First;
N}
N
Ntemplate <class T>
NT *List_Iterator<T>::GetNext (T *item)
N{
N    if (item != (T *)0)
N        if (item->rlink != (T *)0) return item->rlink;
N    return (T *)0;
N}
N
Ntemplate <class T>
NT *List_Iterator<T>::Remove (uint32_t index)
N{
N	if (this->Elements < index) return (T *)0;
N	
N	T *item = this->First;
N	while (index--)
N		  item = item->rlink;
N	*(this) - item;
N	return item;
N}
N
Ntemplate <class T>
Nint32_t List_Iterator<T>::Remove (T *item)
N{
N	if (!this->Contain()) return -1;
N	*(this) - item;
N	
N	return 0;
N}
N
Ntemplate <class T>
Nint32_t List_Iterator<T>::Remove (T &item)
N{
N	if (!this->Contain()) return -1;
N
N	*(this) - &item;
N	return 0;
N}
N
Ntemplate <class T>
Nint32_t List_Iterator<T>::Put (T &item, uint32_t index)
N{
N	return -1;
N}
Ntemplate <class T>
Nuint32_t List_Iterator<T>::Contain ()
N{
N	return this->Elements;
N}
N
N#endif /*__LIST*/
L 8 ".\device\GUI\inc\Frame_Class.h" 2
N
Ntemplate <typename T>
Nstruct frame_data_t {
N	ColorTypeDef *Frame;
N	T W, H;
N	T glo_x, glo_y;
N};
N
N
N
Ntemplate <typename T>
N	class Frame2D : public List_Node<Frame2D<T>, uint8_t>{
N	public:
N		Frame2D ();
N	  void operator () (b2D);
N	  void operator () (b2D, ColorTypeDef *);
N	  b2D GetRect ();
N	  float GetH ();
N	  float GetW ();
N	  ColorTypeDef *GetBuff ();
N	  ColorTypeDef *GetBuff (b2D);
N	  void FillDMA (ColorTypeDef = StdColBlack);
N	private:
N    frame_data_t<T> Data;
N	  virtual void DmaTransfer (ColorTypeDef *, ColorTypeDef *, uint32_t);
N	  ColorTypeDef PointToFill;
N};
N
Ntemplate <typename T>
N	class Frame2DManager : public List_Iterator<Frame2D<T> > ,
N		                     public Allocator<Frame2D<T> >     {
N	public:
N		Frame2DManager ();
N	  void operator () ();
N	  Frame2D<T> *Create (b2D);
N	  Frame2D<T> *Access (uint32_t);
N	private:
N};
N												 
Ntemplate <typename T>
NFrame2D<T>::Frame2D (){}
N
Ntemplate <typename T>
Nvoid Frame2D<T>::operator () (b2D rect)
N{
N	this->Data.Frame = (ColorTypeDef *)(this + 1);	
N	this->Data.glo_x = rect.x;
N	this->Data.glo_y = rect.y;
N	this->Data.W     = rect.w;
N	this->Data.H     = rect.h;
N	this->PointToFill = StdColBlack;
N}
N
Ntemplate <typename T>
Nvoid Frame2D<T>::operator () (b2D rect, ColorTypeDef *buff)
N{
N	this->Data.Frame = buff;	
N	this->Data.glo_x = rect.x;
N	this->Data.glo_y = rect.y;
N	this->Data.W     = rect.w;
N	this->Data.H     = rect.h;
N	this->PointToFill = StdColBlack;
N}
N
N
Ntemplate <typename T>
Nb2D Frame2D<T>::GetRect ()
N{
N	b2D rect = {this->Data.glo_x, this->Data.glo_y, this->Data.W, this->Data.H};
N	return rect;
N}
N
Ntemplate <typename T>
Nfloat Frame2D<T>::GetH ()
N{
N	return this->Data.H;
N}
N
Ntemplate <typename T>
Nfloat Frame2D<T>::GetW ()
N{
N	return this->Data.W;
N}
N
Ntemplate <typename T>
NColorTypeDef *Frame2D<T>::GetBuff ()
N{
N	return this->Data.Frame;
N}
N
Ntemplate <typename T>
NColorTypeDef *Frame2D<T>::GetBuff (b2D rect)
N{
N	return (this->Data.Frame + rect.y + rect.x * this->Data.H);
N}
N
Ntemplate <typename T>
Nvoid Frame2D<T>::FillDMA (ColorTypeDef color)
N{
N	this->PointToFill = color;
N	this->DmaTransfer(this->Data.Frame, &this->PointToFill, this->Data.W * this->Data.H);
N}
N
N
N
N
Ntemplate <typename T>
NFrame2DManager<T>::Frame2DManager () {}
N	
Ntemplate <typename T>
Nvoid Frame2DManager<T>::operator () ()
N{
N
N}
N
Ntemplate <typename T>
NFrame2D<T> *Frame2DManager<T>::Create (b2D rect)
N{
N	Frame2D<T> *frame = this->New((rect.h * rect.w) * sizeof(ColorTypeDef));
N	*this + frame;
N	(*frame)(rect);
N	return frame;
N}
N
Ntemplate <typename T>
NFrame2D<T> *Frame2DManager<T>::Access (uint32_t id)
N{
N	Frame2D<T> *frame = this->Get(id);
N	return frame;
N}
N#endif /*FRAME_CLASS_H*/
N
N
N
N/*End Of File*/
L 7 ".\device\GUI\inc\Screen.h" 2
N#include "list.h"
N#include "geometry.h"
N#include "locker.h"
L 1 ".\misc\inc\locker.h" 1
N#ifndef __LOCKER
N#define __LOCKER
N#include <stdint.h>
N
Nclass Locker {
N	public: 
N		Locker ();
N	  void Unlock (uint32_t = 0);
N	  void Lock (uint32_t = 0);
N	  bool Test ();
N  private:
N    bool lock;		
N};
N
N
N
N#endif
N
L 10 ".\device\GUI\inc\Screen.h" 2
N
N#include "affine_tf.h"
L 1 ".\misc\inc\affine_tf.h" 1
N#ifndef AFFINE_TF_H
N#define AFFINE_TF_H
N#include "geometry.h"
N#include <math.h>
N
Nclass Affine_Body {
N	public:
N		Affine_Body ();
N	  void operator () ();
N	  f2D PointRotateZ (f2D, float);
N	  f2D PointRotateZ (float, float, float, float, float);
N	private:
N	  	
N	
N};
N
Ntemplate <typename T>
NT Sqr (T, T);
N
N
N#endif /*AFFINE_TF_H*/
N
N/*End Of File*/
N
L 12 ".\device\GUI\inc\Screen.h" 2
N
N#include "screen_obj.h"
L 1 ".\device\GUI\inc\screen_obj.h" 1
N#ifndef SCREEN_OBJ_CPP
N#define SCREEN_OBJ_CPP
N
N#include <stdint.h>
N#include "frame_class.h"
N
Ntemplate <typename T>
Nclass Screen_Obj {
N	public:
N		Screen_Obj ();
N	  void operator () (T &);
N	protected:
N		T *Screen;
N	  ColorTypeDef *Frame;
N	  uint32_t H;
N};
N
N
Ntemplate <typename T>
NScreen_Obj<T>::Screen_Obj () {}
N		
Ntemplate <typename T>
Nvoid Screen_Obj<T>::operator () (T &screen)
N{
N	this->Screen = &screen;
N	uint32_t h = (uint32_t)this->Screen->Frame->GetH();
N	this->H = h;
N	this->Frame = this->Screen->Frame->GetBuff();
N}
N
N
N#endif /*SCREEN_OBJ_CPP*/
N
N/*End Of File*/
L 14 ".\device\GUI\inc\Screen.h" 2
N#include "fill_class.h"
L 1 ".\device\GUI\inc\fill_class.h" 1
N#ifndef FILL_CLASS_CPP
N#define FILL_CLASS_CPP
N
N#ifdef SOFTWARE_GL
N
N#include "frame_class.h"
N#include "screen_obj.h"
N
N#ifndef GUI_FILL_TRIG_JITTER
N#define GUI_FILL_TRIG_JITTER 3
N#endif
N
Ntemplate <typename T> 
Nclass Fill_Class : public Screen_Obj<T> {
N  public:
N    Fill_Class ();
N    int32_t Fill (ColorTypeDef = StdColBlack);	
N	  int32_t Fill (b2D, ColorTypeDef = StdColBlack);
N	  int32_t Fill (gbasic_t, gbasic_t, gbasic_t, gbasic_t, ColorTypeDef = StdColBlack);
N	  int32_t FillX (b2D, ColorTypeDef = StdColBlack, uint8_t = GUI_FILL_TRIG_JITTER);
X	  int32_t FillX (b2D, ColorTypeDef = StdColBlack, uint8_t = 3);
N	  int32_t FillY (b2D, ColorTypeDef = StdColBlack);
N	protected:
N	  friend class Screen; 
N};
N
N
Ntemplate <typename T>
NFill_Class<T>::Fill_Class (){}
N
Ntemplate <typename T>
Nint32_t Fill_Class<T>::Fill (ColorTypeDef color)
N{
N	if (this->Screen->Test()) return -1;
N	
N	register int32_t x = this->Screen->X0;
N	register uint32_t y = this->Screen->Y0;
N	register uint32_t D = this->H * x;
N	
N  for (int32_t __x = D + this->H * this->Screen->W; __x > D; __x -= this->H)  
N    for (uint32_t __y = this->Screen->H + y - 1; __y > y; __y--)
N        this->Frame[(uint32_t)__y + (uint32_t)__x] = color;
N	return 0;
N}
N
N
N
Ntemplate <typename T>
Nint32_t Fill_Class<T>::Fill (b2D __rect, ColorTypeDef color)
N{
N	static b2D rect;
N	rect = __rect;
N	if (this->Screen->Test()) return -1;
N	this->Screen->Trunc(&rect);
N	
N	register int32_t x = rect.x;
N	register uint32_t y = rect.y;
N	register uint32_t h = this->H;
N	register uint32_t D = h * x;
N	
N  for (int32_t __x = D + h * rect.w; __x > D; __x -= h)  
N    for (uint32_t __y = rect.h + y - 1; __y > y; __y--)
N        this->Frame[__y + __x] = color;
N	return 0;
N}
N
Ntemplate <typename T>
Nint32_t Fill_Class<T>::Fill (gbasic_t xt0, gbasic_t yt0, gbasic_t xt, gbasic_t yt, ColorTypeDef color)
N{
N	static b2D rect = {xt0, yt0, xt, yt};
N	return this->Fill (rect, color);
N}
N
Ntemplate <typename T>
Nint32_t Fill_Class<T>::FillX (b2D rect, ColorTypeDef color, uint8_t jitter)
N{
N	if (this->Screen->Test()) return -1;
N	ColorTypeDef *ftarget = this->Frame;
N	ColorTypeDef *target = (ColorTypeDef *)0;
N	this->Screen->Trunc(&rect);
N	
N	register uint32_t H = this->H;
N	register uint32_t x0 = (uint32_t)rect.x * H;
N	register uint32_t y0 = (uint32_t)rect.y;
N	register uint32_t h = (uint32_t)rect.h * H;
N	register uint32_t w = (uint32_t)rect.w;
N	uint32_t Key = 0;
N	
N    for (uint32_t __y = y0 + w; __y > y0; __y--) {  
N       for (uint32_t __x = x0 + h; __x > x0; __x -= H) {
N				target = ftarget + __y + __x + H;
N				if (*(target) == color && *(target - H) != color )
N					 Key ^= 1;
N			  if (Key)*(target) = color;
N			
N			}
N			Key = 0;
N		}
N	return 0;	
N}
N
Ntemplate <typename T>
Nint32_t Fill_Class<T>::FillY (b2D rect, ColorTypeDef color)
N{
N	if (this->Screen->Test()) return -1;
N	ColorTypeDef *ftarget = this->Frame;
N	ColorTypeDef *target = (ColorTypeDef *)0;
N	this->Screen->Trunc(&rect);
N	
N	register uint32_t H = this->H;
N	register uint32_t x0 = rect.x * H;
N	register uint32_t y0 = rect.y;
N	register uint32_t h = rect.h * H;
N	register uint32_t w = rect.w;
N	uint32_t Key = 0;
N	
N    for (uint32_t __x = x0 + h; __x > x0; __x -= H) {  
N      for (uint32_t __y = y0 + w; __y > y0; __y--) {
N				target = ftarget + __y + __x - 1;
N				if (*(target + 1) == color && *target != color)
N					 Key ^= 1;
N			  if (Key)*(target + 1) = color;
N			}
N			Key = 0;
N		}
N	return 0;	
N}
N
N#else /*!SOFTWARE_GL*/
S
N#endif /*SOFTWARE_GL*/
N
N
N#endif /*FILL_CLASS_CPP*/
L 15 ".\device\GUI\inc\Screen.h" 2
N#include "bitmap_class.h"
L 1 ".\device\GUI\inc\bitmap_class.h" 1
N#ifndef BITMAP_CLASS_H
N#define BITMAP_CLASS_H
N
N#ifdef SOFTWARE_GL
N
N#include <stdint.h>
N#include "Frame_Class.h"
N#include "screen_obj.h"
N#include "print_class.h"
L 1 ".\device\GUI\inc\print_class.h" 1
N#ifndef PRINT_CLASS_H
N#define PRINT_CLASS_H
N
N#include <stdint.h>
N#include "String_Defs.h"
L 1 ".\device\GUI\inc\String_Defs.h" 1
N#ifndef STRING_DEFS_H
N#define STRING_DEFS_H
N#include <stdint.h>
N
Nstruct bar_t {
N  const char* __string;
N  uint16_t __len;    
N};
N
Ntypedef struct {
N	union __Buff {
N		const char *Const;
N		char       *Ram;    
N	} Buff;
N	uint32_t Size;
N} __TEXT;
N
N#endif /*STRING_DEFS_H*/
N
N/*End Of File*/
L 6 ".\device\GUI\inc\print_class.h" 2
N#include "Frame_Class.h"
N#include "screen_obj.h"
N#include "list.h"
N
Nenum FormatEnum{
N	StrFormatTabOnly      = 0,
N	StrFormatSpaceOnly    = 1,
N	StrFormatTimeOnly     = 2,
N};
N
Ntemplate <typename T>
Nclass Print_Class : public Screen_Obj<T> ,
N	                  public List_Node<tFont, uint8_t>{
N  public:
N	  Print_Class ();
N	  void Init ();
N	  void UseFont (const tFont *Font);
N	  b2D Char (b2D, char, ColorTypeDef = StdColBlack);
N	  b2D Char (char, ColorTypeDef);
N	template <typename char_t>
N	  b2D String (b2D, char_t *, gbasic_t, ColorTypeDef = StdColBlack);
N	template <typename char_t>
N	  b2D fString (char_t *, gbasic_t, ColorTypeDef = StdColBlack);
N	template <typename char_t>
N	  b2D String (char_t *, gbasic_t, ColorTypeDef = StdColBlack);
N	
N	
N	  b2D String (b2D, __TEXT , ColorTypeDef = StdColBlack);
N	  b2D String (__TEXT , ColorTypeDef = StdColBlack);
N  private:
N		int32_t GetCharCode (char);
N		b2D Caret;
N	  gbasic_t EofX, EofY;
N	  gbasic_t FontW, FontH;
N	  const tFont *Font;
N	  uint8_t Format;
N};
N
Ntemplate <typename T>
NPrint_Class<T>::Print_Class() {}
N	
Ntemplate <typename T>
Nvoid Print_Class<T>::Init ()
N{
N	this->EofX = this->Screen->GetRect().w;
N	this->EofY = this->Screen->GetRect().h;
N  this->Font = (tFont *)0;	
N	this->Format = 0;
N}	
N
Ntemplate <typename T>
Nvoid Print_Class<T>::UseFont (const tFont *font)
N{
N  this->Font = font;
N	this->FontW = font->W;
N	this->FontH = font->H;
N}	
N
Ntemplate <typename T>
Nint32_t Print_Class<T>::GetCharCode (char symbol)
N{
N  if (this->Font == (tFont *)0) return -1;
N  uint32_t code = 0;
N  uint32_t quantity = this->Font->Quantity;
N  while ((code != symbol) && (quantity--))
N        code = this->Font->CharArray[quantity].Code;
N  return quantity;  
N}	
N
Ntemplate <typename T>
Nb2D Print_Class<T>::Char(b2D rect, char code, ColorTypeDef color)
N{
N  if (this->Font == (tFont *)0) return rect;
N	
N  code = this->GetCharCode(code);
N  const tImage *Img = this->Font->CharArray[code].Image;
N  this->Screen->Bitmap.Draw(rect, Img, StdColWhite);
N	this->Caret.x = Img->W + rect.x;
N	this->Caret.w -=Img->W;
N  return this->Caret;
N}
N
Ntemplate <typename T>
Nb2D Print_Class<T>::Char(char code, ColorTypeDef color)
N{
N	b2D rect;
N	return rect;
N}
N
Ntemplate <typename T> template <typename char_t>
Nb2D Print_Class<T>::String(b2D rect, char_t *str, gbasic_t len, ColorTypeDef color)
N{
N	if (this->Screen->Test()) return rect;
N	
N	this->Caret = rect;
N	char_t C = '0';
N    uint32_t __i = 0;
N    while (len--) {
N			C = *(str + __i++);
N      if (this->Caret.x > (rect.w + rect.x) || (C == '\n')) {
N          this->Caret.x = rect.x;
N				  this->Caret.w = rect.w;
N          this->Caret.y += this->FontH;
N				  this->Caret.h -= this->FontH;
N			} else {}
N      if (this->Caret.y > rect.h + rect.y) {
N          return this->Caret;
N      } else {}	
N      if ((C != '\n')) {				
N        this->Char(this->Caret, C);		
N			} else {}				
N    }
N	return this->Caret;
N}
N
Ntemplate <typename T> template <typename char_t>
Nb2D Print_Class<T>::String(char_t *str, gbasic_t len, ColorTypeDef color)
N{
N	return this->String(this->Caret, str, len, color);
N}
N
Ntemplate <typename T> template <typename char_t>
Nb2D Print_Class<T>::fString(char_t *str, gbasic_t len, ColorTypeDef color)
N{
N	b2D rect = this->Screen->GetRect();
N	rect.x = 0;
N	rect.y = 0;
N	return this->String(rect, str, len, color);
N}
N
Ntemplate <typename T>
Nb2D Print_Class<T>::String(b2D rect, __TEXT text, ColorTypeDef color)
N{
N	return this->String(rect, text.Buff.Ram, text.Size, color);
N}
N
Ntemplate <typename T> 
Nb2D Print_Class<T>::String(__TEXT text, ColorTypeDef color)
N{
N	b2D rect = this->Screen->GetRect();
N	rect.x = 0;
N	rect.y = 0;
N	return this->String(rect, text.Buff.Ram, text.Size, color);
N}
N
N
N#endif /*PRINT_CLASS_CPP*/
N
L 10 ".\device\GUI\inc\bitmap_class.h" 2
N
N
Ntemplate <typename T> 
N	class Bitmap_Class : public Screen_Obj<T> {
N	public:
N		Bitmap_Class ();
N	  template <typename img_t>
N	    int32_t Draw (b2D, img_t *, ColorTypeDef = StdColBlack);
N		template <typename img_t>
N			int32_t Draw (gbasic_t, gbasic_t, img_t *, ColorTypeDef = StdColBlack);
N		
N		
N		template <typename img_d, typename img_t>
N	    int32_t Copy (b2D, img_d *, img_t *, ColorTypeDef = StdColBlack);
N		template <typename img_d, typename img_t>
N	    int32_t Copy (gbasic_t, gbasic_t, img_d *, img_t *, ColorTypeDef = StdColBlack);
N		template <typename img_d, typename img_t>
N	    int32_t Copy (img_d *, img_t *, ColorTypeDef = StdColBlack);
N		
N		template <typename img_t, typename img_d>
N	    img_d *Rotate (img_d *, img_t *, float, ColorTypeDef = StdColBlack);
N		template <typename img_t, typename img_d>
N	    img_d *Rotate90 (img_d *, img_t *, ColorTypeDef = StdColBlack);
N		template <typename img_t, typename img_d>
N	    img_d *Rotate180 (img_d *, img_t *, ColorTypeDef = StdColBlack);
N		template <typename img_t, typename img_d>
N	    img_d *Rotate270 (img_d *, img_t *, ColorTypeDef = StdColBlack);
N		template <typename img_t, typename img_d>
N	    img_d *Rotate0 (img_d *, img_t *, ColorTypeDef = StdColBlack);
N		
N		template <typename img_t, typename img_d>
N	    img_d  *FlipVertical (img_d *, img_t *, float, ColorTypeDef = StdColBlack);
N		template <typename img_t, typename img_d>
N	    img_d  *FlipHorizontal (img_d *, img_t *, float, ColorTypeDef = StdColBlack);
N		
N		template <typename img_t, typename img_d>
N	    img_d  *ShrinkX (img_d *, img_t *, float, ColorTypeDef = StdColBlack);
N		template <typename img_t, typename img_d>
N	    img_d  *ShrinkY (img_d *, img_t *, float, ColorTypeDef = StdColBlack);
N		template <typename img_t, typename img_d>
N	    img_d  *ExpandX (img_d *, img_t *, float, ColorTypeDef = StdColBlack);
N		template <typename img_t, typename img_d>
N	    img_d  *ExpandY (img_d *, img_t *, float, ColorTypeDef = StdColBlack);
N		template <typename img_t, typename img_d>
N	    img_d  *ResizeX (img_d *, img_t *, float, ColorTypeDef = StdColBlack);
N		template <typename img_t, typename img_d>
N	    img_d  *ResizeY (img_d *, img_t *, float, ColorTypeDef = StdColBlack);
N		template <typename img_t, typename img_d>
N	    img_d  *Resize (img_d *, img_t *, float, float, ColorTypeDef = StdColBlack);
N		template <typename img_t, typename img_d>
N	    img_d  *Resize (b2D, img_d *, img_t *, ColorTypeDef = StdColBlack);
N		
N		template <typename img_t>
N	    int32_t Tile (b2D, img_t *, ColorTypeDef = StdColBlack);
N		template <typename img_t>
N		  int32_t TileLarge (b2D, img_t *, ColorTypeDef = StdColBlack);
N		
N		
N		template <typename img_t>
N		  int32_t Fill (img_t *, ColorTypeDef = StdColBlack);
N		
N		  int32_t NewBitmapOpen (tTexture &);
N		  int32_t NewBitmapClose ();
N	    void SetScale (b2D);
N		  void SetScale (float, float);
N		  void setBlendLevel (uint8_t = 0);
N	private:
N	  	
N	
N	  template <typename img_t>
N	    int32_t DrawScaled (b2D, img_t *, ColorTypeDef = StdColBlack);
N		template <typename img_t>
N	    int32_t DrawNoScale (b2D, img_t *, ColorTypeDef = StdColBlack);
N		
N		template <typename dest, typename src>
N	    dest  *ShiftRight ( dest *, src *, uint32_t, float, ColorTypeDef = StdColBlack);
N		template <typename  dest, typename src>
N	    dest  *ShiftLeft ( dest *, src *, uint32_t, float, ColorTypeDef = StdColBlack);
N		template <typename  dest, typename src>
N	    dest  *ShiftUp ( dest *, src *, uint32_t, float, ColorTypeDef = StdColBlack);
N		template <typename  dest, typename src>
N	    dest  *ShiftDown ( dest *, src *, uint32_t, float, ColorTypeDef = StdColBlack);
N	  
N	  uint8_t scale_x, scale_y;
N		b2D TempFrameDataRect;
N		Frame2D<gbasic_t> *TempFrameDataPackP;
N		uint8_t BlendLevel;
N		
N		
N	friend class Print_Class<T>;
N};
N	
N
Ntemplate <typename T>
NBitmap_Class<T>::Bitmap_Class ()
N{
N}
N		
Ntemplate <typename T> template <typename img_t>
Nint32_t Bitmap_Class<T>::DrawNoScale (b2D rect, img_t *image, ColorTypeDef color)
N{
N	if (this->Screen->Test()) return -1;
N	this->Screen->Trunc(&rect);
N	uint32_t gh = this->H;
N  uint32_t x = rect.x * gh, xi = 0;
N	uint32_t w = GUI_min(rect.w, image->W);
X	uint32_t w = ((rect . w) < (image ->W) ? (rect . w) : (image ->W));
N	uint32_t h = GUI_min(rect.h, image->H);
X	uint32_t h = ((rect . h) < (image ->H) ? (rect . h) : (image ->H));
N	int32_t y0 = rect.y;
N	uint32_t iw = image->W;
N	
N	ColorTypeDef *dest = this->Frame;
N  const ColorTypeDef *src = image->Image;
N	
N  uint32_t S = h * iw;
N  ColorTypeDef target = color;
N	if (color != StdColBlack) {
N		for (; xi < w; x += gh, xi++) {  
N			for (uint32_t y = y0 + x, yi = xi, t = S + xi; yi < t; y++, yi += iw) {
N				target = src[yi];
N				if (target != color) {
N					dest[y] = target;   
N				} else {}
N			}
N		}
N  } else {
N		for (; xi < w; x += gh, xi++) {  
N			for (uint32_t y = y0 + x, yi = xi, t = S + xi; yi < t; y++, yi += iw) {
N					dest[y] = src[yi];   
N			}
N		}
N	}
N	
N	return 0;
N}
N
Ntemplate <typename T> template <typename img_d, typename img_t>
Nint32_t Bitmap_Class<T>::Copy (b2D rect, img_d *img_dest, img_t *image, ColorTypeDef color)
N{
N	if (this->Screen->Test()) return -1;
N	
N  uint32_t x = rect.x * img_dest->H, xi = 0;
N	uint32_t w = image->W;
N	uint32_t h = image->H;
N	
N  register int32_t wd = img_dest->W;
N		
N	register const ColorTypeDef *src = image->Image;
N	register ColorTypeDef *dest = img_dest->Image;
N	
N  uint32_t S = h * w;
N  ColorTypeDef target = color;
N	
N	if (color != StdColBlack) {
N		for (; xi < w; x++, xi++) {  
N			for (uint32_t y = rect.y, yi = 0; yi < S; y += wd, yi += w) {
N				target = src[xi + yi];
N				if (target != color) {
N					dest[y + x] = target;   
N				} else {}
N			}
N		}
N  } else {	
N		for (; xi < w; x++, xi++) {  
N			for (uint32_t y = rect.y, yi = 0; yi < S; y += wd, yi += w) {
N					dest[y + x] = src[xi + yi];   
N			}
N		}
N	}
N	return 0;
N}
N
Ntemplate <typename T> template <typename img_t>
Nint32_t Bitmap_Class<T>::DrawScaled (b2D rect, img_t *image, ColorTypeDef color)
N{
N	if (this->Screen->Test()) return -1;
N	if (!this->scale_x || !this->scale_y) {
N		  return this->DrawNoScale(rect, image, color);
N	}
N	rect.w = image->W * this->scale_x;
N	rect.h = image->H * this->scale_y;
N	this->Screen->Trunc(&rect);
N	
N	register uint32_t h  = this->H;
N	register uint32_t ys = this->scale_y;
N	register uint32_t xs = this->scale_x;
N	register uint32_t xt = rect.w / xs;
N	register uint32_t yt = rect.h / ys;	
N	
N  register uint32_t S = yt * image->W;
N	register ColorTypeDef *target = this->Frame;
N	register const ColorTypeDef *source = image->Image;
N	ColorTypeDef targ = color;
N	register uint32_t ws = image->W;
N	if (color == StdColBlack) {
N		for (uint32_t xi = 0, x = rect.x * h; xi < xt; xi++) { 
N				for (uint32_t d = x + xs * h; x < d; x += h) {
N						for (uint32_t y = rect.y + 1, yi = 0; yi < S; yi += ws) {
N								for (uint32_t d = y + ys; y < d; y++) {
N									 target[y + x] = source[xi + yi]; 
N								}
N						}
N				}
N		}	
N  }	else {
N		for (uint32_t xi = 0, x = rect.x * h; xi < xt; xi++) { 
N				for (uint32_t d = x + xs * h; x < d; x += h) {
N						for (uint32_t y = rect.y + 1, yi = 0; yi < S; yi += ws) {
N								for (uint32_t d = y + ys; y < d; y++) {
N									  targ = source[xi + yi];
N									  if (targ != color) {
N										    target[y + x] = targ;
N										} else {}	
N								}
N						}
N				}
N		}			
N	}
N	return 0;
N}
N
N
Ntemplate <typename T> template <typename dest_t, typename src_t>
Ndest_t *Bitmap_Class<T>::ShiftRight (dest_t *dest, src_t *src, uint32_t w, float A, ColorTypeDef color)
N{
N	int32_t S = w * w;
N	int32_t C = (int32_t)((float)(w / 2) * A) * w;
N	
N	int32_t xi = 0;
N	float j;
N	int32_t yi = 0;
N	int32_t t = 0;
N	int32_t W = w + C;
N  for (yi = 0, j = 0; yi < w; yi++, j += A) {  
N		for (xi = yi, t = S + yi; xi < t; xi += w) {
N				dest[xi - (int32_t)(j) * w + C] = src[xi];   
N		}
N	}
N	return dest;
W ".\device\GUI\inc\bitmap_class.h" 241 10 variable "W" was declared but never referenced
N}
N
Ntemplate <typename T> template <typename dest_t, typename src_t>
Ndest_t *Bitmap_Class<T>::ShiftLeft (dest_t *dest, src_t *image, uint32_t w, float A, ColorTypeDef color)
N{
N	return this->ShiftRight(dest, image, w, -A, color);
N}
N
Ntemplate <typename T> template <typename dest_t, typename src_t>
Ndest_t *Bitmap_Class<T>::ShiftDown (dest_t *dest, src_t *src, uint32_t w, float A, ColorTypeDef color)
N{
N	int32_t S = w * w;
N	int32_t C = -(int32_t)((float)(w / 2) * A);
N	
N	int32_t xi = S;
N  for (float j = 0; xi > 0; xi -= w, j -= A) {  
N		for (int32_t c = ((int32_t)(j) - C), t = w + xi, yi = xi; yi < t; yi++) {
N				dest[yi + c] = src[yi];   
N		}
N	}
N	return dest;
N}
N
Ntemplate <typename T> template <typename dest_t, typename src_t>
Ndest_t *Bitmap_Class<T>::ShiftUp (dest_t *dest, src_t *image, uint32_t w, float A, ColorTypeDef color)
N{
N	return this->ShiftDown(dest, image, w, -A, color);
N}
N
Ntemplate <typename T> template <typename img_t, typename img_d>
Nimg_d *Bitmap_Class<T>::FlipVertical (img_d *img_dest, img_t *img_src, float A, ColorTypeDef color)
N{
N	if (this->Screen->Test()) return img_dest;
N	
N  uint32_t w = img_src->W;
N	uint32_t h = img_src->H;
N	uint32_t hd = img_dest->H;
N  uint32_t S = h * img_src->W;
N	ColorTypeDef *target = img_dest->Image;
N	ColorTypeDef *src = img_src->Image;
N	
N	uint32_t x = 0, xi = w;
N		for (; xi > 0; x += hd, xi--) {  
N			for (uint32_t y = 0, yi = 0; yi < S; y++, yi += w) {
N					target[y + x] = src[xi + yi];   
N			}
N		}
N	return img_src;
N}
N
Ntemplate <typename T> template <typename img_t, typename img_d>
Nimg_d *Bitmap_Class<T>::FlipHorizontal (img_d *img_dest, img_t *img_src, float A, ColorTypeDef color)
N{
N	if (this->Screen->Test()) return img_dest;
N	
N	uint32_t w = img_src->W;
N	uint32_t h = img_src->H;
N	uint32_t hd = img_dest->H;
N    uint32_t S = h * img_src->W;
N	ColorTypeDef *target = img_dest->Image;
N	ColorTypeDef *src = img_src->Image;
N	
N	uint32_t x = 0, xi = w;
N		for (; xi > 0; x += hd, xi--) {  
N			for (uint32_t y = 0, yi = 0; yi < S; y++, yi += w) {
N					target[y + x] = src[xi + yi];   
N			}
N		}
N	return img_src;
N}
N
Ntemplate <typename T> template <typename img_t, typename img_d>
N	img_d *Bitmap_Class<T>::ShrinkX (img_d *img_dest, img_t *img_src, float A, ColorTypeDef color)
N{
N	if (this->Screen->Test()) return img_dest;
N	
N  uint32_t w = img_src->W;
N	uint32_t h = img_src->H;
N	uint32_t wd = img_dest->W;
N  uint32_t S = h * w;
N	ColorTypeDef *target = img_dest->Image;
N	const ColorTypeDef *src = img_src->Image;
N	float Ax = 0, An = 0;;
N	
N	uint32_t x = 0, xi = 0;
N	/*
N			for (; xi < w; x++, xi++) {  
N			for (uint32_t y = rect.y, yi = 0; yi < S; y += wd, yi += w) {
N					dest[y + x] = src[xi + yi];   
N			}
N		}
N	*/
N		for (x = 0, xi = 0; xi < S; xi += w) {  
N			Ax += A;
N			if ((Ax - An) > 1.0F) {
N				An += 1.0F;
N				for (uint32_t y = x, yi = xi, t = h + xi; yi < t; y += wd, yi++) {
N						target[y] = src[yi];   
N				}
N				x++;
N		  } else {}
N		}
N	return img_dest;
N}
N
Ntemplate <typename T> template <typename img_t, typename img_d>
N	img_d *Bitmap_Class<T>::ShrinkY (img_d *img_dest, img_t *img_src, float A, ColorTypeDef color)
N{
N	if (this->Screen->Test()) return img_dest;
N	
N  uint32_t w = img_src->W;
N	uint32_t h = img_src->H;
N	uint32_t wd = img_dest->W;
N  uint32_t S = h * img_src->W;
N	ColorTypeDef *target = img_dest->Image;
N	const ColorTypeDef *src = img_src->Image;
N	float Ay = 0, An = 0;
N	
N	uint32_t x = 0, xi = 0;
N		for (uint32_t y = 0, yi = 0; yi < S; yi += w) {  
N			Ay += A;
N			if ((Ay - An) > 1.0F) {
N				An += 1;
N				for (x = y, xi = yi; xi < w + yi; x++, xi++) {
N						target[x] = src[xi];   
N				}
N				y += wd;
N		  } else {}
N		}
N	return img_dest;
N}
N
Ntemplate <typename T> template <typename img_t, typename img_d>
N	img_d *Bitmap_Class<T>::ExpandX (img_d *img_dest, img_t *img_src, float A, ColorTypeDef color)
N{
N	if (this->Screen->Test()) return img_dest;
N	
N  uint32_t w = img_src->W;
N	uint32_t h = img_src->H;
N	uint32_t wd = img_dest->W;
N  uint32_t S = h * w;
N	ColorTypeDef *target = img_dest->Image;
N	const ColorTypeDef *src = img_src->Image;
N	if (A != 0) {
N	  A = (1.0F - 1 / A);
N	}
N	float Ax = 0, An = 0;
N	
N	uint32_t x = 0, xi = 0;
N		for (; xi < w; x++) {  
N			Ax += A;
N			if ((Ax - An) > 1.0F) {
N				An += 1.0F;
N		  } else {
N			    xi++;
N			}
N			for (uint32_t y = x, yi = xi, t = S + xi; yi < t; y += wd, yi += w) {
N						target[y] = src[yi];   
N			}
N		}
N	return img_dest;
N}
N
Ntemplate <typename T> template <typename img_t, typename img_d>
N	img_d *Bitmap_Class<T>::ExpandY (img_d *img_dest, img_t *img_src, float A, ColorTypeDef color)
N{
N	if (this->Screen->Test()) return img_dest;
N	
N  uint32_t w = img_src->W;
N	uint32_t h = img_src->H;
N	uint32_t wd = img_dest->W;
N  uint32_t S = h * w;
N	ColorTypeDef *target = img_dest->Image;
N	const ColorTypeDef *src = img_src->Image;
N	if (A != 0) {
N	  A = (1.0F - 1 / A);
N	}
N	float Ax = 0, An = 0;
N	
N	uint32_t x = 0, xi = 0;
N		 for (uint32_t y = 0, yi = 0; yi < S; y += wd){  
N			Ax += A;
N			if ((Ax - An) > 1.0F) {
N				An += 1.0F;
N		  } else {
N			    yi += w;
N			}
N			for (x = y, xi = yi; xi < w + yi; x++, xi++) {
N				  target[x] = src[xi];   
N			}
N		}
N	return img_dest;
N}
N
Ntemplate <typename T> template <typename img_t, typename img_d>
N	img_d *Bitmap_Class<T>::ResizeY (img_d *img_dest, img_t *img_src, float A, ColorTypeDef color)
N{
N	if (A > 1.0F) {
N		return this->ExpandY(img_dest, img_src, A, color);
N	} else {
N		return this->ShrinkY(img_dest, img_src, A, color);
N	}
N}
N
Ntemplate <typename T> template <typename img_t, typename img_d>
N	img_d *Bitmap_Class<T>::ResizeX (img_d *img_dest, img_t *img_src, float A, ColorTypeDef color)
N{
N	if (A > 1.0F) {
N		return this->ExpandX(img_dest, img_src, A, color);
N	} else {
N		return this->ShrinkX(img_dest, img_src, A, color);
N	}
N}
N
Ntemplate <typename T> template <typename img_t, typename img_d>
N	img_d *Bitmap_Class<T>::Resize (img_d *dest, img_t *src, float A, float B, ColorTypeDef color)
N{
N	gbasic_t w = (uint32_t)abs(floor((float)src->W * A));
N	gbasic_t h = (uint32_t)abs(floor((float)src->H * B));
N	b2D rect = {0, 0, w, h};
N	return this->Resize(rect, dest, src, color);
N}
N
N
Ntemplate <typename T> template <typename img_t, typename img_d>
N	img_d *Bitmap_Class<T>::Resize (b2D rect, img_d *img_dest, img_t *img_src, ColorTypeDef color)
N{
N	tTexture *texture = this->Screen->MakeTexture(90, 90);
N	if (! texture) {
N		return img_src;
N	} else {}
N	texture->H = img_src->H;
N	texture->W = rect.w;
N	img_dest->W = rect.w;
N	img_dest->H = rect.h;
N	float A = (float)rect.w / (float)img_src->W;
N	float B = (float)rect.h / (float)img_src->H;
N	
N	this->Fill(texture);	
N	this->ResizeX(texture, img_src, A);	
N	this->Fill(img_dest);
N	this->ResizeY(img_dest, texture, B);	
N	
N	this->Screen->KillTexture(texture);
N	return img_dest;
N}
N
Ntemplate <typename T> template <typename img_t, typename img_d>
Nimg_d *Bitmap_Class<T>::Rotate90 (img_d *img_dest, img_t *img_src, ColorTypeDef color)
N{
N	if (this->Screen->Test()) return img_dest;
N	uint32_t w = img_src->W;
N  uint32_t S = w * w;
N	ColorTypeDef *target = img_dest->Image;
N	ColorTypeDef *src = img_src->Image;
N	
N	uint32_t xi = 0;
N		for (; xi < S; xi += w) {  
N			for (uint32_t y = xi, yi = w + xi; yi > xi; y++, yi--) {
N					target[y] = src[yi];   
N			}
N		}
N	return img_dest;
N}
N
Ntemplate <typename T> template <typename img_t, typename img_d>
Nimg_d *Bitmap_Class<T>::Rotate180 (img_d *img_dest, img_t *img_src, ColorTypeDef color)
N{
N	if (this->Screen->Test()) return img_dest;
N	
N	uint32_t w = img_src->W;
N  uint32_t S = w * w;
N	ColorTypeDef *target = img_dest->Image;
N	ColorTypeDef *src = img_src->Image;
N	
N	uint32_t x = 0, xi = w;
N		for (; xi > 0; x += w, xi--) {  
N			for (uint32_t y = x, yi = S + xi; yi > xi; y++, yi -= w) {
N					target[y] = src[yi];   
N			}
N		}
N	return img_src;
N}
N
Ntemplate <typename T> template <typename img_t, typename img_d>
Nimg_d *Bitmap_Class<T>::Rotate270 (img_d *img_dest, img_t *img_src, ColorTypeDef color)
N{
N	if (this->Screen->Test()) return img_dest;
N
N	uint32_t w = img_src->W;
N  uint32_t S = w * w;
N	ColorTypeDef *target = img_dest->Image;
N	ColorTypeDef *src = img_src->Image;
N	
N	uint32_t x = 0, xi = S;
N		for (; xi > 0; x += w, xi -= w) {  
N			for (uint32_t y = x, yi = xi, t = w + xi; yi < t; y++, yi++) {
N					target[y] = src[yi];   
N			}
N		}
N	return img_dest;
N}
N
Ntemplate <typename T> template <typename img_t, typename img_d>
Nimg_d *Bitmap_Class<T>::Rotate0 (img_d *img_dest, img_t *img_src, ColorTypeDef color)
N{
N	if (this->Screen->Test()) return img_dest;
N	
N  uint32_t w = img_src->W;
N  uint32_t S = w * w;
N	ColorTypeDef *target = img_dest->Image;
N	ColorTypeDef *src = img_src->Image;
N	
N	uint32_t x = 0, xi = 0;
N		for (; xi < w; x += w, xi++) {  
N			for (uint32_t y = x, yi = xi, t = S + xi; yi < t; y++, yi += w) {
N					target[y] = src[yi];   
N			}
N		}
N	return img_src;
N}
N
Ntemplate <typename T> template <typename img_t>
Nint32_t Bitmap_Class<T>::Tile (b2D rect, img_t *image, ColorTypeDef color)
N{
N	
N	if (this->Screen->Test()) return -1;
N	
N	this->Screen->Trunc(&rect);
N	uint32_t x0 = rect.x;
N	uint32_t y0 = rect.y;
N	uint32_t w  = rect.w + x0;
N	uint32_t h  = rect.h + y0;
N	uint32_t img_w = image->W;
N	uint32_t img_h = image->H;
N	uint32_t cut_x = 0;
N	uint32_t cut_y = 0;
N	uint32_t h0 = this->H;
N	uint32_t t_y;
N	
N	ColorTypeDef *target = this->Frame;
N	ColorTypeDef *src = image->Image;
N	if (color == StdColBlack) {
N		for (; x0 < w; x0 += img_w) {
N				t_y = y0;
N			for (; y0 < h; y0 += img_h) {
N					uint32_t __x = x0 * h0;
N					uint32_t xi = 0;	
N					uint32_t i = w - x0;
N					if (i < img_w) {
N							cut_x = i;
N					} else {
N							cut_x = img_w;
N					}
N					i = h - y0;
N					if (i < img_h) {
N						 cut_y = i;
N					} else {
N					cut_y = img_h;
N					}
N					uint32_t S = cut_y * img_w;
N					for (; xi < cut_x; __x += h0, xi++) {  
N							for (uint32_t __y = y0, yi = 0; yi < S; __y++, yi += img_w) {
N									target[__y + __x] = src[xi + yi];   
N							}
N					}
N			}
N			y0 = t_y;
N		}
N  } else {
N		for (ColorTypeDef tcol = 0; x0 < w; x0 += img_w) {
N				t_y = y0;
N			for (; y0 < h; y0 += img_h) {
N					uint32_t __x = x0 * h0;
N					uint32_t xi = 0;	
N					uint32_t i = w - x0;
N					if (i < img_w) {
N							cut_x = i;
N					} else {
N							cut_x = img_w;
N					}
N					i = h - y0;
N					if (i < img_h) {
N						 cut_y = i;
N					} else {
N					cut_y = img_h;
N					}
N					uint32_t S = cut_y * img_w;
N					for (; xi < cut_x; __x += h0, xi++) {  
N							for (uint32_t __y = y0, yi = 0; yi < S; __y++, yi += img_w) {
N								  tcol = src[xi + yi];
N								  if (tcol != color) {
N									    target[__y + __x] = tcol;
N									} else {}									
N							}
N					}
N			}
N			y0 = t_y;
N		}		
N	}
N	return 0;
N}
N
Ntemplate <typename T>
Nvoid Bitmap_Class<T>::SetScale (b2D rect)
N{
N  this->scale_x = (uint8_t)rect.x;
N	this->scale_y = (uint8_t)rect.y;
N	this->BlendLevel = 0;
N}	
N
Ntemplate <typename T>
Nvoid Bitmap_Class<T>::SetScale (float x, float y)
N{
N  this->scale_x = (uint8_t)x;
N	this->scale_y = (uint8_t)y;
N	this->BlendLevel = 0;
N}	
N
Ntemplate <typename T>
Nvoid Bitmap_Class<T>::setBlendLevel (uint8_t level)
N{
N	 this->BlendLevel = level;
N}
N
Ntemplate <typename T>
Nint32_t Bitmap_Class<T>::NewBitmapOpen (tTexture &texture)
N{
N	if (this->Screen->Test()) return -1;
N	uint8_t memo[sizeof(Frame2D<gbasic_t>)];
N	Frame2D<gbasic_t>  *TempFrameDataPack = (Frame2D<gbasic_t> *)memo;
N	
N	this->TempFrameDataPackP = this->Screen->GetFrame();
N	this->TempFrameDataRect  = this->Screen->GetRect();
N    b2D rect = {0, 0, texture.W, texture.H};
N	(*TempFrameDataPack)(rect, texture.Image);
N	(*this->Screen)(rect, *TempFrameDataPack);
N	
N	return 0;
N}
N
Ntemplate <typename T>
Nint32_t Bitmap_Class<T>::NewBitmapClose ()
N{
N	if (this->Screen->Test()) return -1;
N	(*this->Screen)(this->TempFrameDataRect, *this->TempFrameDataPackP);
N	
N	return 0;
N}
N
Ntemplate <typename T> template <typename img_t>
Nint32_t Bitmap_Class<T>::Fill (img_t *image, ColorTypeDef color)
N{
N	if (this->Screen->Test()) return -1;
N	
N	ColorTypeDef *target = image->Image;
N	for (int32_t D = image->W * image->H; D > 0; D--)
N	    target[D] = color;
N	return 0;
N}
N
Ntemplate <typename T> template <typename img_t, typename img_d>
Nimg_d *Bitmap_Class<T>::Rotate (img_d *img_dest, img_t *img_src, float A, ColorTypeDef color)
N{
N	float D = ((float)GUI_max(img_src->H, img_src->W) * 2.0F );
X	float D = ((float)((img_src->H) > (img_src->W) ? (img_src->H) : (img_src->W)) * 2.0F );
N	uint32_t w = (int32_t)D;
N	img_dest->W = w;
N	img_dest->H = w;
N    
N    tTexture *texture = this->Screen->MakeTexture((int32_t)D, (int32_t)D);
N	
N	this->Fill(img_dest, StdColWhite);
N	this->Copy(img_dest, img_src, color);
N	
N	float t;
N	t = A / (PI_const / 2);
X	t = A / ((3.14159265359F) / 2);
N	t = (abs(floor(t)));
N	bool sign = false;
N	if (A > 0) {
N		A -= t * (PI_const / 2);
X		A -= t * ((3.14159265359F) / 2);
N	} else {
N		sign = true;
N		A += t * (PI_const / 2);
X		A += t * ((3.14159265359F) / 2);
N	}
N	this->Fill(&img_dest[1]);
N	int32_t j = (int32_t)t % 4;
N		if (j == 1) {
N			if (sign) {
N				this->Rotate270(texture, img_dest);
N			} else {
N			  this->Rotate90(texture, img_dest);
N			}
N		} else if (j == 2) {
N			this->Rotate180(texture, img_dest);
N		} else if (j == 3){
N			if (sign) {
N				this->Rotate90(texture, img_dest);
N			} else {
N			  this->Rotate270(texture, img_dest);
N			}
N		} else {
N			this->Rotate0(texture, img_dest);
N		}
N	A = ((PI_const / 4) - A);
X	A = (((3.14159265359F) / 4) - A);
N  
N  ColorTypeDef *Output = img_dest->Image, *Input = texture->Image;		
N		
N  this->Fill(img_dest, StdColWhite);
N	this->ShiftRight(Output, Input, w, A / 2);
N	this->Fill(texture, StdColWhite);
N  this->ShiftDown(Input, Output, w, A);
N	this->Fill(img_dest, StdColWhite);
N  this->ShiftRight(Output, Input, w, A / 2);    
N  this->Screen->KillTexture(texture);
N	return img_dest;
N}
N
N
Ntemplate <typename T> template <typename img_t>
Nint32_t Bitmap_Class<T>::Draw (b2D rect, img_t *image, ColorTypeDef color)
N{
N	return this->DrawScaled (rect, image, color);
N}
N
Ntemplate <typename T> template <typename img_t>
Nint32_t Bitmap_Class<T>::Draw (gbasic_t x0, gbasic_t y0, img_t *image, ColorTypeDef color)
N{
N	b2D rect = {x0, y0, 0, 0};
N	return this->DrawScaled (rect, image, color);
N}
N
Ntemplate <typename T> template <typename img_d, typename img_t>
Nint32_t Bitmap_Class<T>::Copy (gbasic_t x0, gbasic_t y0,img_d *img_dest, img_t *image, ColorTypeDef color)
N{
N	b2D rect = {x0, y0, 0, 0};
N	return this->Copy (rect, img_dest, image, color);
N}
N
Ntemplate <typename T> template <typename img_d, typename img_t>
Nint32_t Bitmap_Class<T>::Copy (img_d *img_dest, img_t *image, ColorTypeDef color)
N{
N	int32_t x = (img_dest->W - image->W) / 2;
N	int32_t y = (img_dest->H - image->H) / 2;
N	b2D rect = {x, y, 0, 0};
N	return this->Copy (rect, img_dest, image, color);
N}
N#else /*!SOFTWARE_GL*/
S
N#endif /*SOFTWARE_GL*/
N
N#endif /*BITMAP_CLASS_H*/
N
L 16 ".\device\GUI\inc\Screen.h" 2
N#include "circle_class.h"
L 1 ".\device\GUI\inc\circle_class.h" 1
N#ifndef CIRCLE_CLASS_CPP
N#define CIRCLE_CLASS_CPP
N
N#ifdef SOFTWARE_GL
N
N#include "Frame_Class.h"
N#include "screen_obj.h"
N
N
Ntemplate <typename T>
Nclass Circle_Class : public Screen_Obj<T> {
N	public:
N		Circle_Class();
N	  int32_t Draw (b2D, float, ColorTypeDef);
N	  int32_t Draw (gbasic_t, gbasic_t, float, ColorTypeDef);
N	  int32_t DrawFilled (b2D, float, ColorTypeDef);
N	  int32_t DrawFilled (gbasic_t, gbasic_t, float, ColorTypeDef);
N	  int32_t Round (b2D, float, ColorTypeDef, uint32_t = 2);
N	  int32_t Round (gbasic_t, gbasic_t, float, ColorTypeDef, uint32_t = 2);
N	  int32_t Arc (b2D, float, float, ColorTypeDef, float = PI_const / 16);
X	  int32_t Arc (b2D, float, float, ColorTypeDef, float = (3.14159265359F) / 16);
N	  int32_t Arc (gbasic_t, gbasic_t, float, float, ColorTypeDef, float = PI_const / 16);
X	  int32_t Arc (gbasic_t, gbasic_t, float, float, ColorTypeDef, float = (3.14159265359F) / 16);
N	  int32_t Segment (b2D, float, float, ColorTypeDef, float = PI_const / 16);
X	  int32_t Segment (b2D, float, float, ColorTypeDef, float = (3.14159265359F) / 16);
N	  int32_t Segment (gbasic_t, gbasic_t, float, float, ColorTypeDef, float = PI_const / 16);
X	  int32_t Segment (gbasic_t, gbasic_t, float, float, ColorTypeDef, float = (3.14159265359F) / 16);
N	private:
N	  int32_t Pixel (uint32_t, uint32_t, ColorTypeDef);
N	  int32_t Point (int32_t, int32_t, int32_t, int32_t, ColorTypeDef);
N	  int32_t fBotToTop (int32_t, int32_t, int32_t, int32_t, ColorTypeDef);
N	  int32_t Sqr (int32_t);
N};
N
N
Ntemplate <typename T>
NCircle_Class<T>::Circle_Class (){}
N
Ntemplate <typename T>
Nint32_t Circle_Class<T>::Sqr (int32_t val)
N{
N  return val * val;
N}
N
Ntemplate <typename T>
Nint32_t Circle_Class<T>::Pixel (uint32_t x, uint32_t y, ColorTypeDef color)
N{
N  *(this->Frame + y + x * this->H) = color;
N	return 0;
N}
Ntemplate <typename T>
Nint32_t Circle_Class<T>::Point (int32_t x0, int32_t y0, int32_t x, int32_t y, ColorTypeDef color)
N{
N	int32_t h0 = (x + x0) * this->H + y0;
N	int32_t h1 = (-x + x0) * this->H + y0;
N  *(this->Frame + y + h0) = color;
N	*(this->Frame - y + h1) = color;
N	*(this->Frame - y + h0) = color;
N	*(this->Frame + y + h1) = color;
N	return 0;
N}
N
Ntemplate <typename T>
Nint32_t Circle_Class<T>::fBotToTop (int32_t x0, int32_t y0, int32_t x, int32_t y, ColorTypeDef color)
N{
N	uint32_t h = this->H;
N	int32_t D = x0 * h + y0;
N	int32_t D0 = x * h + D;
N	int32_t D1 = -x * h + D;
N	y0 = - y;
N	y  = + y;
N	for (; y > y0; y--) {
N      *(this->Frame + y + D0) = color;
N		  *(this->Frame + y + D1) = color;
N	}
N	return 0;		
N}
N
Ntemplate <typename T>
Nint32_t Circle_Class<T>::Draw (b2D rect, float R, ColorTypeDef color)
N{
N  if (this->Screen->Test()) return -1;
N	
N	this->Screen->Trunc(&rect);
N	int32_t y = (int32_t)R;
N	int32_t sR = this->Sqr((int32_t)R);
N	int32_t x = 0;
N	int32_t Dg = 0;
N	int32_t Dd = 0;
N	int32_t Dv = 0;
N	int32_t sqrx = 0;
N	int32_t sqry = 0;
N	rect.x += R;
N	rect.y += R;
N	this->Pixel(rect.x,  y  + rect.y, color);
N	this->Pixel(rect.x,  -y  + rect.y, color);
N	for(;y >= 0;){
N		sqrx = this->Sqr(x + 1) - sR;
N		sqry = this->Sqr(y - 1);
N		Dg = (sqrx + this->Sqr(y));
N		Dd = (sqrx + sqry);
N		Dv = (this->Sqr(x) + sqry - sR);
N		if(Dd < 0){
N			if(Dd > -labs(Dg)){ 	
X			if(Dd > -((int32_t)(Dg) < 0 ? -(int32_t)(Dg) : (int32_t)(Dg))){ 	
N				  x++;
N				  y--;
N			}
N			else {
N			    x++;
N			}
N		}
N		else if(Dd > 0){
N			if(Dd < labs(Dv)){
X			if(Dd < ((int32_t)(Dv) < 0 ? -(int32_t)(Dv) : (int32_t)(Dv))){
N				  y--;
N				  x++;
N			}
N			else {
N			    y--;
N			}
N		}
N		else {
N			  y--;
N			  x++;
N		}
N		this->Point(rect.x, rect.y, x, y, color);
N	}
N	return 0;
N}
N
Ntemplate <typename T>
Nint32_t Circle_Class<T>::Draw (gbasic_t x0, gbasic_t y0, float R, ColorTypeDef color)
N{
N	b2D rect = {x0, y0, 0, 0};
N	return this->Draw (rect, R, color);
N}
N
Ntemplate <typename T>
Nint32_t Circle_Class<T>::DrawFilled (b2D rect, float R, ColorTypeDef color)
N{
N  if (this->Screen->Test()) return -1;
N	
N	this->Screen->Trunc(&rect);
N	int32_t y = (int32_t)R;
N	int32_t sR = this->Sqr((int32_t)R);
N	int32_t x = 0;
N	int32_t Dg = 0;
N	int32_t Dd = 0;
N	int32_t Dv = 0;
N	int32_t sqrx = 0;
N	int32_t sqry = 0;
N	rect.x += R;
N	rect.y += R;
N	uint32_t tx = 0;
N	this->fBotToTop(rect.x, rect.y, x, y, color);
N	for(;y >= 0 ;){
N		sqrx = this->Sqr(x + 1) - sR;
N		sqry = this->Sqr(y - 1);
N		Dg = (sqrx + this->Sqr(y));
N		Dd = (sqrx + sqry);
N		Dv = (this->Sqr(x) + sqry - sR);
N		if(Dd < 0){
N			if(Dd > -labs(Dg)){
X			if(Dd > -((int32_t)(Dg) < 0 ? -(int32_t)(Dg) : (int32_t)(Dg))){
N				  x++;
N				  y--;
N			}
N			else {
N			    x++;
N			}
N		}
N		else if(Dd > 0) {
N			if(Dd < labs(Dv)){
X			if(Dd < ((int32_t)(Dv) < 0 ? -(int32_t)(Dv) : (int32_t)(Dv))){
N				  y--;
N				  x++;
N			}
N			else {
N			    y--;
N			}
N		}
N		else {
N			  y--;
N			  x++;
N		}
N		if (tx != x) {
N		    this->fBotToTop(rect.x, rect.y, x, y, color);
N		} else {}
N		tx = x;
N	}
N	return 0;
N}
N
Ntemplate <typename T>
Nint32_t Circle_Class<T>::Round (b2D rect, float R, ColorTypeDef color, uint32_t z)
N{
N	b2D cut_rect = rect;
N	this->Draw(rect, R, color);
N	rect.x = rect.x + z;
N	rect.y = rect.y + z;
N	this->Draw(rect, R - z, color);
N	this->Screen->Fill.FillX(cut_rect, color);
N	return 0;
N}
N
Ntemplate <typename T>
Nint32_t Circle_Class<T>::Round (gbasic_t x0, gbasic_t y0, float R, ColorTypeDef color, uint32_t z)
N{
N	b2D rect = {x0, y0, 0, 0}, cut_rect = {x0, y0, (gbasic_t)(2 * R), (gbasic_t)(2 * R)};
N	this->Draw(rect, R, color);
N	rect.x = rect.x + z;
N	rect.y = rect.y + z;
N	this->Draw(rect, R - z, color);
N	this->Screen->Fill.FillX(cut_rect, color);
N	return 0;
N}
N
Ntemplate <typename T>
Nint32_t Circle_Class<T>::Arc (b2D rect, float R, float A, ColorTypeDef color, float Ai)
N{
N	return this->Arc(rect.x, rect.y, R, A, color, Ai);
N}
N
Ntemplate <typename T>
Nint32_t Circle_Class<T>::Arc (gbasic_t x0, gbasic_t y0, float R, float A, ColorTypeDef color, float Ai)
N{
N	float x = 0, y = R;
N	float px = x0 + x, py = y0 + y;
N	int32_t t = (int32_t)abs(floor(A / Ai));
N	while (t--) {
N		x = (float)x + y * Ai;
N	  y = (float)y - x * Ai; 
N		this->Screen->Line.DrawDda((gbasic_t)px, (gbasic_t)py, (gbasic_t)x + x0, (gbasic_t)y + y0, color);
N		px = x + x0;
N		py = y + y0;
N	}
N	
N	return 0;
N}
N
Ntemplate <typename T>
Nint32_t Circle_Class<T>::Segment (b2D rect, float R, float A, ColorTypeDef color, float Ai)
N{
N	return this->Segment(rect.x, rect.y, R, A, color, Ai);
N}
N
Ntemplate <typename T>
Nint32_t Circle_Class<T>::Segment (gbasic_t x0, gbasic_t y0, float R, float A, ColorTypeDef color, float Ai)
N{
N	float x = 0, y = R;
N	float px = x0, py = y0;
N	int32_t t = (int32_t)abs(floor(A / Ai));
N	b2D rect = {x0 - R, y0 - R, 2 * R, 2 * R};
N	while (t--) {
N		x = (float)x + y * Ai;
N	  y = (float)y - x * Ai; 
N		this->Screen->Line.DrawDda((gbasic_t)px, (gbasic_t)py, (gbasic_t)x + x0, (gbasic_t)y + y0, color);
N		px = x + x0;
N		py = y + y0;
N	}
N	x = 0, y = R - 10.0F;
N	px = x0 + x, py = y0 + y;
N	t = (int32_t)abs(floor(A / Ai));
N	while (t--) {
N		x = (float)x + y * Ai;
N	  y = (float)y - x * Ai; 
N		this->Screen->Line.DrawDda((gbasic_t)px, (gbasic_t)py, (gbasic_t)x + x0, (gbasic_t)y + y0, color);
N		px = x + x0;
N		py = y + y0;
N	}
N	this->Screen->Line.DrawDda((gbasic_t)x0, (gbasic_t)y0, (gbasic_t)x + x0, (gbasic_t)y + y0, color);
N	this->Screen->Fill.FillX(rect, color);
N	return 0;
N}
N 
Ntemplate <typename T>
Nint32_t Circle_Class<T>::DrawFilled (gbasic_t x, gbasic_t y, float R, ColorTypeDef color)
N{
N	b2D rect = {x, y, 0, 0};
N	return this->DrawFilled(rect, R, color);
N}
N#else /*!SOFTWARE_GL*/
S
N#endif /*SOFTWARE_GL*/
N
N#endif /*CIRCLE_CLASS_CPP*/
N
N
N/*End Of File*/
L 17 ".\device\GUI\inc\Screen.h" 2
N#include "line_class.h"
L 1 ".\device\GUI\inc\line_class.h" 1
N#ifndef LINE_CLASS_CPP
N#define LINE_CLASS_CPP
N
N#ifdef SOFTWARE_GL
N
N#include "frame_class.h"
N#include "screen_obj.h"
N#include "rectangle_class.h"
L 1 ".\device\GUI\inc\rectangle_class.h" 1
N#ifndef RECTANGLE_CLASS_H
N#define RECTANGLE_CLASS_H
N
N#include <stdint.h>
N#include "Frame_Class.h"
N#include "screen_obj.h"
N
Ntemplate <typename T> 
Nclass Rectangle_Class   : public Screen_Obj<T> {
N	public:
N		Rectangle_Class ();
N	  void Init ();
N	  int32_t Draw (b2D, ColorTypeDef);
N	  int32_t DrawHatched (b2D, ColorTypeDef, uint8_t);
N	private:
N		uint8_t Z;
N	
N};
N
Ntemplate <typename T>
NRectangle_Class<T>::Rectangle_Class () {}
N		
Ntemplate <typename T>
Nvoid Rectangle_Class<T>::Init ()
N{
N	this->Z = 5;
N}
N
Ntemplate <typename T>
Nint32_t Rectangle_Class<T>::Draw (b2D rect, ColorTypeDef color)
N{
N	if (this->Screen->Test()) return -1;
N	static b2D r;
N	r = rect;
N	this->Screen->Trunc(&r);
N	uint32_t w0 = r.x + r.w;
N	uint32_t h0 = r.y + r.h;
N	this->Screen->Line.fBotToTop(r.x, r.y, h0, color);
N	this->Screen->Line.fBotToTop(w0, r.y, h0, color);
N	this->Screen->Line.fLeftToRight(r.x, r.y, w0, color);
N	this->Screen->Line.fLeftToRight(r.x, h0, w0, color);
N	
N	return 0;
N}
N
Ntemplate <typename T>
Nint32_t Rectangle_Class<T>::DrawHatched (b2D rect, ColorTypeDef color, uint8_t hatch)
N{
N	if (this->Screen->Test()) return -1;
N	
N	return 0;
N}
N
N
N#endif /*RECTANGLE_CLASS_CPP*/
L 9 ".\device\GUI\inc\line_class.h" 2
N
Ntemplate <typename T>
Nclass Line_Class : public Screen_Obj<T> {
N	public:
N	  Line_Class ();
N	  void Init ();
N	  int32_t DrawDda (float, float, float, float, ColorTypeDef);
N	  int32_t DrawVertical (b2D rect, ColorTypeDef);
N	  int32_t DrawHorizontal (b2D rect, ColorTypeDef);
N	  int32_t DrawDdaBold (float, float, float, float, ColorTypeDef);
N	  int32_t DrawVerticalBold (b2D rect, ColorTypeDef);
N	  int32_t DrawHorizontalBold (b2D rect, ColorTypeDef);
N	  int32_t DrawVector (float, float, float, float, ColorTypeDef);
N	  int32_t DrawVectorBold (float, float, float, float, ColorTypeDef);
N	private:
N	  uint8_t Z;
N	  int32_t Pixel (int32_t, int32_t, ColorTypeDef);
N	  int32_t Point (int32_t, int32_t, int32_t, int32_t, ColorTypeDef);
N	  int32_t fBotToTop (uint32_t, uint32_t, uint32_t, ColorTypeDef, uint8_t = 1);
N	  int32_t fLeftToRight (uint32_t, uint32_t, uint32_t, ColorTypeDef, uint8_t = 1);
N	  int8_t log2LaySize;
N	
N	  friend class Rectangle_Class<T>;
N};
N
Ntemplate <typename T>
NLine_Class<T>::Line_Class()
N{
N
N}
N
Ntemplate <typename T>
Nvoid Line_Class<T>::Init ()
N{
N	this->Z = 5;
N	uint32_t h = this->H;
N	while ((h >> (this->log2LaySize++))){} 
N}
N		
Ntemplate <typename T>
Nint32_t Line_Class<T>::Pixel (int32_t x, int32_t y, ColorTypeDef color)
N{
N  *(this->Frame + y + x * this->H) = color;
N	return 0;
N}
N
Ntemplate <typename T>
Nint32_t Line_Class<T>::DrawDda (float xt0, float yt0, float xt, float yt, ColorTypeDef color)
N{
N  if (this->Screen->Test()) return -1;
N	
N	b2D rect = this->Screen->TruncLine(xt0, yt0, xt, yt);
N	int32_t Xo = rect.x;
N  int32_t Yo = rect.y;
N  int32_t X  =  rect.w;
N  int32_t Y  =  rect.h;
N	int32_t dx = labs(X - Xo);
X	int32_t dx = ((int32_t)(X - Xo) < 0 ? -(int32_t)(X - Xo) : (int32_t)(X - Xo));
N  int32_t dy = labs(Y - Yo);
X  int32_t dy = ((int32_t)(Y - Yo) < 0 ? -(int32_t)(Y - Yo) : (int32_t)(Y - Yo));
N  int32_t sx = X >= Xo ? 1 : -1;
N  int32_t sy = Y >= Yo ? 1 : -1;
N		if(dy <= dx)                    
N		{
N			int32_t d =  (dy<<1)-dx;                     
N			int32_t d1 = dy<<1;
N			int32_t d2 = (dy-dx)<<1;
N			this->Pixel(Xo, Yo, color);            
N			for(int32_t x = Xo+sx, y = Yo, i = 1; i<=dx; i++, x+=sx) 
N			{
N				if(d>0)            
N				{
N					d +=d2;
N					y +=sy;
N				}
N				else d +=d1;
N				this->Pixel(x, y,color);            
N			}
N		}
N		else
N		{
N			int32_t d = (dx<<1)-dy;
N			int32_t d1 = dx<<1;
N			int32_t d2 = (dx-dy)<<1;
N			this->Pixel(Xo, Yo,  color);
N			for(int32_t x = Xo,y = Yo+sy,i = 1;i<=dy;i++,y+=sy)
N			{
N				if(d>0)
N				{
N					d+=d2;
N					x+=sx;
N				}
N				else d+=d1;
N				this->Pixel(x, y, color);
N			}
N		}  
N  return 0;	
N}
N
Ntemplate <typename T>
Nint32_t Line_Class<T>::DrawDdaBold (float xt0, float yt0, float xt, float yt, ColorTypeDef color)
N{
N  if (this->Screen->Test()) return -1;
N	
N	if (this->Z == 0) this->Z = 2;
N	b2D rect = this->Screen->TruncLine(xt0, yt0, xt, yt);
N	int32_t Xo = rect.x;
N  int32_t Yo = rect.y;
N  int32_t X  =  rect.w;
N  int32_t Y  =  rect.h;
N	int32_t dx = labs(X - Xo);
X	int32_t dx = ((int32_t)(X - Xo) < 0 ? -(int32_t)(X - Xo) : (int32_t)(X - Xo));
N  int32_t dy = labs(Y - Yo);
X  int32_t dy = ((int32_t)(Y - Yo) < 0 ? -(int32_t)(Y - Yo) : (int32_t)(Y - Yo));
N  int32_t sx = X >= Xo ? this->Z : -this->Z;
N  int32_t sy = Y >= Yo ? this->Z : -this->Z;
N		if(dy <= dx)                    
N		{
N			int32_t d =  (dy<<1)-dx;                     
N			int32_t d1 = dy<<1;
N			int32_t d2 = (dy-dx)<<1;           
N			for(int32_t x = Xo+sx, y = Yo, i = 1; i<=dx/this->Z; i++, x+=sx) 
N			{
N				if(d>0)            
N				{
N					d +=d2;
N					y +=sy;
N				}
N				else {
N					  d +=d1;
N				}
N				this->fBotToTop(x, y, y + this->Z, color, this->Z);           
N			}
N		}
N		else
N		{
N			int32_t d = (dx<<1)-dy;
N			int32_t d1 = dx<<1;
N			int32_t d2 = (dx-dy)<<1;
N			for(int32_t x = Xo,y = Yo+sy,i = 1;i<=dy/this->Z;i++,y+=sy)
N			{
N				if(d>0)
N				{
N					d+=d2;
N					x+=sx;
N				}
N				else {
N					  d+=d1;
N				}
N				this->fLeftToRight(x, y, x + this->Z, color, this->Z);
N			}
N		}  
N  return 0;	
N}
N
Ntemplate <typename T>
Nint32_t Line_Class<T>::DrawVector (float x0, float y0, float R, float A, ColorTypeDef color)
N{
N  if (this->Screen->Test()) return -1;
N	float x, y;
N  x = x0 + R * sin(A);
N  y = y0 + R * cos(A);
N	return this->DrawDda(x0, y0, x, y, color);
N}
N
Ntemplate <typename T>
Nint32_t Line_Class<T>::DrawVectorBold (float x0, float y0, float R, float A, ColorTypeDef color)
N{
N  if (this->Screen->Test()) return -1;
N	float x, y;
N  x = x0 + R * sin(A);
N  y = y0 + R * cos(A);	
N	return this->DrawDdaBold(x0, y0, x, y, color);	
N}
N
Ntemplate <typename T>
Nint32_t Line_Class<T>::DrawVertical (b2D rect, ColorTypeDef color)
N{
N  if (this->Screen->Test()) return -1;
N
N  return 0;	
N}
N
Ntemplate <typename T>
Nint32_t Line_Class<T>::DrawHorizontal (b2D rect, ColorTypeDef color)
N{
N  if (this->Screen->Test()) return -1;
N
N  return 0;	
N}
N
Ntemplate <typename T>
Nint32_t Line_Class<T>::DrawHorizontalBold (b2D rect, ColorTypeDef color)
N{
N  if (this->Screen->Test()) return -1;
N
N  return 0;	
N}
N
Ntemplate <typename T>
Nint32_t Line_Class<T>::fBotToTop (uint32_t x0, uint32_t y0, uint32_t y, ColorTypeDef color, uint8_t z)
N{
N	uint32_t h = this->H;
N	uint32_t D = x0 * h;
N	
N	y0 += D;
N	y += D;
N	for (; y > y0; y--) {
N	    for (int32_t tz = z * h; tz > 0; tz -= h) {
N          *(this->Frame + y + tz) = color;
N			}
N	}
N	return 0;		
N}
N
Ntemplate <typename T>
Nint32_t Line_Class<T>::fLeftToRight (uint32_t x0, uint32_t y0, uint32_t x, ColorTypeDef color,  uint8_t z)
N{
N	uint32_t h0 = this->H;
N	x0 = x0 * h0 + y0;
N	x = x * h0 + y0;
N	
N  for (; x > x0; x -= h0) {
N	    for (uint32_t tz = z; tz > 0; tz--) {
N          *(this->Frame + x + tz) = color;
N			}
N	}
N	return 0;		
N}
N
N#else /*!SOFTWARE_GL*/
S
N#endif /*SOFTWARE_GL*/
N
N#endif /*LINE_CLASS_CPP*/
N
N
N/*End Of File*/
N
L 18 ".\device\GUI\inc\Screen.h" 2
N#include "rectangle_class.h"
N#include "print_class.h"
N
Nclass Screen : public Locker ,
N	           public Coordinates,		  
N		       public List_Node <Screen, uint8_t>,
N               public Allocator <Screen>				 {
N	public:
N	  Screen ();
N	  void operator () (b2D, Frame2D<gbasic_t> &); 
N	  int32_t Refresh ();
N	  tTexture *MakeTexture (b2D);
N	  tTexture *MakeTexture (gbasic_t, gbasic_t);
N	  int32_t   KillTexture (tTexture *);
N    
N      int32_t Pixel (gbasic_t, gbasic_t, ColorTypeDef);
N      ColorTypeDef Pixel (gbasic_t, gbasic_t);
N	  
N	  Affine_Body Affine;
N	
N      Fill_Class       <Screen> Fill;
N	  Bitmap_Class     <Screen> Bitmap;
N	  Circle_Class     <Screen> Circle;
N	  Line_Class       <Screen> Line;
N	  Rectangle_Class  <Screen> Rectangle;
N	  Print_Class      <Screen> Print;
N	  Frame2D<gbasic_t> *GetFrame ();
N	private:
N	  Frame2D<gbasic_t> *Frame;
N	  ColorTypeDef back_color;
N      ColorTypeDef *frame_;
N      ColorTypeDef h_;
N	
N	  friend class Bitmap_Class     <Screen>;
N	  friend class Fill_Class       <Screen>;
N	  friend class Circle_Class     <Screen>;
N	  friend class Line_Class       <Screen>;
N	  friend class Rectangle_Class  <Screen>;
N	  friend class Print_Class      <Screen>;
N	  friend class Screen_Obj       <Screen>;
N};
N							 
Nclass ScreenManager : public Locker ,
N	                    public List_Iterator<Screen>,
N										  public Allocator <Screen>		 {
N  public:
N		ScreenManager ();
N	  void operator () ();
N	  Screen *Create (b2D, Frame2D<gbasic_t> *);
N	  int32_t Kill (Screen *);
N	  int32_t Refresh (uint32_t);
N	private:
N};
N
N
N
N#endif /*SCREEN_H*/
N
N
N
N
L 2 "device\GUI\src\Screen.cpp" 2
N
N
NScreen::Screen (){}
N	
N
Nvoid Screen::operator () (b2D rect, Frame2D<gbasic_t> &frame)
N{
N	this->Dispose(rect);
N	this->Frame = &frame;
N	this->Fill(*this);
N	this->Bitmap(*this);
N	      this->Bitmap.SetScale(0, 0);
N	this->Circle(*this);
N	this->Line(*this);
N	      this->Line.Init();
N	this->Rectangle(*this);
N	      this->Rectangle.Init();
N	this->Print(*this);
N	      this->Print.Init();
N    
N    this->frame_ = this->Frame->GetBuff();
N    this->h_     = this->Frame->GetH();
N}
N
Nint32_t Screen::Pixel (gbasic_t x, gbasic_t y, ColorTypeDef color)
N{
N  *(frame_ + (y + Y0) + (x + X0) * h_) = color;
N  return 0;    
N}
N
NColorTypeDef Screen::Pixel (gbasic_t x, gbasic_t y)
N{
N  return *(frame_ + (y + Y0) + (x + X0) * h_);    
N}
N
Nint32_t Screen::Refresh ()
N{
N	return this->Fill.Fill(this->back_color);
N}
N
NFrame2D<gbasic_t> *Screen::GetFrame ()
N{
N	return this->Frame;
N}
N
NtTexture *Screen::MakeTexture (gbasic_t w, gbasic_t h)
N{
N    tTexture *texture = this->New<tTexture>((w + 1) * (h + 1) * sizeof(ColorTypeDef));
N	texture->Image = (ColorTypeDef *)(texture + 1);
N	texture->W = w;
N	texture->H = h;
N	return texture;
N}
N
NtTexture *Screen::MakeTexture (b2D rect)
N{
N  return this->MakeTexture(rect.w, rect.h);
N}
N
Nint32_t Screen::KillTexture (tTexture *texture)
N{
N  return this->Delete(texture);
N}
N
N
N
N
NScreenManager::ScreenManager (){}
N	
Nvoid ScreenManager::operator () ()
N{
N	this->Unlock();
N}
N
NScreen *ScreenManager::Create (b2D rect, Frame2D<gbasic_t> *frame)
N{
N	Screen *screen = this->New();
N	*this + screen;
N	screen->operator()(rect, *frame);
N	return screen;
N}
N
Nint32_t ScreenManager::Kill (Screen *screen)
N{
N	if (screen == (Screen *)0) return -1;
N	*this - screen;
N	this->Delete(screen);
N	return 0;
N}
N
Nint32_t ScreenManager::Refresh (uint32_t flags)
N{
N	if (this->Test()) return -1;
N	register uint32_t i = this->Contain();
N	while (i--)
N		this->Get(i)->Refresh();
N	return 0;
N}
