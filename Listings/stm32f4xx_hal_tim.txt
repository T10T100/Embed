; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--cpp --list --debug -c --asm --interleave -o.\objects\stm32f4xx_hal_tim.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_hal_tim.d --cpu=Cortex-M4.fp --apcs=interwork -O1 -Otime --diag_suppress=9931 -I.\device\GUI\inc -I.\device\hardware\inc -I.\device\init\inc -I.\misc\inc -I.\user\inc -I..\tester_1.03 -I.\memory\inc -I.\drivers\inc -IE:\KeilProj\tester_1_03\Embed\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.4.0 -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.4.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=514 -D_RTE_ -DSTM32F417xx -DSTM32F417xx -DColorDepthBpp16 -Dtftili9486 -DSOFTWARE_GL -DGUI_ALLIGN_LAYSIZE_TO_POW2 --omf_browse=.\objects\stm32f4xx_hal_tim.crf drivers\src\stm32f4xx_hal_tim.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TIM_Base_SetConfig PROC
;;;4416     */
;;;4417   void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
000000  b4f0              PUSH     {r4-r7}
;;;4418   {
;;;4419     uint32_t tmpcr1 = 0;
;;;4420     tmpcr1 = TIMx->CR1;
000002  6802              LDR      r2,[r0,#0]
;;;4421     
;;;4422     /* Set TIM Time Base Unit parameters ---------------------------------------*/
;;;4423     if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
000004  4bf8              LDR      r3,|L1.1000|
000006  f8dfc3e4          LDR      r12,|L1.1004|
00000a  4df9              LDR      r5,|L1.1008|
00000c  4ef9              LDR      r6,|L1.1012|
00000e  4cfa              LDR      r4,|L1.1016|
000010  4298              CMP      r0,r3
000012  d00a              BEQ      |L1.42|
000014  f1b04f80          CMP      r0,#0x40000000
000018  d007              BEQ      |L1.42|
00001a  4560              CMP      r0,r12
00001c  d005              BEQ      |L1.42|
00001e  42a8              CMP      r0,r5
000020  d003              BEQ      |L1.42|
000022  42b0              CMP      r0,r6
000024  d001              BEQ      |L1.42|
000026  42a0              CMP      r0,r4
000028  d103              BNE      |L1.50|
                  |L1.42|
;;;4424     {
;;;4425       /* Select the Counter Mode */
;;;4426       tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
00002a  f0220270          BIC      r2,r2,#0x70
;;;4427       tmpcr1 |= Structure->CounterMode;
00002e  684f              LDR      r7,[r1,#4]
000030  433a              ORRS     r2,r2,r7
                  |L1.50|
;;;4428     }
;;;4429    
;;;4430     if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
000032  4298              CMP      r0,r3
000034  d01e              BEQ      |L1.116|
000036  f1b04f80          CMP      r0,#0x40000000
00003a  d01b              BEQ      |L1.116|
00003c  4560              CMP      r0,r12
00003e  d019              BEQ      |L1.116|
000040  42a8              CMP      r0,r5
000042  d017              BEQ      |L1.116|
000044  42b0              CMP      r0,r6
000046  d015              BEQ      |L1.116|
000048  42a0              CMP      r0,r4
00004a  d013              BEQ      |L1.116|
00004c  f1a04c80          SUB      r12,r0,#0x40000000
000050  f5bc3ca0          SUBS     r12,r12,#0x14000
000054  d00e              BEQ      |L1.116|
000056  f5bc6c80          SUBS     r12,r12,#0x400
00005a  d00b              BEQ      |L1.116|
00005c  f5bc6c80          SUBS     r12,r12,#0x400
000060  d008              BEQ      |L1.116|
000062  f51c3c98          ADDS     r12,r12,#0x13000
000066  d005              BEQ      |L1.116|
000068  f5bc6c80          SUBS     r12,r12,#0x400
00006c  d002              BEQ      |L1.116|
00006e  f5bc6c80          SUBS     r12,r12,#0x400
000072  d105              BNE      |L1.128|
                  |L1.116|
;;;4431     {
;;;4432       /* Set the clock division */
;;;4433       tmpcr1 &= ~TIM_CR1_CKD;
000074  f4227240          BIC      r2,r2,#0x300
;;;4434       tmpcr1 |= (uint32_t)Structure->ClockDivision;
000078  f8d1c00c          LDR      r12,[r1,#0xc]
00007c  ea4c0202          ORR      r2,r12,r2
                  |L1.128|
;;;4435     }
;;;4436   
;;;4437     TIMx->CR1 = tmpcr1;
000080  6002              STR      r2,[r0,#0]
;;;4438   
;;;4439     /* Set the Auto-reload value */
;;;4440     TIMx->ARR = (uint32_t)Structure->Period ;
000082  688a              LDR      r2,[r1,#8]
000084  62c2              STR      r2,[r0,#0x2c]
;;;4441    
;;;4442     /* Set the Prescaler value */
;;;4443     TIMx->PSC = (uint32_t)Structure->Prescaler;
000086  680a              LDR      r2,[r1,#0]
000088  6282              STR      r2,[r0,#0x28]
;;;4444       
;;;4445     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
00008a  4298              CMP      r0,r3
00008c  d001              BEQ      |L1.146|
00008e  42a0              CMP      r0,r4
000090  d101              BNE      |L1.150|
                  |L1.146|
;;;4446     {
;;;4447       /* Set the Repetition Counter value */
;;;4448       TIMx->RCR = Structure->RepetitionCounter;
000092  6909              LDR      r1,[r1,#0x10]
000094  6301              STR      r1,[r0,#0x30]
                  |L1.150|
;;;4449     }
;;;4450   
;;;4451     /* Generate an update event to reload the Prescaler 
;;;4452        and the repetition counter(only for TIM1 and TIM8) value immediately */
;;;4453     TIMx->EGR = TIM_EGR_UG;
000096  2101              MOVS     r1,#1
000098  6141              STR      r1,[r0,#0x14]
;;;4454   }
00009a  bcf0              POP      {r4-r7}
00009c  4770              BX       lr
;;;4455   
                          ENDP

                  HAL_TIM_Base_MspInit PROC
;;;274      */
;;;275    __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
00009e  4770              BX       lr
;;;276    {
;;;277      /* NOTE : This function Should not be modified, when the callback is needed,
;;;278                the HAL_TIM_Base_MspInit could be implemented in the user file
;;;279       */
;;;280    }
;;;281    
                          ENDP

                  HAL_TIM_Base_Init PROC
;;;207      */
;;;208    HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
0000a0  b510              PUSH     {r4,lr}
;;;209    { 
0000a2  4604              MOV      r4,r0
;;;210      /* Check the TIM handle allocation */
;;;211      if(htim == NULL)
0000a4  2c00              CMP      r4,#0
0000a6  d003              BEQ      |L1.176|
;;;212      {
;;;213        return HAL_ERROR;
;;;214      }
;;;215      
;;;216      /* Check the parameters */
;;;217      assert_param(IS_TIM_INSTANCE(htim->Instance)); 
;;;218      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;219      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;220      
;;;221      if(htim->State == HAL_TIM_STATE_RESET)
0000a8  f8940039          LDRB     r0,[r4,#0x39]
0000ac  b110              CBZ      r0,|L1.180|
0000ae  e007              B        |L1.192|
                  |L1.176|
0000b0  2001              MOVS     r0,#1                 ;213
;;;222      {  
;;;223        /* Allocate lock resource and initialize it */
;;;224        htim->Lock = HAL_UNLOCKED;
;;;225        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;226        HAL_TIM_Base_MspInit(htim);
;;;227      }
;;;228      
;;;229      /* Set the TIM state */
;;;230      htim->State= HAL_TIM_STATE_BUSY;
;;;231      
;;;232      /* Set the Time Base configuration */
;;;233      TIM_Base_SetConfig(htim->Instance, &htim->Init); 
;;;234      
;;;235      /* Initialize the TIM state*/
;;;236      htim->State= HAL_TIM_STATE_READY;
;;;237      
;;;238      return HAL_OK;
;;;239    }
0000b2  bd10              POP      {r4,pc}
                  |L1.180|
0000b4  2000              MOVS     r0,#0                 ;224
0000b6  f8840038          STRB     r0,[r4,#0x38]         ;224
0000ba  4620              MOV      r0,r4                 ;226
0000bc  f7fffffe          BL       HAL_TIM_Base_MspInit
                  |L1.192|
0000c0  2002              MOVS     r0,#2                 ;230
0000c2  f8840039          STRB     r0,[r4,#0x39]         ;230
0000c6  1d21              ADDS     r1,r4,#4              ;233
0000c8  6820              LDR      r0,[r4,#0]            ;233
0000ca  f7fffffe          BL       TIM_Base_SetConfig
0000ce  2001              MOVS     r0,#1                 ;236
0000d0  f8840039          STRB     r0,[r4,#0x39]         ;236
0000d4  2000              MOVS     r0,#0                 ;238
0000d6  bd10              POP      {r4,pc}
;;;240    
                          ENDP

                  HAL_TIM_Base_MspDeInit PROC
;;;287      */
;;;288    __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
0000d8  4770              BX       lr
;;;289    {
;;;290      /* NOTE : This function Should not be modified, when the callback is needed,
;;;291                the HAL_TIM_Base_MspDeInit could be implemented in the user file
;;;292       */
;;;293    }
;;;294    
                          ENDP

                  HAL_TIM_Base_DeInit PROC
;;;246      */
;;;247    HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
0000da  b510              PUSH     {r4,lr}
;;;248    {  
0000dc  4604              MOV      r4,r0
;;;249      /* Check the parameters */
;;;250      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;251    
;;;252      htim->State = HAL_TIM_STATE_BUSY;
0000de  2002              MOVS     r0,#2
0000e0  f8840039          STRB     r0,[r4,#0x39]
;;;253       
;;;254      /* Disable the TIM Peripheral Clock */
;;;255      __HAL_TIM_DISABLE(htim);
0000e4  6820              LDR      r0,[r4,#0]
0000e6  6a01              LDR      r1,[r0,#0x20]
0000e8  f2411211          MOV      r2,#0x1111
0000ec  4211              TST      r1,r2
0000ee  d107              BNE      |L1.256|
0000f0  6a01              LDR      r1,[r0,#0x20]
0000f2  1092              ASRS     r2,r2,#2
0000f4  4211              TST      r1,r2
0000f6  d103              BNE      |L1.256|
0000f8  6801              LDR      r1,[r0,#0]
0000fa  f0210101          BIC      r1,r1,#1
0000fe  6001              STR      r1,[r0,#0]
                  |L1.256|
;;;256        
;;;257      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;258      HAL_TIM_Base_MspDeInit(htim);
000100  4620              MOV      r0,r4
000102  f7fffffe          BL       HAL_TIM_Base_MspDeInit
;;;259      
;;;260      /* Change TIM state */  
;;;261      htim->State = HAL_TIM_STATE_RESET; 
000106  2000              MOVS     r0,#0
000108  f8840039          STRB     r0,[r4,#0x39]
;;;262      
;;;263      /* Release Lock */
;;;264      __HAL_UNLOCK(htim);
00010c  f8840038          STRB     r0,[r4,#0x38]
;;;265    
;;;266      return HAL_OK;
;;;267    }
000110  bd10              POP      {r4,pc}
;;;268    
                          ENDP

                  HAL_TIM_Base_Start PROC
;;;300      */
;;;301    HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
000112  2102              MOVS     r1,#2
;;;302    {
;;;303      /* Check the parameters */
;;;304      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;305      
;;;306      /* Set the TIM state */
;;;307      htim->State= HAL_TIM_STATE_BUSY;
000114  f8801039          STRB     r1,[r0,#0x39]
;;;308      
;;;309      /* Enable the Peripheral */
;;;310      __HAL_TIM_ENABLE(htim);
000118  6801              LDR      r1,[r0,#0]
00011a  680a              LDR      r2,[r1,#0]
00011c  f0420201          ORR      r2,r2,#1
000120  600a              STR      r2,[r1,#0]
;;;311      
;;;312      /* Change the TIM state*/
;;;313      htim->State= HAL_TIM_STATE_READY;
000122  2101              MOVS     r1,#1
000124  f8801039          STRB     r1,[r0,#0x39]
;;;314      
;;;315      /* Return function status */
;;;316      return HAL_OK;
000128  2000              MOVS     r0,#0
;;;317    }
00012a  4770              BX       lr
;;;318    
                          ENDP

                  HAL_TIM_Base_Stop PROC
;;;324      */
;;;325    HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
00012c  2102              MOVS     r1,#2
;;;326    {
;;;327      /* Check the parameters */
;;;328      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;329      
;;;330      /* Set the TIM state */
;;;331      htim->State= HAL_TIM_STATE_BUSY;
00012e  f8801039          STRB     r1,[r0,#0x39]
;;;332      
;;;333      /* Disable the Peripheral */
;;;334      __HAL_TIM_DISABLE(htim);
000132  6801              LDR      r1,[r0,#0]
000134  6a0a              LDR      r2,[r1,#0x20]
000136  f2411311          MOV      r3,#0x1111
00013a  421a              TST      r2,r3
00013c  d107              BNE      |L1.334|
00013e  6a0a              LDR      r2,[r1,#0x20]
000140  109b              ASRS     r3,r3,#2
000142  421a              TST      r2,r3
000144  d103              BNE      |L1.334|
000146  680a              LDR      r2,[r1,#0]
000148  f0220201          BIC      r2,r2,#1
00014c  600a              STR      r2,[r1,#0]
                  |L1.334|
;;;335      
;;;336      /* Change the TIM state*/
;;;337      htim->State= HAL_TIM_STATE_READY;
00014e  2101              MOVS     r1,#1
000150  f8801039          STRB     r1,[r0,#0x39]
;;;338      
;;;339      /* Return function status */
;;;340      return HAL_OK;
000154  2000              MOVS     r0,#0
;;;341    }
000156  4770              BX       lr
;;;342    
                          ENDP

                  HAL_TIM_Base_Start_IT PROC
;;;348      */
;;;349    HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
000158  6801              LDR      r1,[r0,#0]
;;;350    {
;;;351      /* Check the parameters */
;;;352      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;353      
;;;354      /* Enable the TIM Update interrupt */
;;;355      __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
00015a  68ca              LDR      r2,[r1,#0xc]
00015c  f0420201          ORR      r2,r2,#1
000160  60ca              STR      r2,[r1,#0xc]
;;;356          
;;;357      /* Enable the Peripheral */
;;;358      __HAL_TIM_ENABLE(htim);
000162  6800              LDR      r0,[r0,#0]
000164  6801              LDR      r1,[r0,#0]
000166  f0410101          ORR      r1,r1,#1
00016a  6001              STR      r1,[r0,#0]
;;;359          
;;;360      /* Return function status */
;;;361      return HAL_OK;
00016c  2000              MOVS     r0,#0
;;;362    }
00016e  4770              BX       lr
;;;363    
                          ENDP

                  HAL_TIM_Base_Stop_IT PROC
;;;369      */
;;;370    HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
000170  6801              LDR      r1,[r0,#0]
;;;371    {
;;;372      /* Check the parameters */
;;;373      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;374      /* Disable the TIM Update interrupt */
;;;375      __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
000172  68ca              LDR      r2,[r1,#0xc]
000174  f0220201          BIC      r2,r2,#1
000178  60ca              STR      r2,[r1,#0xc]
;;;376          
;;;377      /* Disable the Peripheral */
;;;378      __HAL_TIM_DISABLE(htim);
00017a  6800              LDR      r0,[r0,#0]
00017c  6a01              LDR      r1,[r0,#0x20]
00017e  f2411211          MOV      r2,#0x1111
000182  4211              TST      r1,r2
000184  d107              BNE      |L1.406|
000186  6a01              LDR      r1,[r0,#0x20]
000188  1092              ASRS     r2,r2,#2
00018a  4211              TST      r1,r2
00018c  d103              BNE      |L1.406|
00018e  6801              LDR      r1,[r0,#0]
000190  f0210101          BIC      r1,r1,#1
000194  6001              STR      r1,[r0,#0]
                  |L1.406|
;;;379        
;;;380      /* Return function status */
;;;381      return HAL_OK;
000196  2000              MOVS     r0,#0
;;;382    }
000198  4770              BX       lr
;;;383    
                          ENDP

                  HAL_TIM_ErrorCallback PROC
;;;4316     */
;;;4317   __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
00019a  4770              BX       lr
;;;4318   {
;;;4319     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4320               the HAL_TIM_ErrorCallback could be implemented in the user file
;;;4321      */
;;;4322   }
;;;4323   /**
                          ENDP

                  TIM_DMAError PROC
;;;4620     */
;;;4621   void TIM_DMAError(DMA_HandleTypeDef *hdma)
00019c  b510              PUSH     {r4,lr}
;;;4622   {
;;;4623     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
00019e  6b80              LDR      r0,[r0,#0x38]
;;;4624     
;;;4625     htim->State= HAL_TIM_STATE_READY;
0001a0  2101              MOVS     r1,#1
0001a2  f8801039          STRB     r1,[r0,#0x39]
;;;4626      
;;;4627     HAL_TIM_ErrorCallback(htim);
0001a6  f7fffffe          BL       HAL_TIM_ErrorCallback
;;;4628   }
0001aa  bd10              POP      {r4,pc}
;;;4629   
                          ENDP

                  HAL_TIM_PeriodElapsedCallback PROC
;;;4252     */
;;;4253   __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
0001ac  4770              BX       lr
;;;4254   {
;;;4255     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4256               the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
;;;4257      */
;;;4258     
;;;4259   }
;;;4260   /**
                          ENDP

                  _Z24TIM_DMAPeriodElapsedCpltP19__DMA_HandleTypeDef PROC ; TIM_DMAPeriodElapsedCplt(__DMA_HandleTypeDef*)
;;;4699     */
;;;4700   static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
0001ae  b510              PUSH     {r4,lr}
;;;4701   {
;;;4702     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
0001b0  6b80              LDR      r0,[r0,#0x38]
;;;4703     
;;;4704     htim->State= HAL_TIM_STATE_READY;
0001b2  2101              MOVS     r1,#1
0001b4  f8801039          STRB     r1,[r0,#0x39]
;;;4705     
;;;4706     HAL_TIM_PeriodElapsedCallback(htim);
0001b8  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
;;;4707   }
0001bc  bd10              POP      {r4,pc}
;;;4708   
                          ENDP

                  HAL_TIM_Base_Start_DMA PROC
;;;391      */
;;;392    HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
0001be  b510              PUSH     {r4,lr}
;;;393    {
0001c0  4604              MOV      r4,r0
;;;394      /* Check the parameters */
;;;395      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance)); 
;;;396      
;;;397      if((htim->State == HAL_TIM_STATE_BUSY))
0001c2  f8940039          LDRB     r0,[r4,#0x39]
0001c6  2802              CMP      r0,#2
0001c8  d004              BEQ      |L1.468|
;;;398      {
;;;399         return HAL_BUSY;
;;;400      }
;;;401      else if((htim->State == HAL_TIM_STATE_READY))
0001ca  f8940039          LDRB     r0,[r4,#0x39]
0001ce  2801              CMP      r0,#1
0001d0  d002              BEQ      |L1.472|
0001d2  e008              B        |L1.486|
                  |L1.468|
0001d4  2002              MOVS     r0,#2                 ;399
;;;402      {
;;;403        if((pData == 0 ) && (Length > 0)) 
;;;404        {
;;;405          return HAL_ERROR;                                    
;;;406        }
;;;407        else
;;;408        {
;;;409          htim->State = HAL_TIM_STATE_BUSY;
;;;410        }
;;;411      }  
;;;412      /* Set the DMA Period elapsed callback */
;;;413      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;414         
;;;415      /* Set the DMA error callback */
;;;416      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;417      
;;;418      /* Enable the DMA Stream */
;;;419      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
;;;420      
;;;421      /* Enable the TIM Update DMA request */
;;;422      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
;;;423    
;;;424      /* Enable the Peripheral */
;;;425      __HAL_TIM_ENABLE(htim);  
;;;426      
;;;427      /* Return function status */
;;;428      return HAL_OK;
;;;429    }
0001d6  bd10              POP      {r4,pc}
                  |L1.472|
0001d8  b911              CBNZ     r1,|L1.480|
0001da  b10a              CBZ      r2,|L1.480|
0001dc  2001              MOVS     r0,#1                 ;405
0001de  bd10              POP      {r4,pc}
                  |L1.480|
0001e0  2002              MOVS     r0,#2                 ;409
0001e2  f8840039          STRB     r0,[r4,#0x39]         ;409
                  |L1.486|
0001e6  69e3              LDR      r3,[r4,#0x1c]         ;413
0001e8  4884              LDR      r0,|L1.1020|
0001ea  63d8              STR      r0,[r3,#0x3c]         ;413
0001ec  f2af0053          ADR      r0,TIM_DMAError + 1
0001f0  69e3              LDR      r3,[r4,#0x1c]         ;416
0001f2  6498              STR      r0,[r3,#0x48]         ;416
0001f4  6820              LDR      r0,[r4,#0]            ;419
0001f6  4613              MOV      r3,r2                 ;419
0001f8  f1000c2c          ADD      r12,r0,#0x2c          ;419
0001fc  4662              MOV      r2,r12                ;419
0001fe  69e0              LDR      r0,[r4,#0x1c]         ;419
000200  f7fffffe          BL       HAL_DMA_Start_IT
000204  6820              LDR      r0,[r4,#0]            ;422
000206  68c1              LDR      r1,[r0,#0xc]          ;422
000208  f4417180          ORR      r1,r1,#0x100          ;422
00020c  60c1              STR      r1,[r0,#0xc]          ;422
00020e  6820              LDR      r0,[r4,#0]            ;425
000210  6801              LDR      r1,[r0,#0]            ;425
000212  f0410101          ORR      r1,r1,#1              ;425
000216  6001              STR      r1,[r0,#0]            ;425
000218  2000              MOVS     r0,#0                 ;428
00021a  bd10              POP      {r4,pc}
;;;430    
                          ENDP

                  HAL_TIM_Base_Stop_DMA PROC
;;;436      */
;;;437    HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
00021c  6801              LDR      r1,[r0,#0]
;;;438    {
;;;439      /* Check the parameters */
;;;440      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;441      
;;;442      /* Disable the TIM Update DMA request */
;;;443      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
00021e  68ca              LDR      r2,[r1,#0xc]
000220  f4227280          BIC      r2,r2,#0x100
000224  60ca              STR      r2,[r1,#0xc]
;;;444          
;;;445      /* Disable the Peripheral */
;;;446      __HAL_TIM_DISABLE(htim);
000226  6801              LDR      r1,[r0,#0]
000228  6a0a              LDR      r2,[r1,#0x20]
00022a  f2411311          MOV      r3,#0x1111
00022e  421a              TST      r2,r3
000230  d107              BNE      |L1.578|
000232  6a0a              LDR      r2,[r1,#0x20]
000234  109b              ASRS     r3,r3,#2
000236  421a              TST      r2,r3
000238  d103              BNE      |L1.578|
00023a  680a              LDR      r2,[r1,#0]
00023c  f0220201          BIC      r2,r2,#1
000240  600a              STR      r2,[r1,#0]
                  |L1.578|
;;;447        
;;;448      /* Change the htim state */
;;;449      htim->State = HAL_TIM_STATE_READY;
000242  2101              MOVS     r1,#1
000244  f8801039          STRB     r1,[r0,#0x39]
;;;450          
;;;451      /* Return function status */
;;;452      return HAL_OK;
000248  2000              MOVS     r0,#0
;;;453    }
00024a  4770              BX       lr
;;;454    /**
                          ENDP

                  HAL_TIM_OC_MspInit PROC
;;;552      */
;;;553    __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
00024c  4770              BX       lr
;;;554    {
;;;555      /* NOTE : This function Should not be modified, when the callback is needed,
;;;556                the HAL_TIM_OC_MspInit could be implemented in the user file
;;;557       */
;;;558    }
;;;559    
                          ENDP

                  HAL_TIM_OC_Init PROC
;;;485      */
;;;486    HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
00024e  b510              PUSH     {r4,lr}
;;;487    {
000250  4604              MOV      r4,r0
;;;488      /* Check the TIM handle allocation */
;;;489      if(htim == NULL)
000252  2c00              CMP      r4,#0
000254  d003              BEQ      |L1.606|
;;;490      {
;;;491        return HAL_ERROR;
;;;492      }
;;;493    
;;;494      /* Check the parameters */
;;;495      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;496      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;497      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;498     
;;;499      if(htim->State == HAL_TIM_STATE_RESET)
000256  f8940039          LDRB     r0,[r4,#0x39]
00025a  b110              CBZ      r0,|L1.610|
00025c  e007              B        |L1.622|
                  |L1.606|
00025e  2001              MOVS     r0,#1                 ;491
;;;500      { 
;;;501        /* Allocate lock resource and initialize it */
;;;502        htim->Lock = HAL_UNLOCKED;
;;;503        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;504        HAL_TIM_OC_MspInit(htim);
;;;505      }
;;;506      
;;;507      /* Set the TIM state */
;;;508      htim->State= HAL_TIM_STATE_BUSY;
;;;509      
;;;510      /* Init the base time for the Output Compare */  
;;;511      TIM_Base_SetConfig(htim->Instance,  &htim->Init); 
;;;512      
;;;513      /* Initialize the TIM state*/
;;;514      htim->State= HAL_TIM_STATE_READY;
;;;515      
;;;516      return HAL_OK;
;;;517    }
000260  bd10              POP      {r4,pc}
                  |L1.610|
000262  2000              MOVS     r0,#0                 ;502
000264  f8840038          STRB     r0,[r4,#0x38]         ;502
000268  4620              MOV      r0,r4                 ;504
00026a  f7fffffe          BL       HAL_TIM_OC_MspInit
                  |L1.622|
00026e  2002              MOVS     r0,#2                 ;508
000270  f8840039          STRB     r0,[r4,#0x39]         ;508
000274  1d21              ADDS     r1,r4,#4              ;511
000276  6820              LDR      r0,[r4,#0]            ;511
000278  f7fffffe          BL       TIM_Base_SetConfig
00027c  2001              MOVS     r0,#1                 ;514
00027e  f8840039          STRB     r0,[r4,#0x39]         ;514
000282  2000              MOVS     r0,#0                 ;516
000284  bd10              POP      {r4,pc}
;;;518    
                          ENDP

                  HAL_TIM_OC_MspDeInit PROC
;;;565      */
;;;566    __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
000286  4770              BX       lr
;;;567    {
;;;568      /* NOTE : This function Should not be modified, when the callback is needed,
;;;569                the HAL_TIM_OC_MspDeInit could be implemented in the user file
;;;570       */
;;;571    }
;;;572    
                          ENDP

                  HAL_TIM_OC_DeInit PROC
;;;524      */
;;;525    HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
000288  b510              PUSH     {r4,lr}
;;;526    {
00028a  4604              MOV      r4,r0
;;;527      /* Check the parameters */
;;;528      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;529      
;;;530       htim->State = HAL_TIM_STATE_BUSY;
00028c  2002              MOVS     r0,#2
00028e  f8840039          STRB     r0,[r4,#0x39]
;;;531       
;;;532      /* Disable the TIM Peripheral Clock */
;;;533      __HAL_TIM_DISABLE(htim);
000292  6820              LDR      r0,[r4,#0]
000294  6a01              LDR      r1,[r0,#0x20]
000296  f2411211          MOV      r2,#0x1111
00029a  4211              TST      r1,r2
00029c  d107              BNE      |L1.686|
00029e  6a01              LDR      r1,[r0,#0x20]
0002a0  1092              ASRS     r2,r2,#2
0002a2  4211              TST      r1,r2
0002a4  d103              BNE      |L1.686|
0002a6  6801              LDR      r1,[r0,#0]
0002a8  f0210101          BIC      r1,r1,#1
0002ac  6001              STR      r1,[r0,#0]
                  |L1.686|
;;;534      
;;;535      /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;536      HAL_TIM_OC_MspDeInit(htim);
0002ae  4620              MOV      r0,r4
0002b0  f7fffffe          BL       HAL_TIM_OC_MspDeInit
;;;537        
;;;538      /* Change TIM state */  
;;;539      htim->State = HAL_TIM_STATE_RESET; 
0002b4  2000              MOVS     r0,#0
0002b6  f8840039          STRB     r0,[r4,#0x39]
;;;540    
;;;541      /* Release Lock */
;;;542      __HAL_UNLOCK(htim);
0002ba  f8840038          STRB     r0,[r4,#0x38]
;;;543    
;;;544      return HAL_OK;
;;;545    }
0002be  bd10              POP      {r4,pc}
;;;546    
                          ENDP

                  TIM_CCxChannelCmd PROC
;;;4676     */
;;;4677   void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
0002c0  2301              MOVS     r3,#1
;;;4678   {
;;;4679     uint32_t tmp = 0;
;;;4680   
;;;4681     /* Check the parameters */
;;;4682     assert_param(IS_TIM_CC1_INSTANCE(TIMx)); 
;;;4683     assert_param(IS_TIM_CHANNELS(Channel));
;;;4684   
;;;4685     tmp = TIM_CCER_CC1E << Channel;
0002c2  408b              LSLS     r3,r3,r1
;;;4686   
;;;4687     /* Reset the CCxE Bit */
;;;4688     TIMx->CCER &= ~tmp;
0002c4  f8d0c020          LDR      r12,[r0,#0x20]
0002c8  ea2c0303          BIC      r3,r12,r3
0002cc  6203              STR      r3,[r0,#0x20]
;;;4689   
;;;4690     /* Set or reset the CCxE Bit */ 
;;;4691     TIMx->CCER |= (uint32_t)(ChannelState << Channel);
0002ce  6a03              LDR      r3,[r0,#0x20]
0002d0  fa02f101          LSL      r1,r2,r1
0002d4  4319              ORRS     r1,r1,r3
0002d6  6201              STR      r1,[r0,#0x20]
;;;4692   }
0002d8  4770              BX       lr
;;;4693   
                          ENDP

                  HAL_TIM_OC_Start PROC
;;;584      */
;;;585    HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
0002da  b510              PUSH     {r4,lr}
;;;586    {
0002dc  4604              MOV      r4,r0
;;;587      /* Check the parameters */
;;;588      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;589      
;;;590      /* Enable the Output compare channel */
;;;591      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
0002de  2201              MOVS     r2,#1
0002e0  6820              LDR      r0,[r4,#0]
0002e2  f7fffffe          BL       TIM_CCxChannelCmd
;;;592      
;;;593      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
0002e6  6821              LDR      r1,[r4,#0]
0002e8  f1a14080          SUB      r0,r1,#0x40000000
0002ec  f5b03080          SUBS     r0,r0,#0x10000
0002f0  d002              BEQ      |L1.760|
0002f2  f5b06080          SUBS     r0,r0,#0x400
0002f6  d103              BNE      |L1.768|
                  |L1.760|
;;;594      {
;;;595        /* Enable the main output */
;;;596        __HAL_TIM_MOE_ENABLE(htim);
0002f8  6c48              LDR      r0,[r1,#0x44]
0002fa  f4404000          ORR      r0,r0,#0x8000
0002fe  6448              STR      r0,[r1,#0x44]
                  |L1.768|
;;;597      }
;;;598      
;;;599      /* Enable the Peripheral */
;;;600      __HAL_TIM_ENABLE(htim); 
000300  6820              LDR      r0,[r4,#0]
000302  6801              LDR      r1,[r0,#0]
000304  f0410101          ORR      r1,r1,#1
000308  6001              STR      r1,[r0,#0]
;;;601      
;;;602      /* Return function status */
;;;603      return HAL_OK;
00030a  2000              MOVS     r0,#0
;;;604    }
00030c  bd10              POP      {r4,pc}
;;;605    
                          ENDP

                  HAL_TIM_OC_Stop PROC
;;;617      */
;;;618    HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
00030e  b510              PUSH     {r4,lr}
;;;619    {
000310  4604              MOV      r4,r0
;;;620      /* Check the parameters */
;;;621      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;622      
;;;623      /* Disable the Output compare channel */
;;;624      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000312  2200              MOVS     r2,#0
000314  6820              LDR      r0,[r4,#0]
000316  f7fffffe          BL       TIM_CCxChannelCmd
;;;625      
;;;626      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00031a  6821              LDR      r1,[r4,#0]
;;;627      {
;;;628        /* Disable the Main Output */
;;;629        __HAL_TIM_MOE_DISABLE(htim);
00031c  f2411311          MOV      r3,#0x1111
000320  109a              ASRS     r2,r3,#2
000322  f1a14080          SUB      r0,r1,#0x40000000     ;626
000326  f5b03080          SUBS     r0,r0,#0x10000        ;626
00032a  d002              BEQ      |L1.818|
00032c  f5b06080          SUBS     r0,r0,#0x400          ;626
000330  d109              BNE      |L1.838|
                  |L1.818|
000332  6a08              LDR      r0,[r1,#0x20]
000334  4218              TST      r0,r3
000336  d106              BNE      |L1.838|
000338  6a08              LDR      r0,[r1,#0x20]
00033a  4210              TST      r0,r2
00033c  d103              BNE      |L1.838|
00033e  6c48              LDR      r0,[r1,#0x44]
000340  f4204000          BIC      r0,r0,#0x8000
000344  6448              STR      r0,[r1,#0x44]
                  |L1.838|
;;;630      }  
;;;631      
;;;632      /* Disable the Peripheral */
;;;633      __HAL_TIM_DISABLE(htim);  
000346  6820              LDR      r0,[r4,#0]
000348  6a01              LDR      r1,[r0,#0x20]
00034a  4219              TST      r1,r3
00034c  d106              BNE      |L1.860|
00034e  6a01              LDR      r1,[r0,#0x20]
000350  4211              TST      r1,r2
000352  d103              BNE      |L1.860|
000354  6801              LDR      r1,[r0,#0]
000356  f0210101          BIC      r1,r1,#1
00035a  6001              STR      r1,[r0,#0]
                  |L1.860|
;;;634      
;;;635      /* Return function status */
;;;636      return HAL_OK;
00035c  2000              MOVS     r0,#0
;;;637    }  
00035e  bd10              POP      {r4,pc}
;;;638    
                          ENDP

                  HAL_TIM_OC_Start_IT PROC
;;;650      */
;;;651    HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000360  b510              PUSH     {r4,lr}
;;;652    {
000362  4604              MOV      r4,r0
;;;653      /* Check the parameters */
;;;654      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;655      
;;;656      switch (Channel)
000364  2900              CMP      r1,#0
;;;657      {
;;;658        case TIM_CHANNEL_1:
;;;659        {       
;;;660          /* Enable the TIM Capture/Compare 1 interrupt */
;;;661          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000366  6822              LDR      r2,[r4,#0]
000368  d006              BEQ      |L1.888|
00036a  2904              CMP      r1,#4                 ;656
00036c  d009              BEQ      |L1.898|
00036e  2908              CMP      r1,#8                 ;656
000370  d00c              BEQ      |L1.908|
000372  290c              CMP      r1,#0xc               ;656
000374  d113              BNE      |L1.926|
000376  e00e              B        |L1.918|
                  |L1.888|
000378  68d0              LDR      r0,[r2,#0xc]
00037a  f0400002          ORR      r0,r0,#2
00037e  60d0              STR      r0,[r2,#0xc]
;;;662        }
;;;663        break;
000380  e00d              B        |L1.926|
                  |L1.898|
;;;664        
;;;665        case TIM_CHANNEL_2:
;;;666        {
;;;667          /* Enable the TIM Capture/Compare 2 interrupt */
;;;668          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000382  68d0              LDR      r0,[r2,#0xc]
000384  f0400004          ORR      r0,r0,#4
000388  60d0              STR      r0,[r2,#0xc]
;;;669        }
;;;670        break;
00038a  e008              B        |L1.926|
                  |L1.908|
;;;671        
;;;672        case TIM_CHANNEL_3:
;;;673        {
;;;674          /* Enable the TIM Capture/Compare 3 interrupt */
;;;675          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
00038c  68d0              LDR      r0,[r2,#0xc]
00038e  f0400008          ORR      r0,r0,#8
000392  60d0              STR      r0,[r2,#0xc]
;;;676        }
;;;677        break;
000394  e003              B        |L1.926|
                  |L1.918|
;;;678        
;;;679        case TIM_CHANNEL_4:
;;;680        {
;;;681          /* Enable the TIM Capture/Compare 4 interrupt */
;;;682          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000396  68d0              LDR      r0,[r2,#0xc]
000398  f0400010          ORR      r0,r0,#0x10
00039c  60d0              STR      r0,[r2,#0xc]
                  |L1.926|
;;;683        }
;;;684        break;
;;;685        
;;;686        default:
;;;687        break;
;;;688      } 
;;;689    
;;;690      /* Enable the Output compare channel */
;;;691      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
00039e  2201              MOVS     r2,#1
0003a0  6820              LDR      r0,[r4,#0]
0003a2  f7fffffe          BL       TIM_CCxChannelCmd
;;;692      
;;;693      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
0003a6  6820              LDR      r0,[r4,#0]
0003a8  f1a04180          SUB      r1,r0,#0x40000000
0003ac  f5b13180          SUBS     r1,r1,#0x10000
0003b0  d002              BEQ      |L1.952|
0003b2  f5b16180          SUBS     r1,r1,#0x400
0003b6  d103              BNE      |L1.960|
                  |L1.952|
;;;694      {
;;;695        /* Enable the main output */
;;;696        __HAL_TIM_MOE_ENABLE(htim);
0003b8  6c41              LDR      r1,[r0,#0x44]
0003ba  f4414100          ORR      r1,r1,#0x8000
0003be  6441              STR      r1,[r0,#0x44]
                  |L1.960|
;;;697      }
;;;698    
;;;699      /* Enable the Peripheral */
;;;700      __HAL_TIM_ENABLE(htim);
0003c0  6820              LDR      r0,[r4,#0]
0003c2  6801              LDR      r1,[r0,#0]
0003c4  f0410101          ORR      r1,r1,#1
0003c8  6001              STR      r1,[r0,#0]
;;;701      
;;;702      /* Return function status */
;;;703      return HAL_OK;
0003ca  2000              MOVS     r0,#0
;;;704    }
0003cc  bd10              POP      {r4,pc}
;;;705    
                          ENDP

                  HAL_TIM_OC_Stop_IT PROC
;;;717      */
;;;718    HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
0003ce  b510              PUSH     {r4,lr}
;;;719    {
0003d0  4604              MOV      r4,r0
;;;720      /* Check the parameters */
;;;721      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;722      
;;;723      switch (Channel)
0003d2  2900              CMP      r1,#0
;;;724      {
;;;725        case TIM_CHANNEL_1:
;;;726        {       
;;;727          /* Disable the TIM Capture/Compare 1 interrupt */
;;;728          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
0003d4  6822              LDR      r2,[r4,#0]
0003d6  d013              BEQ      |L1.1024|
0003d8  2904              CMP      r1,#4                 ;723
0003da  d016              BEQ      |L1.1034|
0003dc  2908              CMP      r1,#8                 ;723
0003de  d019              BEQ      |L1.1044|
0003e0  290c              CMP      r1,#0xc               ;723
0003e2  d120              BNE      |L1.1062|
0003e4  e01b              B        |L1.1054|
0003e6  0000              DCW      0x0000
                  |L1.1000|
                          DCD      0x40010000
                  |L1.1004|
                          DCD      0x40000400
                  |L1.1008|
                          DCD      0x40000800
                  |L1.1012|
                          DCD      0x40000c00
                  |L1.1016|
                          DCD      0x40010400
                  |L1.1020|
                          DCD      _Z24TIM_DMAPeriodElapsedCpltP19__DMA_HandleTypeDef ; TIM_DMAPeriodElapsedCplt(__DMA_HandleTypeDef*)
                  |L1.1024|
000400  68d0              LDR      r0,[r2,#0xc]
000402  f0200002          BIC      r0,r0,#2
000406  60d0              STR      r0,[r2,#0xc]
;;;729        }
;;;730        break;
000408  e00d              B        |L1.1062|
                  |L1.1034|
;;;731        
;;;732        case TIM_CHANNEL_2:
;;;733        {
;;;734          /* Disable the TIM Capture/Compare 2 interrupt */
;;;735          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00040a  68d0              LDR      r0,[r2,#0xc]
00040c  f0200004          BIC      r0,r0,#4
000410  60d0              STR      r0,[r2,#0xc]
;;;736        }
;;;737        break;
000412  e008              B        |L1.1062|
                  |L1.1044|
;;;738        
;;;739        case TIM_CHANNEL_3:
;;;740        {
;;;741          /* Disable the TIM Capture/Compare 3 interrupt */
;;;742          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
000414  68d0              LDR      r0,[r2,#0xc]
000416  f0200008          BIC      r0,r0,#8
00041a  60d0              STR      r0,[r2,#0xc]
;;;743        }
;;;744        break;
00041c  e003              B        |L1.1062|
                  |L1.1054|
;;;745        
;;;746        case TIM_CHANNEL_4:
;;;747        {
;;;748          /* Disable the TIM Capture/Compare 4 interrupt */
;;;749          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
00041e  68d0              LDR      r0,[r2,#0xc]
000420  f0200010          BIC      r0,r0,#0x10
000424  60d0              STR      r0,[r2,#0xc]
                  |L1.1062|
;;;750        }
;;;751        break;
;;;752        
;;;753        default:
;;;754        break; 
;;;755      } 
;;;756      
;;;757      /* Disable the Output compare channel */
;;;758      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
000426  2200              MOVS     r2,#0
000428  6820              LDR      r0,[r4,#0]
00042a  f7fffffe          BL       TIM_CCxChannelCmd
;;;759      
;;;760      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00042e  6821              LDR      r1,[r4,#0]
;;;761      {
;;;762        /* Disable the Main Output */
;;;763        __HAL_TIM_MOE_DISABLE(htim);
000430  f2411311          MOV      r3,#0x1111
000434  109a              ASRS     r2,r3,#2
000436  f1a14080          SUB      r0,r1,#0x40000000     ;760
00043a  f5b03080          SUBS     r0,r0,#0x10000        ;760
00043e  d002              BEQ      |L1.1094|
000440  f5b06080          SUBS     r0,r0,#0x400          ;760
000444  d109              BNE      |L1.1114|
                  |L1.1094|
000446  6a08              LDR      r0,[r1,#0x20]
000448  4218              TST      r0,r3
00044a  d106              BNE      |L1.1114|
00044c  6a08              LDR      r0,[r1,#0x20]
00044e  4210              TST      r0,r2
000450  d103              BNE      |L1.1114|
000452  6c48              LDR      r0,[r1,#0x44]
000454  f4204000          BIC      r0,r0,#0x8000
000458  6448              STR      r0,[r1,#0x44]
                  |L1.1114|
;;;764      }
;;;765      
;;;766      /* Disable the Peripheral */
;;;767      __HAL_TIM_DISABLE(htim);  
00045a  6820              LDR      r0,[r4,#0]
00045c  6a01              LDR      r1,[r0,#0x20]
00045e  4219              TST      r1,r3
000460  d106              BNE      |L1.1136|
000462  6a01              LDR      r1,[r0,#0x20]
000464  4211              TST      r1,r2
000466  d103              BNE      |L1.1136|
000468  6801              LDR      r1,[r0,#0]
00046a  f0210101          BIC      r1,r1,#1
00046e  6001              STR      r1,[r0,#0]
                  |L1.1136|
;;;768      
;;;769      /* Return function status */
;;;770      return HAL_OK;
000470  2000              MOVS     r0,#0
;;;771    }
000472  bd10              POP      {r4,pc}
;;;772    
                          ENDP

                  HAL_TIM_PWM_PulseFinishedCallback PROC
;;;4290     */
;;;4291   __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
000474  4770              BX       lr
;;;4292   {
;;;4293     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4294               the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
;;;4295      */
;;;4296   }
;;;4297   
                          ENDP

                  TIM_DMADelayPulseCplt PROC
;;;4586     */
;;;4587   void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
000476  b510              PUSH     {r4,lr}
;;;4588   {
;;;4589     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000478  6b84              LDR      r4,[r0,#0x38]
;;;4590     
;;;4591     htim->State= HAL_TIM_STATE_READY; 
00047a  2101              MOVS     r1,#1
00047c  f8841039          STRB     r1,[r4,#0x39]
;;;4592     
;;;4593     if(hdma == htim->hdma[TIM_DMA_ID_CC1])
000480  6a22              LDR      r2,[r4,#0x20]
000482  4282              CMP      r2,r0
000484  d101              BNE      |L1.1162|
;;;4594     {
;;;4595       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000486  7621              STRB     r1,[r4,#0x18]
000488  e010              B        |L1.1196|
                  |L1.1162|
;;;4596     }
;;;4597     else if(hdma == htim->hdma[TIM_DMA_ID_CC2])
00048a  6a61              LDR      r1,[r4,#0x24]
00048c  4281              CMP      r1,r0
00048e  d102              BNE      |L1.1174|
;;;4598     {
;;;4599       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000490  2002              MOVS     r0,#2
000492  7620              STRB     r0,[r4,#0x18]
000494  e00a              B        |L1.1196|
                  |L1.1174|
;;;4600     }
;;;4601     else if(hdma == htim->hdma[TIM_DMA_ID_CC3])
000496  6aa1              LDR      r1,[r4,#0x28]
000498  4281              CMP      r1,r0
00049a  d102              BNE      |L1.1186|
;;;4602     {
;;;4603       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
00049c  2004              MOVS     r0,#4
00049e  7620              STRB     r0,[r4,#0x18]
0004a0  e004              B        |L1.1196|
                  |L1.1186|
;;;4604     }
;;;4605     else if(hdma == htim->hdma[TIM_DMA_ID_CC4])
0004a2  6ae1              LDR      r1,[r4,#0x2c]
0004a4  4281              CMP      r1,r0
0004a6  d101              BNE      |L1.1196|
;;;4606     {
;;;4607       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
0004a8  2008              MOVS     r0,#8
0004aa  7620              STRB     r0,[r4,#0x18]
                  |L1.1196|
;;;4608     }
;;;4609   
;;;4610     HAL_TIM_PWM_PulseFinishedCallback(htim);
0004ac  4620              MOV      r0,r4
0004ae  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
;;;4611   
;;;4612     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;  
0004b2  2000              MOVS     r0,#0
0004b4  7620              STRB     r0,[r4,#0x18]
;;;4613   }
0004b6  bd10              POP      {r4,pc}
;;;4614   
                          ENDP

                  HAL_TIM_OC_Start_DMA PROC
;;;786      */
;;;787    HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
0004b8  b570              PUSH     {r4-r6,lr}
;;;788    {
0004ba  4604              MOV      r4,r0
0004bc  460d              MOV      r5,r1
0004be  4694              MOV      r12,r2
;;;789      /* Check the parameters */
;;;790      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;791      
;;;792      if((htim->State == HAL_TIM_STATE_BUSY))
0004c0  f8940039          LDRB     r0,[r4,#0x39]
0004c4  2802              CMP      r0,#2
0004c6  d004              BEQ      |L1.1234|
;;;793      {
;;;794         return HAL_BUSY;
;;;795      }
;;;796      else if((htim->State == HAL_TIM_STATE_READY))
0004c8  f8940039          LDRB     r0,[r4,#0x39]
0004cc  2801              CMP      r0,#1
0004ce  d002              BEQ      |L1.1238|
0004d0  e00a              B        |L1.1256|
                  |L1.1234|
0004d2  2002              MOVS     r0,#2                 ;794
;;;797      {
;;;798        if(((uint32_t)pData == 0 ) && (Length > 0)) 
;;;799        {
;;;800          return HAL_ERROR;                                    
;;;801        }
;;;802        else
;;;803        {
;;;804          htim->State = HAL_TIM_STATE_BUSY;
;;;805        }
;;;806      }    
;;;807      switch (Channel)
;;;808      {
;;;809        case TIM_CHANNEL_1:
;;;810        {      
;;;811          /* Set the DMA Period elapsed callback */
;;;812          htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;813         
;;;814          /* Set the DMA error callback */
;;;815          htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;816          
;;;817          /* Enable the DMA Stream */
;;;818          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;819          
;;;820          /* Enable the TIM Capture/Compare 1 DMA request */
;;;821          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;822        }
;;;823        break;
;;;824        
;;;825        case TIM_CHANNEL_2:
;;;826        {
;;;827          /* Set the DMA Period elapsed callback */
;;;828          htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;829         
;;;830          /* Set the DMA error callback */
;;;831          htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;832          
;;;833          /* Enable the DMA Stream */
;;;834          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;835          
;;;836          /* Enable the TIM Capture/Compare 2 DMA request */
;;;837          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;838        }
;;;839        break;
;;;840        
;;;841        case TIM_CHANNEL_3:
;;;842        {
;;;843          /* Set the DMA Period elapsed callback */
;;;844          htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;845         
;;;846          /* Set the DMA error callback */
;;;847          htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;848          
;;;849          /* Enable the DMA Stream */
;;;850          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;851          
;;;852          /* Enable the TIM Capture/Compare 3 DMA request */
;;;853          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;854        }
;;;855        break;
;;;856        
;;;857        case TIM_CHANNEL_4:
;;;858        {
;;;859         /* Set the DMA Period elapsed callback */
;;;860          htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;861         
;;;862          /* Set the DMA error callback */
;;;863          htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;864          
;;;865          /* Enable the DMA Stream */
;;;866          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;867          
;;;868          /* Enable the TIM Capture/Compare 4 DMA request */
;;;869          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;870        }
;;;871        break;
;;;872        
;;;873        default:
;;;874        break;
;;;875      }
;;;876    
;;;877      /* Enable the Output compare channel */
;;;878      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;879      
;;;880      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;881      {
;;;882        /* Enable the main output */
;;;883        __HAL_TIM_MOE_ENABLE(htim);
;;;884      }  
;;;885      
;;;886      /* Enable the Peripheral */
;;;887      __HAL_TIM_ENABLE(htim); 
;;;888      
;;;889      /* Return function status */
;;;890      return HAL_OK;
;;;891    }
0004d4  bd70              POP      {r4-r6,pc}
                  |L1.1238|
0004d6  f1bc0f00          CMP      r12,#0                ;798
0004da  d102              BNE      |L1.1250|
0004dc  b10b              CBZ      r3,|L1.1250|
0004de  2001              MOVS     r0,#1                 ;800
0004e0  bd70              POP      {r4-r6,pc}
                  |L1.1250|
0004e2  2002              MOVS     r0,#2                 ;804
0004e4  f8840039          STRB     r0,[r4,#0x39]         ;804
                  |L1.1256|
0004e8  f2af0075          ADR      r0,TIM_DMADelayPulseCplt + 1
0004ec  f2af3153          ADR      r1,TIM_DMAError + 1
0004f0  b135              CBZ      r5,|L1.1280|
0004f2  2d04              CMP      r5,#4                 ;807
0004f4  d015              BEQ      |L1.1314|
0004f6  2d08              CMP      r5,#8                 ;807
0004f8  d024              BEQ      |L1.1348|
0004fa  2d0c              CMP      r5,#0xc               ;807
0004fc  d143              BNE      |L1.1414|
0004fe  e032              B        |L1.1382|
                  |L1.1280|
000500  6a22              LDR      r2,[r4,#0x20]         ;812
000502  63d0              STR      r0,[r2,#0x3c]         ;812
000504  6a20              LDR      r0,[r4,#0x20]         ;815
000506  6481              STR      r1,[r0,#0x48]         ;815
000508  6820              LDR      r0,[r4,#0]            ;818
00050a  4661              MOV      r1,r12                ;818
00050c  f1000234          ADD      r2,r0,#0x34           ;818
000510  6a20              LDR      r0,[r4,#0x20]         ;818
000512  f7fffffe          BL       HAL_DMA_Start_IT
000516  6820              LDR      r0,[r4,#0]            ;821
000518  68c1              LDR      r1,[r0,#0xc]          ;821
00051a  f4417100          ORR      r1,r1,#0x200          ;821
00051e  60c1              STR      r1,[r0,#0xc]          ;821
000520  e031              B        |L1.1414|
                  |L1.1314|
000522  6a62              LDR      r2,[r4,#0x24]         ;828
000524  63d0              STR      r0,[r2,#0x3c]         ;828
000526  6a60              LDR      r0,[r4,#0x24]         ;831
000528  6481              STR      r1,[r0,#0x48]         ;831
00052a  6820              LDR      r0,[r4,#0]            ;834
00052c  4661              MOV      r1,r12                ;834
00052e  f1000238          ADD      r2,r0,#0x38           ;834
000532  6a60              LDR      r0,[r4,#0x24]         ;834
000534  f7fffffe          BL       HAL_DMA_Start_IT
000538  6820              LDR      r0,[r4,#0]            ;837
00053a  68c1              LDR      r1,[r0,#0xc]          ;837
00053c  f4416180          ORR      r1,r1,#0x400          ;837
000540  60c1              STR      r1,[r0,#0xc]          ;837
000542  e020              B        |L1.1414|
                  |L1.1348|
000544  6aa2              LDR      r2,[r4,#0x28]         ;844
000546  63d0              STR      r0,[r2,#0x3c]         ;844
000548  6aa0              LDR      r0,[r4,#0x28]         ;847
00054a  6481              STR      r1,[r0,#0x48]         ;847
00054c  6820              LDR      r0,[r4,#0]            ;850
00054e  4661              MOV      r1,r12                ;850
000550  f100023c          ADD      r2,r0,#0x3c           ;850
000554  6aa0              LDR      r0,[r4,#0x28]         ;850
000556  f7fffffe          BL       HAL_DMA_Start_IT
00055a  6820              LDR      r0,[r4,#0]            ;853
00055c  68c1              LDR      r1,[r0,#0xc]          ;853
00055e  f4416100          ORR      r1,r1,#0x800          ;853
000562  60c1              STR      r1,[r0,#0xc]          ;853
000564  e00f              B        |L1.1414|
                  |L1.1382|
000566  6ae2              LDR      r2,[r4,#0x2c]         ;860
000568  63d0              STR      r0,[r2,#0x3c]         ;860
00056a  6ae0              LDR      r0,[r4,#0x2c]         ;863
00056c  6481              STR      r1,[r0,#0x48]         ;863
00056e  6820              LDR      r0,[r4,#0]            ;866
000570  4661              MOV      r1,r12                ;866
000572  f1000240          ADD      r2,r0,#0x40           ;866
000576  6ae0              LDR      r0,[r4,#0x2c]         ;866
000578  f7fffffe          BL       HAL_DMA_Start_IT
00057c  6820              LDR      r0,[r4,#0]            ;869
00057e  68c1              LDR      r1,[r0,#0xc]          ;869
000580  f4415180          ORR      r1,r1,#0x1000         ;869
000584  60c1              STR      r1,[r0,#0xc]          ;869
                  |L1.1414|
000586  2201              MOVS     r2,#1                 ;878
000588  4629              MOV      r1,r5                 ;878
00058a  6820              LDR      r0,[r4,#0]            ;878
00058c  f7fffffe          BL       TIM_CCxChannelCmd
000590  6820              LDR      r0,[r4,#0]            ;880
000592  f1a04180          SUB      r1,r0,#0x40000000     ;880
000596  f5b13180          SUBS     r1,r1,#0x10000        ;880
00059a  d002              BEQ      |L1.1442|
00059c  f5b16180          SUBS     r1,r1,#0x400          ;880
0005a0  d103              BNE      |L1.1450|
                  |L1.1442|
0005a2  6c41              LDR      r1,[r0,#0x44]         ;883
0005a4  f4414100          ORR      r1,r1,#0x8000         ;883
0005a8  6441              STR      r1,[r0,#0x44]         ;883
                  |L1.1450|
0005aa  6820              LDR      r0,[r4,#0]            ;887
0005ac  6801              LDR      r1,[r0,#0]            ;887
0005ae  f0410101          ORR      r1,r1,#1              ;887
0005b2  6001              STR      r1,[r0,#0]            ;887
0005b4  2000              MOVS     r0,#0                 ;890
0005b6  bd70              POP      {r4-r6,pc}
;;;892    
                          ENDP

                  HAL_TIM_OC_Stop_DMA PROC
;;;904      */
;;;905    HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
0005b8  b510              PUSH     {r4,lr}
;;;906    {
0005ba  4604              MOV      r4,r0
;;;907      /* Check the parameters */
;;;908      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;909      
;;;910      switch (Channel)
0005bc  2900              CMP      r1,#0
;;;911      {
;;;912        case TIM_CHANNEL_1:
;;;913        {       
;;;914          /* Disable the TIM Capture/Compare 1 DMA request */
;;;915          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
0005be  6822              LDR      r2,[r4,#0]
0005c0  d006              BEQ      |L1.1488|
0005c2  2904              CMP      r1,#4                 ;910
0005c4  d009              BEQ      |L1.1498|
0005c6  2908              CMP      r1,#8                 ;910
0005c8  d00c              BEQ      |L1.1508|
0005ca  290c              CMP      r1,#0xc               ;910
0005cc  d113              BNE      |L1.1526|
0005ce  e00e              B        |L1.1518|
                  |L1.1488|
0005d0  68d0              LDR      r0,[r2,#0xc]
0005d2  f4207000          BIC      r0,r0,#0x200
0005d6  60d0              STR      r0,[r2,#0xc]
;;;916        }
;;;917        break;
0005d8  e00d              B        |L1.1526|
                  |L1.1498|
;;;918        
;;;919        case TIM_CHANNEL_2:
;;;920        {
;;;921          /* Disable the TIM Capture/Compare 2 DMA request */
;;;922          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
0005da  68d0              LDR      r0,[r2,#0xc]
0005dc  f4206080          BIC      r0,r0,#0x400
0005e0  60d0              STR      r0,[r2,#0xc]
;;;923        }
;;;924        break;
0005e2  e008              B        |L1.1526|
                  |L1.1508|
;;;925        
;;;926        case TIM_CHANNEL_3:
;;;927        {
;;;928          /* Disable the TIM Capture/Compare 3 DMA request */
;;;929          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
0005e4  68d0              LDR      r0,[r2,#0xc]
0005e6  f4206000          BIC      r0,r0,#0x800
0005ea  60d0              STR      r0,[r2,#0xc]
;;;930        }
;;;931        break;
0005ec  e003              B        |L1.1526|
                  |L1.1518|
;;;932        
;;;933        case TIM_CHANNEL_4:
;;;934        {
;;;935          /* Disable the TIM Capture/Compare 4 interrupt */
;;;936          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
0005ee  68d0              LDR      r0,[r2,#0xc]
0005f0  f4205080          BIC      r0,r0,#0x1000
0005f4  60d0              STR      r0,[r2,#0xc]
                  |L1.1526|
;;;937        }
;;;938        break;
;;;939        
;;;940        default:
;;;941        break;
;;;942      } 
;;;943      
;;;944      /* Disable the Output compare channel */
;;;945      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
0005f6  2200              MOVS     r2,#0
0005f8  6820              LDR      r0,[r4,#0]
0005fa  f7fffffe          BL       TIM_CCxChannelCmd
;;;946      
;;;947      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
0005fe  6821              LDR      r1,[r4,#0]
;;;948      {
;;;949        /* Disable the Main Output */
;;;950        __HAL_TIM_MOE_DISABLE(htim);
000600  f2411311          MOV      r3,#0x1111
000604  109a              ASRS     r2,r3,#2
000606  f1a14080          SUB      r0,r1,#0x40000000     ;947
00060a  f5b03080          SUBS     r0,r0,#0x10000        ;947
00060e  d002              BEQ      |L1.1558|
000610  f5b06080          SUBS     r0,r0,#0x400          ;947
000614  d109              BNE      |L1.1578|
                  |L1.1558|
000616  6a08              LDR      r0,[r1,#0x20]
000618  4218              TST      r0,r3
00061a  d106              BNE      |L1.1578|
00061c  6a08              LDR      r0,[r1,#0x20]
00061e  4210              TST      r0,r2
000620  d103              BNE      |L1.1578|
000622  6c48              LDR      r0,[r1,#0x44]
000624  f4204000          BIC      r0,r0,#0x8000
000628  6448              STR      r0,[r1,#0x44]
                  |L1.1578|
;;;951      }
;;;952      
;;;953      /* Disable the Peripheral */
;;;954      __HAL_TIM_DISABLE(htim);
00062a  6820              LDR      r0,[r4,#0]
00062c  6a01              LDR      r1,[r0,#0x20]
00062e  4219              TST      r1,r3
000630  d106              BNE      |L1.1600|
000632  6a01              LDR      r1,[r0,#0x20]
000634  4211              TST      r1,r2
000636  d103              BNE      |L1.1600|
000638  6801              LDR      r1,[r0,#0]
00063a  f0210101          BIC      r1,r1,#1
00063e  6001              STR      r1,[r0,#0]
                  |L1.1600|
;;;955      
;;;956      /* Change the htim state */
;;;957      htim->State = HAL_TIM_STATE_READY;
000640  2001              MOVS     r0,#1
000642  f8840039          STRB     r0,[r4,#0x39]
;;;958      
;;;959      /* Return function status */
;;;960      return HAL_OK;
000646  2000              MOVS     r0,#0
;;;961    }
000648  bd10              POP      {r4,pc}
;;;962    /**
                          ENDP

                  HAL_TIM_PWM_MspInit PROC
;;;1060     */
;;;1061   __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
00064a  4770              BX       lr
;;;1062   {
;;;1063     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1064               the HAL_TIM_PWM_MspInit could be implemented in the user file
;;;1065      */
;;;1066   }
;;;1067   
                          ENDP

                  HAL_TIM_PWM_Init PROC
;;;993      */
;;;994    HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
00064c  b510              PUSH     {r4,lr}
;;;995    {
00064e  4604              MOV      r4,r0
;;;996      /* Check the TIM handle allocation */
;;;997      if(htim == NULL)
000650  2c00              CMP      r4,#0
000652  d003              BEQ      |L1.1628|
;;;998      {
;;;999        return HAL_ERROR;
;;;1000     }
;;;1001   
;;;1002     /* Check the parameters */
;;;1003     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1004     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1005     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1006   
;;;1007     if(htim->State == HAL_TIM_STATE_RESET)
000654  f8940039          LDRB     r0,[r4,#0x39]
000658  b110              CBZ      r0,|L1.1632|
00065a  e007              B        |L1.1644|
                  |L1.1628|
00065c  2001              MOVS     r0,#1                 ;999
;;;1008     {
;;;1009       /* Allocate lock resource and initialize it */
;;;1010       htim->Lock = HAL_UNLOCKED;
;;;1011       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1012       HAL_TIM_PWM_MspInit(htim);
;;;1013     }
;;;1014   
;;;1015     /* Set the TIM state */
;;;1016     htim->State= HAL_TIM_STATE_BUSY;  
;;;1017     
;;;1018     /* Init the base time for the PWM */  
;;;1019     TIM_Base_SetConfig(htim->Instance, &htim->Init); 
;;;1020      
;;;1021     /* Initialize the TIM state*/
;;;1022     htim->State= HAL_TIM_STATE_READY;
;;;1023     
;;;1024     return HAL_OK;
;;;1025   }  
00065e  bd10              POP      {r4,pc}
                  |L1.1632|
000660  2000              MOVS     r0,#0                 ;1010
000662  f8840038          STRB     r0,[r4,#0x38]         ;1010
000666  4620              MOV      r0,r4                 ;1012
000668  f7fffffe          BL       HAL_TIM_PWM_MspInit
                  |L1.1644|
00066c  2002              MOVS     r0,#2                 ;1016
00066e  f8840039          STRB     r0,[r4,#0x39]         ;1016
000672  1d21              ADDS     r1,r4,#4              ;1019
000674  6820              LDR      r0,[r4,#0]            ;1019
000676  f7fffffe          BL       TIM_Base_SetConfig
00067a  2001              MOVS     r0,#1                 ;1022
00067c  f8840039          STRB     r0,[r4,#0x39]         ;1022
000680  2000              MOVS     r0,#0                 ;1024
000682  bd10              POP      {r4,pc}
;;;1026   
                          ENDP

                  HAL_TIM_PWM_MspDeInit PROC
;;;1073     */
;;;1074   __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
000684  4770              BX       lr
;;;1075   {
;;;1076     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1077               the HAL_TIM_PWM_MspDeInit could be implemented in the user file
;;;1078      */
;;;1079   }
;;;1080   
                          ENDP

                  HAL_TIM_PWM_DeInit PROC
;;;1032     */
;;;1033   HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
000686  b510              PUSH     {r4,lr}
;;;1034   {
000688  4604              MOV      r4,r0
;;;1035     /* Check the parameters */
;;;1036     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1037     
;;;1038     htim->State = HAL_TIM_STATE_BUSY;
00068a  2002              MOVS     r0,#2
00068c  f8840039          STRB     r0,[r4,#0x39]
;;;1039     
;;;1040     /* Disable the TIM Peripheral Clock */
;;;1041     __HAL_TIM_DISABLE(htim);
000690  6820              LDR      r0,[r4,#0]
000692  6a01              LDR      r1,[r0,#0x20]
000694  f2411211          MOV      r2,#0x1111
000698  4211              TST      r1,r2
00069a  d107              BNE      |L1.1708|
00069c  6a01              LDR      r1,[r0,#0x20]
00069e  1092              ASRS     r2,r2,#2
0006a0  4211              TST      r1,r2
0006a2  d103              BNE      |L1.1708|
0006a4  6801              LDR      r1,[r0,#0]
0006a6  f0210101          BIC      r1,r1,#1
0006aa  6001              STR      r1,[r0,#0]
                  |L1.1708|
;;;1042       
;;;1043     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1044     HAL_TIM_PWM_MspDeInit(htim);
0006ac  4620              MOV      r0,r4
0006ae  f7fffffe          BL       HAL_TIM_PWM_MspDeInit
;;;1045       
;;;1046     /* Change TIM state */  
;;;1047     htim->State = HAL_TIM_STATE_RESET; 
0006b2  2000              MOVS     r0,#0
0006b4  f8840039          STRB     r0,[r4,#0x39]
;;;1048   
;;;1049     /* Release Lock */
;;;1050     __HAL_UNLOCK(htim);
0006b8  f8840038          STRB     r0,[r4,#0x38]
;;;1051   
;;;1052     return HAL_OK;
;;;1053   }
0006bc  bd10              POP      {r4,pc}
;;;1054   
                          ENDP

                  HAL_TIM_PWM_Start PROC
;;;1092     */
;;;1093   HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
0006be  b510              PUSH     {r4,lr}
;;;1094   {
0006c0  4604              MOV      r4,r0
;;;1095     /* Check the parameters */
;;;1096     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1097   
;;;1098     /* Enable the Capture compare channel */
;;;1099     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
0006c2  2201              MOVS     r2,#1
0006c4  6820              LDR      r0,[r4,#0]
0006c6  f7fffffe          BL       TIM_CCxChannelCmd
;;;1100     
;;;1101     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
0006ca  6821              LDR      r1,[r4,#0]
0006cc  f1a14080          SUB      r0,r1,#0x40000000
0006d0  f5b03080          SUBS     r0,r0,#0x10000
0006d4  d002              BEQ      |L1.1756|
0006d6  f5b06080          SUBS     r0,r0,#0x400
0006da  d103              BNE      |L1.1764|
                  |L1.1756|
;;;1102     {
;;;1103       /* Enable the main output */
;;;1104       __HAL_TIM_MOE_ENABLE(htim);
0006dc  6c48              LDR      r0,[r1,#0x44]
0006de  f4404000          ORR      r0,r0,#0x8000
0006e2  6448              STR      r0,[r1,#0x44]
                  |L1.1764|
;;;1105     }
;;;1106       
;;;1107     /* Enable the Peripheral */
;;;1108     __HAL_TIM_ENABLE(htim);
0006e4  6820              LDR      r0,[r4,#0]
0006e6  6801              LDR      r1,[r0,#0]
0006e8  f0410101          ORR      r1,r1,#1
0006ec  6001              STR      r1,[r0,#0]
;;;1109     
;;;1110     /* Return function status */
;;;1111     return HAL_OK;
0006ee  2000              MOVS     r0,#0
;;;1112   } 
0006f0  bd10              POP      {r4,pc}
;;;1113   
                          ENDP

                  HAL_TIM_PWM_Stop PROC
;;;1125     */
;;;1126   HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
0006f2  b510              PUSH     {r4,lr}
;;;1127   { 
0006f4  4604              MOV      r4,r0
;;;1128     /* Check the parameters */
;;;1129     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1130       
;;;1131     /* Disable the Capture compare channel */
;;;1132     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
0006f6  2200              MOVS     r2,#0
0006f8  6820              LDR      r0,[r4,#0]
0006fa  f7fffffe          BL       TIM_CCxChannelCmd
;;;1133     
;;;1134     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
0006fe  6821              LDR      r1,[r4,#0]
;;;1135     {
;;;1136       /* Disable the Main Output */
;;;1137       __HAL_TIM_MOE_DISABLE(htim);
000700  f2411311          MOV      r3,#0x1111
000704  109a              ASRS     r2,r3,#2
000706  f1a14080          SUB      r0,r1,#0x40000000     ;1134
00070a  f5b03080          SUBS     r0,r0,#0x10000        ;1134
00070e  d002              BEQ      |L1.1814|
000710  f5b06080          SUBS     r0,r0,#0x400          ;1134
000714  d109              BNE      |L1.1834|
                  |L1.1814|
000716  6a08              LDR      r0,[r1,#0x20]
000718  4218              TST      r0,r3
00071a  d106              BNE      |L1.1834|
00071c  6a08              LDR      r0,[r1,#0x20]
00071e  4210              TST      r0,r2
000720  d103              BNE      |L1.1834|
000722  6c48              LDR      r0,[r1,#0x44]
000724  f4204000          BIC      r0,r0,#0x8000
000728  6448              STR      r0,[r1,#0x44]
                  |L1.1834|
;;;1138     }
;;;1139     
;;;1140     /* Disable the Peripheral */
;;;1141     __HAL_TIM_DISABLE(htim);
00072a  6820              LDR      r0,[r4,#0]
00072c  6a01              LDR      r1,[r0,#0x20]
00072e  4219              TST      r1,r3
000730  d106              BNE      |L1.1856|
000732  6a01              LDR      r1,[r0,#0x20]
000734  4211              TST      r1,r2
000736  d103              BNE      |L1.1856|
000738  6801              LDR      r1,[r0,#0]
00073a  f0210101          BIC      r1,r1,#1
00073e  6001              STR      r1,[r0,#0]
                  |L1.1856|
;;;1142     
;;;1143     /* Change the htim state */
;;;1144     htim->State = HAL_TIM_STATE_READY;
000740  2001              MOVS     r0,#1
000742  f8840039          STRB     r0,[r4,#0x39]
;;;1145     
;;;1146     /* Return function status */
;;;1147     return HAL_OK;
000746  2000              MOVS     r0,#0
;;;1148   } 
000748  bd10              POP      {r4,pc}
;;;1149   
                          ENDP

                  HAL_TIM_PWM_Start_IT PROC
;;;1161     */
;;;1162   HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
00074a  b510              PUSH     {r4,lr}
;;;1163   {
00074c  4604              MOV      r4,r0
;;;1164     /* Check the parameters */
;;;1165     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1166     
;;;1167     switch (Channel)
00074e  2900              CMP      r1,#0
;;;1168     {
;;;1169       case TIM_CHANNEL_1:
;;;1170       {       
;;;1171         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1172         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000750  6822              LDR      r2,[r4,#0]
000752  d006              BEQ      |L1.1890|
000754  2904              CMP      r1,#4                 ;1167
000756  d009              BEQ      |L1.1900|
000758  2908              CMP      r1,#8                 ;1167
00075a  d00c              BEQ      |L1.1910|
00075c  290c              CMP      r1,#0xc               ;1167
00075e  d113              BNE      |L1.1928|
000760  e00e              B        |L1.1920|
                  |L1.1890|
000762  68d0              LDR      r0,[r2,#0xc]
000764  f0400002          ORR      r0,r0,#2
000768  60d0              STR      r0,[r2,#0xc]
;;;1173       }
;;;1174       break;
00076a  e00d              B        |L1.1928|
                  |L1.1900|
;;;1175       
;;;1176       case TIM_CHANNEL_2:
;;;1177       {
;;;1178         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1179         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00076c  68d0              LDR      r0,[r2,#0xc]
00076e  f0400004          ORR      r0,r0,#4
000772  60d0              STR      r0,[r2,#0xc]
;;;1180       }
;;;1181       break;
000774  e008              B        |L1.1928|
                  |L1.1910|
;;;1182       
;;;1183       case TIM_CHANNEL_3:
;;;1184       {
;;;1185         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1186         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
000776  68d0              LDR      r0,[r2,#0xc]
000778  f0400008          ORR      r0,r0,#8
00077c  60d0              STR      r0,[r2,#0xc]
;;;1187       }
;;;1188       break;
00077e  e003              B        |L1.1928|
                  |L1.1920|
;;;1189       
;;;1190       case TIM_CHANNEL_4:
;;;1191       {
;;;1192         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1193         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000780  68d0              LDR      r0,[r2,#0xc]
000782  f0400010          ORR      r0,r0,#0x10
000786  60d0              STR      r0,[r2,#0xc]
                  |L1.1928|
;;;1194       }
;;;1195       break;
;;;1196       
;;;1197       default:
;;;1198       break;
;;;1199     } 
;;;1200     
;;;1201     /* Enable the Capture compare channel */
;;;1202     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000788  2201              MOVS     r2,#1
00078a  6820              LDR      r0,[r4,#0]
00078c  f7fffffe          BL       TIM_CCxChannelCmd
;;;1203     
;;;1204     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000790  6820              LDR      r0,[r4,#0]
000792  f1a04180          SUB      r1,r0,#0x40000000
000796  f5b13180          SUBS     r1,r1,#0x10000
00079a  d002              BEQ      |L1.1954|
00079c  f5b16180          SUBS     r1,r1,#0x400
0007a0  d103              BNE      |L1.1962|
                  |L1.1954|
;;;1205     {
;;;1206       /* Enable the main output */
;;;1207       __HAL_TIM_MOE_ENABLE(htim);
0007a2  6c41              LDR      r1,[r0,#0x44]
0007a4  f4414100          ORR      r1,r1,#0x8000
0007a8  6441              STR      r1,[r0,#0x44]
                  |L1.1962|
;;;1208     }
;;;1209   
;;;1210     /* Enable the Peripheral */
;;;1211     __HAL_TIM_ENABLE(htim);
0007aa  6820              LDR      r0,[r4,#0]
0007ac  6801              LDR      r1,[r0,#0]
0007ae  f0410101          ORR      r1,r1,#1
0007b2  6001              STR      r1,[r0,#0]
;;;1212     
;;;1213     /* Return function status */
;;;1214     return HAL_OK;
0007b4  2000              MOVS     r0,#0
;;;1215   } 
0007b6  bd10              POP      {r4,pc}
;;;1216   
                          ENDP

                  HAL_TIM_PWM_Stop_IT PROC
;;;1228     */
;;;1229   HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
0007b8  b510              PUSH     {r4,lr}
;;;1230   {
0007ba  4604              MOV      r4,r0
;;;1231     /* Check the parameters */
;;;1232     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1233     
;;;1234     switch (Channel)
0007bc  2900              CMP      r1,#0
;;;1235     {
;;;1236       case TIM_CHANNEL_1:
;;;1237       {       
;;;1238         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1239         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
0007be  6822              LDR      r2,[r4,#0]
0007c0  d006              BEQ      |L1.2000|
0007c2  2904              CMP      r1,#4                 ;1234
0007c4  d009              BEQ      |L1.2010|
0007c6  2908              CMP      r1,#8                 ;1234
0007c8  d00c              BEQ      |L1.2020|
0007ca  290c              CMP      r1,#0xc               ;1234
0007cc  d113              BNE      |L1.2038|
0007ce  e00e              B        |L1.2030|
                  |L1.2000|
0007d0  68d0              LDR      r0,[r2,#0xc]
0007d2  f0200002          BIC      r0,r0,#2
0007d6  60d0              STR      r0,[r2,#0xc]
;;;1240       }
;;;1241       break;
0007d8  e00d              B        |L1.2038|
                  |L1.2010|
;;;1242       
;;;1243       case TIM_CHANNEL_2:
;;;1244       {
;;;1245         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1246         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
0007da  68d0              LDR      r0,[r2,#0xc]
0007dc  f0200004          BIC      r0,r0,#4
0007e0  60d0              STR      r0,[r2,#0xc]
;;;1247       }
;;;1248       break;
0007e2  e008              B        |L1.2038|
                  |L1.2020|
;;;1249       
;;;1250       case TIM_CHANNEL_3:
;;;1251       {
;;;1252         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1253         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
0007e4  68d0              LDR      r0,[r2,#0xc]
0007e6  f0200008          BIC      r0,r0,#8
0007ea  60d0              STR      r0,[r2,#0xc]
;;;1254       }
;;;1255       break;
0007ec  e003              B        |L1.2038|
                  |L1.2030|
;;;1256       
;;;1257       case TIM_CHANNEL_4:
;;;1258       {
;;;1259         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1260         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
0007ee  68d0              LDR      r0,[r2,#0xc]
0007f0  f0200010          BIC      r0,r0,#0x10
0007f4  60d0              STR      r0,[r2,#0xc]
                  |L1.2038|
;;;1261       }
;;;1262       break;
;;;1263       
;;;1264       default:
;;;1265       break; 
;;;1266     }
;;;1267     
;;;1268     /* Disable the Capture compare channel */
;;;1269     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
0007f6  2200              MOVS     r2,#0
0007f8  6820              LDR      r0,[r4,#0]
0007fa  f7fffffe          BL       TIM_CCxChannelCmd
;;;1270     
;;;1271     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
0007fe  6821              LDR      r1,[r4,#0]
;;;1272     {
;;;1273       /* Disable the Main Output */
;;;1274       __HAL_TIM_MOE_DISABLE(htim);
000800  f2411311          MOV      r3,#0x1111
000804  109a              ASRS     r2,r3,#2
000806  f1a14080          SUB      r0,r1,#0x40000000     ;1271
00080a  f5b03080          SUBS     r0,r0,#0x10000        ;1271
00080e  d002              BEQ      |L1.2070|
000810  f5b06080          SUBS     r0,r0,#0x400          ;1271
000814  d109              BNE      |L1.2090|
                  |L1.2070|
000816  6a08              LDR      r0,[r1,#0x20]
000818  4218              TST      r0,r3
00081a  d106              BNE      |L1.2090|
00081c  6a08              LDR      r0,[r1,#0x20]
00081e  4210              TST      r0,r2
000820  d103              BNE      |L1.2090|
000822  6c48              LDR      r0,[r1,#0x44]
000824  f4204000          BIC      r0,r0,#0x8000
000828  6448              STR      r0,[r1,#0x44]
                  |L1.2090|
;;;1275     }
;;;1276     
;;;1277     /* Disable the Peripheral */
;;;1278     __HAL_TIM_DISABLE(htim);
00082a  6820              LDR      r0,[r4,#0]
00082c  6a01              LDR      r1,[r0,#0x20]
00082e  4219              TST      r1,r3
000830  d106              BNE      |L1.2112|
000832  6a01              LDR      r1,[r0,#0x20]
000834  4211              TST      r1,r2
000836  d103              BNE      |L1.2112|
000838  6801              LDR      r1,[r0,#0]
00083a  f0210101          BIC      r1,r1,#1
00083e  6001              STR      r1,[r0,#0]
                  |L1.2112|
;;;1279     
;;;1280     /* Return function status */
;;;1281     return HAL_OK;
000840  2000              MOVS     r0,#0
;;;1282   } 
000842  bd10              POP      {r4,pc}
;;;1283   
                          ENDP

                  HAL_TIM_PWM_Start_DMA PROC
;;;1297     */
;;;1298   HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000844  b570              PUSH     {r4-r6,lr}
;;;1299   {
000846  4604              MOV      r4,r0
000848  460d              MOV      r5,r1
00084a  4694              MOV      r12,r2
;;;1300     /* Check the parameters */
;;;1301     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1302     
;;;1303     if((htim->State == HAL_TIM_STATE_BUSY))
00084c  f8940039          LDRB     r0,[r4,#0x39]
000850  2802              CMP      r0,#2
000852  d004              BEQ      |L1.2142|
;;;1304     {
;;;1305        return HAL_BUSY;
;;;1306     }
;;;1307     else if((htim->State == HAL_TIM_STATE_READY))
000854  f8940039          LDRB     r0,[r4,#0x39]
000858  2801              CMP      r0,#1
00085a  d002              BEQ      |L1.2146|
00085c  e00a              B        |L1.2164|
                  |L1.2142|
00085e  2002              MOVS     r0,#2                 ;1305
;;;1308     {
;;;1309       if(((uint32_t)pData == 0 ) && (Length > 0)) 
;;;1310       {
;;;1311         return HAL_ERROR;                                    
;;;1312       }
;;;1313       else
;;;1314       {
;;;1315         htim->State = HAL_TIM_STATE_BUSY;
;;;1316       }
;;;1317     }    
;;;1318     switch (Channel)
;;;1319     {
;;;1320       case TIM_CHANNEL_1:
;;;1321       {      
;;;1322         /* Set the DMA Period elapsed callback */
;;;1323         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1324        
;;;1325         /* Set the DMA error callback */
;;;1326         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1327         
;;;1328         /* Enable the DMA Stream */
;;;1329         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;1330         
;;;1331         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1332         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1333       }
;;;1334       break;
;;;1335       
;;;1336       case TIM_CHANNEL_2:
;;;1337       {
;;;1338         /* Set the DMA Period elapsed callback */
;;;1339         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1340        
;;;1341         /* Set the DMA error callback */
;;;1342         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1343         
;;;1344         /* Enable the DMA Stream */
;;;1345         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;1346         
;;;1347         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1348         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1349       }
;;;1350       break;
;;;1351       
;;;1352       case TIM_CHANNEL_3:
;;;1353       {
;;;1354         /* Set the DMA Period elapsed callback */
;;;1355         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1356        
;;;1357         /* Set the DMA error callback */
;;;1358         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1359         
;;;1360         /* Enable the DMA Stream */
;;;1361         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;1362         
;;;1363         /* Enable the TIM Output Capture/Compare 3 request */
;;;1364         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1365       }
;;;1366       break;
;;;1367       
;;;1368       case TIM_CHANNEL_4:
;;;1369       {
;;;1370        /* Set the DMA Period elapsed callback */
;;;1371         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1372        
;;;1373         /* Set the DMA error callback */
;;;1374         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1375         
;;;1376         /* Enable the DMA Stream */
;;;1377         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;1378         
;;;1379         /* Enable the TIM Capture/Compare 4 DMA request */
;;;1380         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1381       }
;;;1382       break;
;;;1383       
;;;1384       default:
;;;1385       break;
;;;1386     }
;;;1387   
;;;1388     /* Enable the Capture compare channel */
;;;1389     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1390       
;;;1391     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;1392     {
;;;1393       /* Enable the main output */
;;;1394       __HAL_TIM_MOE_ENABLE(htim);
;;;1395     }
;;;1396     
;;;1397     /* Enable the Peripheral */
;;;1398     __HAL_TIM_ENABLE(htim); 
;;;1399     
;;;1400     /* Return function status */
;;;1401     return HAL_OK;
;;;1402   }
000860  bd70              POP      {r4-r6,pc}
                  |L1.2146|
000862  f1bc0f00          CMP      r12,#0                ;1309
000866  d102              BNE      |L1.2158|
000868  b10b              CBZ      r3,|L1.2158|
00086a  2001              MOVS     r0,#1                 ;1311
00086c  bd70              POP      {r4-r6,pc}
                  |L1.2158|
00086e  2002              MOVS     r0,#2                 ;1315
000870  f8840039          STRB     r0,[r4,#0x39]         ;1315
                  |L1.2164|
000874  f2af4001          ADR      r0,TIM_DMADelayPulseCplt + 1
000878  f2af61df          ADR      r1,TIM_DMAError + 1
00087c  b135              CBZ      r5,|L1.2188|
00087e  2d04              CMP      r5,#4                 ;1318
000880  d015              BEQ      |L1.2222|
000882  2d08              CMP      r5,#8                 ;1318
000884  d024              BEQ      |L1.2256|
000886  2d0c              CMP      r5,#0xc               ;1318
000888  d143              BNE      |L1.2322|
00088a  e032              B        |L1.2290|
                  |L1.2188|
00088c  6a22              LDR      r2,[r4,#0x20]         ;1323
00088e  63d0              STR      r0,[r2,#0x3c]         ;1323
000890  6a20              LDR      r0,[r4,#0x20]         ;1326
000892  6481              STR      r1,[r0,#0x48]         ;1326
000894  6820              LDR      r0,[r4,#0]            ;1329
000896  4661              MOV      r1,r12                ;1329
000898  f1000234          ADD      r2,r0,#0x34           ;1329
00089c  6a20              LDR      r0,[r4,#0x20]         ;1329
00089e  f7fffffe          BL       HAL_DMA_Start_IT
0008a2  6820              LDR      r0,[r4,#0]            ;1332
0008a4  68c1              LDR      r1,[r0,#0xc]          ;1332
0008a6  f4417100          ORR      r1,r1,#0x200          ;1332
0008aa  60c1              STR      r1,[r0,#0xc]          ;1332
0008ac  e031              B        |L1.2322|
                  |L1.2222|
0008ae  6a62              LDR      r2,[r4,#0x24]         ;1339
0008b0  63d0              STR      r0,[r2,#0x3c]         ;1339
0008b2  6a60              LDR      r0,[r4,#0x24]         ;1342
0008b4  6481              STR      r1,[r0,#0x48]         ;1342
0008b6  6820              LDR      r0,[r4,#0]            ;1345
0008b8  4661              MOV      r1,r12                ;1345
0008ba  f1000238          ADD      r2,r0,#0x38           ;1345
0008be  6a60              LDR      r0,[r4,#0x24]         ;1345
0008c0  f7fffffe          BL       HAL_DMA_Start_IT
0008c4  6820              LDR      r0,[r4,#0]            ;1348
0008c6  68c1              LDR      r1,[r0,#0xc]          ;1348
0008c8  f4416180          ORR      r1,r1,#0x400          ;1348
0008cc  60c1              STR      r1,[r0,#0xc]          ;1348
0008ce  e020              B        |L1.2322|
                  |L1.2256|
0008d0  6aa2              LDR      r2,[r4,#0x28]         ;1355
0008d2  63d0              STR      r0,[r2,#0x3c]         ;1355
0008d4  6aa0              LDR      r0,[r4,#0x28]         ;1358
0008d6  6481              STR      r1,[r0,#0x48]         ;1358
0008d8  6820              LDR      r0,[r4,#0]            ;1361
0008da  4661              MOV      r1,r12                ;1361
0008dc  f100023c          ADD      r2,r0,#0x3c           ;1361
0008e0  6aa0              LDR      r0,[r4,#0x28]         ;1361
0008e2  f7fffffe          BL       HAL_DMA_Start_IT
0008e6  6820              LDR      r0,[r4,#0]            ;1364
0008e8  68c1              LDR      r1,[r0,#0xc]          ;1364
0008ea  f4416100          ORR      r1,r1,#0x800          ;1364
0008ee  60c1              STR      r1,[r0,#0xc]          ;1364
0008f0  e00f              B        |L1.2322|
                  |L1.2290|
0008f2  6ae2              LDR      r2,[r4,#0x2c]         ;1371
0008f4  63d0              STR      r0,[r2,#0x3c]         ;1371
0008f6  6ae0              LDR      r0,[r4,#0x2c]         ;1374
0008f8  6481              STR      r1,[r0,#0x48]         ;1374
0008fa  6820              LDR      r0,[r4,#0]            ;1377
0008fc  4661              MOV      r1,r12                ;1377
0008fe  f1000240          ADD      r2,r0,#0x40           ;1377
000902  6ae0              LDR      r0,[r4,#0x2c]         ;1377
000904  f7fffffe          BL       HAL_DMA_Start_IT
000908  6820              LDR      r0,[r4,#0]            ;1380
00090a  68c1              LDR      r1,[r0,#0xc]          ;1380
00090c  f4415180          ORR      r1,r1,#0x1000         ;1380
000910  60c1              STR      r1,[r0,#0xc]          ;1380
                  |L1.2322|
000912  2201              MOVS     r2,#1                 ;1389
000914  4629              MOV      r1,r5                 ;1389
000916  6820              LDR      r0,[r4,#0]            ;1389
000918  f7fffffe          BL       TIM_CCxChannelCmd
00091c  6820              LDR      r0,[r4,#0]            ;1391
00091e  f1a04180          SUB      r1,r0,#0x40000000     ;1391
000922  f5b13180          SUBS     r1,r1,#0x10000        ;1391
000926  d002              BEQ      |L1.2350|
000928  f5b16180          SUBS     r1,r1,#0x400          ;1391
00092c  d103              BNE      |L1.2358|
                  |L1.2350|
00092e  6c41              LDR      r1,[r0,#0x44]         ;1394
000930  f4414100          ORR      r1,r1,#0x8000         ;1394
000934  6441              STR      r1,[r0,#0x44]         ;1394
                  |L1.2358|
000936  6820              LDR      r0,[r4,#0]            ;1398
000938  6801              LDR      r1,[r0,#0]            ;1398
00093a  f0410101          ORR      r1,r1,#1              ;1398
00093e  6001              STR      r1,[r0,#0]            ;1398
000940  2000              MOVS     r0,#0                 ;1401
000942  bd70              POP      {r4-r6,pc}
;;;1403   
                          ENDP

                  HAL_TIM_PWM_Stop_DMA PROC
;;;1415     */
;;;1416   HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000944  b510              PUSH     {r4,lr}
;;;1417   {
000946  4604              MOV      r4,r0
;;;1418     /* Check the parameters */
;;;1419     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1420     
;;;1421     switch (Channel)
000948  2900              CMP      r1,#0
;;;1422     {
;;;1423       case TIM_CHANNEL_1:
;;;1424       {       
;;;1425         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1426         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
00094a  6822              LDR      r2,[r4,#0]
00094c  d006              BEQ      |L1.2396|
00094e  2904              CMP      r1,#4                 ;1421
000950  d009              BEQ      |L1.2406|
000952  2908              CMP      r1,#8                 ;1421
000954  d00c              BEQ      |L1.2416|
000956  290c              CMP      r1,#0xc               ;1421
000958  d113              BNE      |L1.2434|
00095a  e00e              B        |L1.2426|
                  |L1.2396|
00095c  68d0              LDR      r0,[r2,#0xc]
00095e  f4207000          BIC      r0,r0,#0x200
000962  60d0              STR      r0,[r2,#0xc]
;;;1427       }
;;;1428       break;
000964  e00d              B        |L1.2434|
                  |L1.2406|
;;;1429       
;;;1430       case TIM_CHANNEL_2:
;;;1431       {
;;;1432         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1433         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000966  68d0              LDR      r0,[r2,#0xc]
000968  f4206080          BIC      r0,r0,#0x400
00096c  60d0              STR      r0,[r2,#0xc]
;;;1434       }
;;;1435       break;
00096e  e008              B        |L1.2434|
                  |L1.2416|
;;;1436       
;;;1437       case TIM_CHANNEL_3:
;;;1438       {
;;;1439         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1440         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
000970  68d0              LDR      r0,[r2,#0xc]
000972  f4206000          BIC      r0,r0,#0x800
000976  60d0              STR      r0,[r2,#0xc]
;;;1441       }
;;;1442       break;
000978  e003              B        |L1.2434|
                  |L1.2426|
;;;1443       
;;;1444       case TIM_CHANNEL_4:
;;;1445       {
;;;1446         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1447         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
00097a  68d0              LDR      r0,[r2,#0xc]
00097c  f4205080          BIC      r0,r0,#0x1000
000980  60d0              STR      r0,[r2,#0xc]
                  |L1.2434|
;;;1448       }
;;;1449       break;
;;;1450       
;;;1451       default:
;;;1452       break;
;;;1453     } 
;;;1454     
;;;1455     /* Disable the Capture compare channel */
;;;1456     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000982  2200              MOVS     r2,#0
000984  6820              LDR      r0,[r4,#0]
000986  f7fffffe          BL       TIM_CCxChannelCmd
;;;1457     
;;;1458     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00098a  6821              LDR      r1,[r4,#0]
;;;1459     {
;;;1460       /* Disable the Main Output */
;;;1461       __HAL_TIM_MOE_DISABLE(htim);
00098c  f2411311          MOV      r3,#0x1111
000990  109a              ASRS     r2,r3,#2
000992  f1a14080          SUB      r0,r1,#0x40000000     ;1458
000996  f5b03080          SUBS     r0,r0,#0x10000        ;1458
00099a  d002              BEQ      |L1.2466|
00099c  f5b06080          SUBS     r0,r0,#0x400          ;1458
0009a0  d109              BNE      |L1.2486|
                  |L1.2466|
0009a2  6a08              LDR      r0,[r1,#0x20]
0009a4  4218              TST      r0,r3
0009a6  d106              BNE      |L1.2486|
0009a8  6a08              LDR      r0,[r1,#0x20]
0009aa  4210              TST      r0,r2
0009ac  d103              BNE      |L1.2486|
0009ae  6c48              LDR      r0,[r1,#0x44]
0009b0  f4204000          BIC      r0,r0,#0x8000
0009b4  6448              STR      r0,[r1,#0x44]
                  |L1.2486|
;;;1462     }
;;;1463     
;;;1464     /* Disable the Peripheral */
;;;1465     __HAL_TIM_DISABLE(htim);
0009b6  6820              LDR      r0,[r4,#0]
0009b8  6a01              LDR      r1,[r0,#0x20]
0009ba  4219              TST      r1,r3
0009bc  d106              BNE      |L1.2508|
0009be  6a01              LDR      r1,[r0,#0x20]
0009c0  4211              TST      r1,r2
0009c2  d103              BNE      |L1.2508|
0009c4  6801              LDR      r1,[r0,#0]
0009c6  f0210101          BIC      r1,r1,#1
0009ca  6001              STR      r1,[r0,#0]
                  |L1.2508|
;;;1466     
;;;1467     /* Change the htim state */
;;;1468     htim->State = HAL_TIM_STATE_READY;
0009cc  2001              MOVS     r0,#1
0009ce  f8840039          STRB     r0,[r4,#0x39]
;;;1469     
;;;1470     /* Return function status */
;;;1471     return HAL_OK;
0009d2  2000              MOVS     r0,#0
;;;1472   }
0009d4  bd10              POP      {r4,pc}
;;;1473   /**
                          ENDP

                  HAL_TIM_IC_MspInit PROC
;;;1571     */
;;;1572   __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
0009d6  4770              BX       lr
;;;1573   {
;;;1574     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1575               the HAL_TIM_IC_MspInit could be implemented in the user file
;;;1576      */
;;;1577   }
;;;1578   
                          ENDP

                  HAL_TIM_IC_Init PROC
;;;1504     */
;;;1505   HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
0009d8  b510              PUSH     {r4,lr}
;;;1506   {
0009da  4604              MOV      r4,r0
;;;1507     /* Check the TIM handle allocation */
;;;1508     if(htim == NULL)
0009dc  2c00              CMP      r4,#0
0009de  d003              BEQ      |L1.2536|
;;;1509     {
;;;1510       return HAL_ERROR;
;;;1511     }
;;;1512   
;;;1513     /* Check the parameters */
;;;1514     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1515     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1516     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision)); 
;;;1517   
;;;1518     if(htim->State == HAL_TIM_STATE_RESET)
0009e0  f8940039          LDRB     r0,[r4,#0x39]
0009e4  b110              CBZ      r0,|L1.2540|
0009e6  e007              B        |L1.2552|
                  |L1.2536|
0009e8  2001              MOVS     r0,#1                 ;1510
;;;1519     { 
;;;1520       /* Allocate lock resource and initialize it */
;;;1521       htim->Lock = HAL_UNLOCKED;
;;;1522       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1523       HAL_TIM_IC_MspInit(htim);
;;;1524     }
;;;1525     
;;;1526     /* Set the TIM state */
;;;1527     htim->State= HAL_TIM_STATE_BUSY;   
;;;1528     
;;;1529     /* Init the base time for the input capture */  
;;;1530     TIM_Base_SetConfig(htim->Instance, &htim->Init); 
;;;1531      
;;;1532     /* Initialize the TIM state*/
;;;1533     htim->State= HAL_TIM_STATE_READY;
;;;1534     
;;;1535     return HAL_OK;
;;;1536   }
0009ea  bd10              POP      {r4,pc}
                  |L1.2540|
0009ec  2000              MOVS     r0,#0                 ;1521
0009ee  f8840038          STRB     r0,[r4,#0x38]         ;1521
0009f2  4620              MOV      r0,r4                 ;1523
0009f4  f7fffffe          BL       HAL_TIM_IC_MspInit
                  |L1.2552|
0009f8  2002              MOVS     r0,#2                 ;1527
0009fa  f8840039          STRB     r0,[r4,#0x39]         ;1527
0009fe  1d21              ADDS     r1,r4,#4              ;1530
000a00  6820              LDR      r0,[r4,#0]            ;1530
000a02  f7fffffe          BL       TIM_Base_SetConfig
000a06  2001              MOVS     r0,#1                 ;1533
000a08  f8840039          STRB     r0,[r4,#0x39]         ;1533
000a0c  2000              MOVS     r0,#0                 ;1535
000a0e  bd10              POP      {r4,pc}
;;;1537   
                          ENDP

                  HAL_TIM_IC_MspDeInit PROC
;;;1584     */
;;;1585   __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
000a10  4770              BX       lr
;;;1586   {
;;;1587     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1588               the HAL_TIM_IC_MspDeInit could be implemented in the user file
;;;1589      */
;;;1590   }
;;;1591   
                          ENDP

                  HAL_TIM_IC_DeInit PROC
;;;1543     */
;;;1544   HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
000a12  b510              PUSH     {r4,lr}
;;;1545   {
000a14  4604              MOV      r4,r0
;;;1546     /* Check the parameters */
;;;1547     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1548   
;;;1549     htim->State = HAL_TIM_STATE_BUSY;
000a16  2002              MOVS     r0,#2
000a18  f8840039          STRB     r0,[r4,#0x39]
;;;1550     
;;;1551     /* Disable the TIM Peripheral Clock */
;;;1552     __HAL_TIM_DISABLE(htim);
000a1c  6820              LDR      r0,[r4,#0]
000a1e  6a01              LDR      r1,[r0,#0x20]
000a20  f2411211          MOV      r2,#0x1111
000a24  4211              TST      r1,r2
000a26  d107              BNE      |L1.2616|
000a28  6a01              LDR      r1,[r0,#0x20]
000a2a  1092              ASRS     r2,r2,#2
000a2c  4211              TST      r1,r2
000a2e  d103              BNE      |L1.2616|
000a30  6801              LDR      r1,[r0,#0]
000a32  f0210101          BIC      r1,r1,#1
000a36  6001              STR      r1,[r0,#0]
                  |L1.2616|
;;;1553       
;;;1554     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1555     HAL_TIM_IC_MspDeInit(htim);
000a38  4620              MOV      r0,r4
000a3a  f7fffffe          BL       HAL_TIM_IC_MspDeInit
;;;1556       
;;;1557     /* Change TIM state */  
;;;1558     htim->State = HAL_TIM_STATE_RESET;
000a3e  2000              MOVS     r0,#0
000a40  f8840039          STRB     r0,[r4,#0x39]
;;;1559   
;;;1560     /* Release Lock */
;;;1561     __HAL_UNLOCK(htim);
000a44  f8840038          STRB     r0,[r4,#0x38]
;;;1562   
;;;1563     return HAL_OK;
;;;1564   }
000a48  bd10              POP      {r4,pc}
;;;1565   
                          ENDP

                  HAL_TIM_IC_Start PROC
;;;1603     */
;;;1604   HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
000a4a  b510              PUSH     {r4,lr}
;;;1605   {
000a4c  4604              MOV      r4,r0
;;;1606     /* Check the parameters */
;;;1607     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1608     
;;;1609     /* Enable the Input Capture channel */
;;;1610     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000a4e  2201              MOVS     r2,#1
000a50  6820              LDR      r0,[r4,#0]
000a52  f7fffffe          BL       TIM_CCxChannelCmd
;;;1611       
;;;1612     /* Enable the Peripheral */
;;;1613     __HAL_TIM_ENABLE(htim);  
000a56  6820              LDR      r0,[r4,#0]
000a58  6801              LDR      r1,[r0,#0]
000a5a  f0410101          ORR      r1,r1,#1
000a5e  6001              STR      r1,[r0,#0]
;;;1614   
;;;1615     /* Return function status */
;;;1616     return HAL_OK;  
000a60  2000              MOVS     r0,#0
;;;1617   } 
000a62  bd10              POP      {r4,pc}
;;;1618   
                          ENDP

                  HAL_TIM_IC_Stop PROC
;;;1630     */
;;;1631   HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000a64  b510              PUSH     {r4,lr}
;;;1632   { 
000a66  4604              MOV      r4,r0
;;;1633     /* Check the parameters */
;;;1634     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1635     
;;;1636     /* Disable the Input Capture channel */
;;;1637     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000a68  2200              MOVS     r2,#0
000a6a  6820              LDR      r0,[r4,#0]
000a6c  f7fffffe          BL       TIM_CCxChannelCmd
;;;1638     
;;;1639     /* Disable the Peripheral */
;;;1640     __HAL_TIM_DISABLE(htim); 
000a70  6820              LDR      r0,[r4,#0]
000a72  6a01              LDR      r1,[r0,#0x20]
000a74  f2411211          MOV      r2,#0x1111
000a78  4211              TST      r1,r2
000a7a  d107              BNE      |L1.2700|
000a7c  6a01              LDR      r1,[r0,#0x20]
000a7e  1092              ASRS     r2,r2,#2
000a80  4211              TST      r1,r2
000a82  d103              BNE      |L1.2700|
000a84  6801              LDR      r1,[r0,#0]
000a86  f0210101          BIC      r1,r1,#1
000a8a  6001              STR      r1,[r0,#0]
                  |L1.2700|
;;;1641     
;;;1642     /* Return function status */
;;;1643     return HAL_OK;
000a8c  2000              MOVS     r0,#0
;;;1644   }
000a8e  bd10              POP      {r4,pc}
;;;1645   
                          ENDP

                  HAL_TIM_IC_Start_IT PROC
;;;1657     */
;;;1658   HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000a90  b510              PUSH     {r4,lr}
;;;1659   {
000a92  4604              MOV      r4,r0
;;;1660     /* Check the parameters */
;;;1661     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1662     
;;;1663     switch (Channel)
000a94  2900              CMP      r1,#0
;;;1664     {
;;;1665       case TIM_CHANNEL_1:
;;;1666       {       
;;;1667         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1668         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000a96  6822              LDR      r2,[r4,#0]
000a98  d006              BEQ      |L1.2728|
000a9a  2904              CMP      r1,#4                 ;1663
000a9c  d009              BEQ      |L1.2738|
000a9e  2908              CMP      r1,#8                 ;1663
000aa0  d00c              BEQ      |L1.2748|
000aa2  290c              CMP      r1,#0xc               ;1663
000aa4  d113              BNE      |L1.2766|
000aa6  e00e              B        |L1.2758|
                  |L1.2728|
000aa8  68d0              LDR      r0,[r2,#0xc]
000aaa  f0400002          ORR      r0,r0,#2
000aae  60d0              STR      r0,[r2,#0xc]
;;;1669       }
;;;1670       break;
000ab0  e00d              B        |L1.2766|
                  |L1.2738|
;;;1671       
;;;1672       case TIM_CHANNEL_2:
;;;1673       {
;;;1674         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1675         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000ab2  68d0              LDR      r0,[r2,#0xc]
000ab4  f0400004          ORR      r0,r0,#4
000ab8  60d0              STR      r0,[r2,#0xc]
;;;1676       }
;;;1677       break;
000aba  e008              B        |L1.2766|
                  |L1.2748|
;;;1678       
;;;1679       case TIM_CHANNEL_3:
;;;1680       {
;;;1681         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1682         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
000abc  68d0              LDR      r0,[r2,#0xc]
000abe  f0400008          ORR      r0,r0,#8
000ac2  60d0              STR      r0,[r2,#0xc]
;;;1683       }
;;;1684       break;
000ac4  e003              B        |L1.2766|
                  |L1.2758|
;;;1685       
;;;1686       case TIM_CHANNEL_4:
;;;1687       {
;;;1688         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1689         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000ac6  68d0              LDR      r0,[r2,#0xc]
000ac8  f0400010          ORR      r0,r0,#0x10
000acc  60d0              STR      r0,[r2,#0xc]
                  |L1.2766|
;;;1690       }
;;;1691       break;
;;;1692       
;;;1693       default:
;;;1694       break;
;;;1695     }  
;;;1696     /* Enable the Input Capture channel */
;;;1697     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000ace  2201              MOVS     r2,#1
000ad0  6820              LDR      r0,[r4,#0]
000ad2  f7fffffe          BL       TIM_CCxChannelCmd
;;;1698       
;;;1699     /* Enable the Peripheral */
;;;1700     __HAL_TIM_ENABLE(htim);  
000ad6  6820              LDR      r0,[r4,#0]
000ad8  6801              LDR      r1,[r0,#0]
000ada  f0410101          ORR      r1,r1,#1
000ade  6001              STR      r1,[r0,#0]
;;;1701   
;;;1702     /* Return function status */
;;;1703     return HAL_OK;  
000ae0  2000              MOVS     r0,#0
;;;1704   } 
000ae2  bd10              POP      {r4,pc}
;;;1705   
                          ENDP

                  HAL_TIM_IC_Stop_IT PROC
;;;1717     */
;;;1718   HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000ae4  b510              PUSH     {r4,lr}
;;;1719   {
000ae6  4604              MOV      r4,r0
;;;1720     /* Check the parameters */
;;;1721     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1722     
;;;1723     switch (Channel)
000ae8  2900              CMP      r1,#0
;;;1724     {
;;;1725       case TIM_CHANNEL_1:
;;;1726       {       
;;;1727         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1728         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000aea  6822              LDR      r2,[r4,#0]
000aec  d006              BEQ      |L1.2812|
000aee  2904              CMP      r1,#4                 ;1723
000af0  d009              BEQ      |L1.2822|
000af2  2908              CMP      r1,#8                 ;1723
000af4  d00c              BEQ      |L1.2832|
000af6  290c              CMP      r1,#0xc               ;1723
000af8  d113              BNE      |L1.2850|
000afa  e00e              B        |L1.2842|
                  |L1.2812|
000afc  68d0              LDR      r0,[r2,#0xc]
000afe  f0200002          BIC      r0,r0,#2
000b02  60d0              STR      r0,[r2,#0xc]
;;;1729       }
;;;1730       break;
000b04  e00d              B        |L1.2850|
                  |L1.2822|
;;;1731       
;;;1732       case TIM_CHANNEL_2:
;;;1733       {
;;;1734         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1735         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000b06  68d0              LDR      r0,[r2,#0xc]
000b08  f0200004          BIC      r0,r0,#4
000b0c  60d0              STR      r0,[r2,#0xc]
;;;1736       }
;;;1737       break;
000b0e  e008              B        |L1.2850|
                  |L1.2832|
;;;1738       
;;;1739       case TIM_CHANNEL_3:
;;;1740       {
;;;1741         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1742         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
000b10  68d0              LDR      r0,[r2,#0xc]
000b12  f0200008          BIC      r0,r0,#8
000b16  60d0              STR      r0,[r2,#0xc]
;;;1743       }
;;;1744       break;
000b18  e003              B        |L1.2850|
                  |L1.2842|
;;;1745       
;;;1746       case TIM_CHANNEL_4:
;;;1747       {
;;;1748         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1749         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000b1a  68d0              LDR      r0,[r2,#0xc]
000b1c  f0200010          BIC      r0,r0,#0x10
000b20  60d0              STR      r0,[r2,#0xc]
                  |L1.2850|
;;;1750       }
;;;1751       break;
;;;1752       
;;;1753       default:
;;;1754       break; 
;;;1755     } 
;;;1756     
;;;1757     /* Disable the Input Capture channel */
;;;1758     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
000b22  2200              MOVS     r2,#0
000b24  6820              LDR      r0,[r4,#0]
000b26  f7fffffe          BL       TIM_CCxChannelCmd
;;;1759     
;;;1760     /* Disable the Peripheral */
;;;1761     __HAL_TIM_DISABLE(htim); 
000b2a  6820              LDR      r0,[r4,#0]
000b2c  6a01              LDR      r1,[r0,#0x20]
000b2e  f2411211          MOV      r2,#0x1111
000b32  4211              TST      r1,r2
000b34  d107              BNE      |L1.2886|
000b36  6a01              LDR      r1,[r0,#0x20]
000b38  1092              ASRS     r2,r2,#2
000b3a  4211              TST      r1,r2
000b3c  d103              BNE      |L1.2886|
000b3e  6801              LDR      r1,[r0,#0]
000b40  f0210101          BIC      r1,r1,#1
000b44  6001              STR      r1,[r0,#0]
                  |L1.2886|
;;;1762     
;;;1763     /* Return function status */
;;;1764     return HAL_OK;
000b46  2000              MOVS     r0,#0
;;;1765   }
000b48  bd10              POP      {r4,pc}
;;;1766   
                          ENDP

                  HAL_TIM_IC_CaptureCallback PROC
;;;4277     */
;;;4278   __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
000b4a  4770              BX       lr
;;;4279   {
;;;4280     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4281               the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
;;;4282      */
;;;4283   }
;;;4284   
                          ENDP

                  TIM_DMACaptureCplt PROC
;;;4635     */
;;;4636   void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
000b4c  b510              PUSH     {r4,lr}
;;;4637   {
;;;4638     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000b4e  6b84              LDR      r4,[r0,#0x38]
;;;4639     
;;;4640     htim->State= HAL_TIM_STATE_READY;
000b50  2101              MOVS     r1,#1
000b52  f8841039          STRB     r1,[r4,#0x39]
;;;4641     
;;;4642     if(hdma == htim->hdma[TIM_DMA_ID_CC1])
000b56  6a22              LDR      r2,[r4,#0x20]
000b58  4282              CMP      r2,r0
000b5a  d101              BNE      |L1.2912|
;;;4643     {
;;;4644       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000b5c  7621              STRB     r1,[r4,#0x18]
000b5e  e010              B        |L1.2946|
                  |L1.2912|
;;;4645     }
;;;4646     else if(hdma == htim->hdma[TIM_DMA_ID_CC2])
000b60  6a61              LDR      r1,[r4,#0x24]
000b62  4281              CMP      r1,r0
000b64  d102              BNE      |L1.2924|
;;;4647     {
;;;4648       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000b66  2002              MOVS     r0,#2
000b68  7620              STRB     r0,[r4,#0x18]
000b6a  e00a              B        |L1.2946|
                  |L1.2924|
;;;4649     }
;;;4650     else if(hdma == htim->hdma[TIM_DMA_ID_CC3])
000b6c  6aa1              LDR      r1,[r4,#0x28]
000b6e  4281              CMP      r1,r0
000b70  d102              BNE      |L1.2936|
;;;4651     {
;;;4652       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000b72  2004              MOVS     r0,#4
000b74  7620              STRB     r0,[r4,#0x18]
000b76  e004              B        |L1.2946|
                  |L1.2936|
;;;4653     }
;;;4654     else if(hdma == htim->hdma[TIM_DMA_ID_CC4])
000b78  6ae1              LDR      r1,[r4,#0x2c]
000b7a  4281              CMP      r1,r0
000b7c  d101              BNE      |L1.2946|
;;;4655     {
;;;4656       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
000b7e  2008              MOVS     r0,#8
000b80  7620              STRB     r0,[r4,#0x18]
                  |L1.2946|
;;;4657     }
;;;4658     
;;;4659     HAL_TIM_IC_CaptureCallback(htim); 
000b82  4620              MOV      r0,r4
000b84  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
;;;4660     
;;;4661     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000b88  2000              MOVS     r0,#0
000b8a  7620              STRB     r0,[r4,#0x18]
;;;4662   }
000b8c  bd10              POP      {r4,pc}
;;;4663   
                          ENDP

                  HAL_TIM_IC_Start_DMA PROC
;;;1780     */
;;;1781   HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000b8e  b570              PUSH     {r4-r6,lr}
;;;1782   {
000b90  4604              MOV      r4,r0
000b92  460d              MOV      r5,r1
;;;1783     /* Check the parameters */
;;;1784     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1785     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1786     
;;;1787     if((htim->State == HAL_TIM_STATE_BUSY))
000b94  f8940039          LDRB     r0,[r4,#0x39]
000b98  2802              CMP      r0,#2
000b9a  d004              BEQ      |L1.2982|
;;;1788     {
;;;1789        return HAL_BUSY;
;;;1790     }
;;;1791     else if((htim->State == HAL_TIM_STATE_READY))
000b9c  f8940039          LDRB     r0,[r4,#0x39]
000ba0  2801              CMP      r0,#1
000ba2  d002              BEQ      |L1.2986|
000ba4  e008              B        |L1.3000|
                  |L1.2982|
000ba6  2002              MOVS     r0,#2                 ;1789
;;;1792     {
;;;1793       if((pData == 0 ) && (Length > 0)) 
;;;1794       {
;;;1795         return HAL_ERROR;                                    
;;;1796       }
;;;1797       else
;;;1798       {
;;;1799         htim->State = HAL_TIM_STATE_BUSY;
;;;1800       }
;;;1801     }  
;;;1802      
;;;1803     switch (Channel)
;;;1804     {
;;;1805       case TIM_CHANNEL_1:
;;;1806       {
;;;1807         /* Set the DMA Period elapsed callback */
;;;1808         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1809        
;;;1810         /* Set the DMA error callback */
;;;1811         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1812         
;;;1813         /* Enable the DMA Stream */
;;;1814         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length); 
;;;1815         
;;;1816         /* Enable the TIM Capture/Compare 1 DMA request */      
;;;1817         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1818       }
;;;1819       break;
;;;1820       
;;;1821       case TIM_CHANNEL_2:
;;;1822       {
;;;1823         /* Set the DMA Period elapsed callback */
;;;1824         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1825        
;;;1826         /* Set the DMA error callback */
;;;1827         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1828         
;;;1829         /* Enable the DMA Stream */
;;;1830         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
;;;1831         
;;;1832         /* Enable the TIM Capture/Compare 2  DMA request */
;;;1833         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1834       }
;;;1835       break;
;;;1836       
;;;1837       case TIM_CHANNEL_3:
;;;1838       {
;;;1839         /* Set the DMA Period elapsed callback */
;;;1840         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1841        
;;;1842         /* Set the DMA error callback */
;;;1843         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1844         
;;;1845         /* Enable the DMA Stream */
;;;1846         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
;;;1847         
;;;1848         /* Enable the TIM Capture/Compare 3  DMA request */
;;;1849         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1850       }
;;;1851       break;
;;;1852       
;;;1853       case TIM_CHANNEL_4:
;;;1854       {
;;;1855         /* Set the DMA Period elapsed callback */
;;;1856         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1857        
;;;1858         /* Set the DMA error callback */
;;;1859         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1860         
;;;1861         /* Enable the DMA Stream */
;;;1862         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
;;;1863         
;;;1864         /* Enable the TIM Capture/Compare 4  DMA request */
;;;1865         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1866       }
;;;1867       break;
;;;1868       
;;;1869       default:
;;;1870       break;
;;;1871     }
;;;1872   
;;;1873     /* Enable the Input Capture channel */
;;;1874     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1875      
;;;1876     /* Enable the Peripheral */
;;;1877     __HAL_TIM_ENABLE(htim); 
;;;1878     
;;;1879     /* Return function status */
;;;1880     return HAL_OK;
;;;1881   }
000ba8  bd70              POP      {r4-r6,pc}
                  |L1.2986|
000baa  b912              CBNZ     r2,|L1.2994|
000bac  b10b              CBZ      r3,|L1.2994|
000bae  2001              MOVS     r0,#1                 ;1795
000bb0  bd70              POP      {r4-r6,pc}
                  |L1.2994|
000bb2  2002              MOVS     r0,#2                 ;1799
000bb4  f8840039          STRB     r0,[r4,#0x39]         ;1799
                  |L1.3000|
000bb8  f2af006f          ADR      r0,TIM_DMACaptureCplt + 1
000bbc  f6af2c23          ADR      r12,TIM_DMAError + 1
000bc0  b135              CBZ      r5,|L1.3024|
000bc2  2d04              CMP      r5,#4                 ;1803
000bc4  d015              BEQ      |L1.3058|
000bc6  2d08              CMP      r5,#8                 ;1803
000bc8  d024              BEQ      |L1.3092|
000bca  2d0c              CMP      r5,#0xc               ;1803
000bcc  d143              BNE      |L1.3158|
000bce  e032              B        |L1.3126|
                  |L1.3024|
000bd0  6a21              LDR      r1,[r4,#0x20]         ;1808
000bd2  63c8              STR      r0,[r1,#0x3c]         ;1808
000bd4  6a20              LDR      r0,[r4,#0x20]         ;1811
000bd6  f8c0c048          STR      r12,[r0,#0x48]        ;1811
000bda  6820              LDR      r0,[r4,#0]            ;1814
000bdc  f1000134          ADD      r1,r0,#0x34           ;1814
000be0  6a20              LDR      r0,[r4,#0x20]         ;1814
000be2  f7fffffe          BL       HAL_DMA_Start_IT
000be6  6820              LDR      r0,[r4,#0]            ;1817
000be8  68c1              LDR      r1,[r0,#0xc]          ;1817
000bea  f4417100          ORR      r1,r1,#0x200          ;1817
000bee  60c1              STR      r1,[r0,#0xc]          ;1817
000bf0  e031              B        |L1.3158|
                  |L1.3058|
000bf2  6a61              LDR      r1,[r4,#0x24]         ;1824
000bf4  63c8              STR      r0,[r1,#0x3c]         ;1824
000bf6  6a60              LDR      r0,[r4,#0x24]         ;1827
000bf8  f8c0c048          STR      r12,[r0,#0x48]        ;1827
000bfc  6820              LDR      r0,[r4,#0]            ;1830
000bfe  f1000138          ADD      r1,r0,#0x38           ;1830
000c02  6a60              LDR      r0,[r4,#0x24]         ;1830
000c04  f7fffffe          BL       HAL_DMA_Start_IT
000c08  6820              LDR      r0,[r4,#0]            ;1833
000c0a  68c1              LDR      r1,[r0,#0xc]          ;1833
000c0c  f4416180          ORR      r1,r1,#0x400          ;1833
000c10  60c1              STR      r1,[r0,#0xc]          ;1833
000c12  e020              B        |L1.3158|
                  |L1.3092|
000c14  6aa1              LDR      r1,[r4,#0x28]         ;1840
000c16  63c8              STR      r0,[r1,#0x3c]         ;1840
000c18  6aa0              LDR      r0,[r4,#0x28]         ;1843
000c1a  f8c0c048          STR      r12,[r0,#0x48]        ;1843
000c1e  6820              LDR      r0,[r4,#0]            ;1846
000c20  f100013c          ADD      r1,r0,#0x3c           ;1846
000c24  6aa0              LDR      r0,[r4,#0x28]         ;1846
000c26  f7fffffe          BL       HAL_DMA_Start_IT
000c2a  6820              LDR      r0,[r4,#0]            ;1849
000c2c  68c1              LDR      r1,[r0,#0xc]          ;1849
000c2e  f4416100          ORR      r1,r1,#0x800          ;1849
000c32  60c1              STR      r1,[r0,#0xc]          ;1849
000c34  e00f              B        |L1.3158|
                  |L1.3126|
000c36  6ae1              LDR      r1,[r4,#0x2c]         ;1856
000c38  63c8              STR      r0,[r1,#0x3c]         ;1856
000c3a  6ae0              LDR      r0,[r4,#0x2c]         ;1859
000c3c  f8c0c048          STR      r12,[r0,#0x48]        ;1859
000c40  6820              LDR      r0,[r4,#0]            ;1862
000c42  f1000140          ADD      r1,r0,#0x40           ;1862
000c46  6ae0              LDR      r0,[r4,#0x2c]         ;1862
000c48  f7fffffe          BL       HAL_DMA_Start_IT
000c4c  6820              LDR      r0,[r4,#0]            ;1865
000c4e  68c1              LDR      r1,[r0,#0xc]          ;1865
000c50  f4415180          ORR      r1,r1,#0x1000         ;1865
000c54  60c1              STR      r1,[r0,#0xc]          ;1865
                  |L1.3158|
000c56  2201              MOVS     r2,#1                 ;1874
000c58  4629              MOV      r1,r5                 ;1874
000c5a  6820              LDR      r0,[r4,#0]            ;1874
000c5c  f7fffffe          BL       TIM_CCxChannelCmd
000c60  6820              LDR      r0,[r4,#0]            ;1877
000c62  6801              LDR      r1,[r0,#0]            ;1877
000c64  f0410101          ORR      r1,r1,#1              ;1877
000c68  6001              STR      r1,[r0,#0]            ;1877
000c6a  2000              MOVS     r0,#0                 ;1880
000c6c  bd70              POP      {r4-r6,pc}
;;;1882   
                          ENDP

                  HAL_TIM_IC_Stop_DMA PROC
;;;1894     */
;;;1895   HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000c6e  b510              PUSH     {r4,lr}
;;;1896   {
000c70  4604              MOV      r4,r0
;;;1897     /* Check the parameters */
;;;1898     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1899     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1900     
;;;1901     switch (Channel)
000c72  2900              CMP      r1,#0
;;;1902     {
;;;1903       case TIM_CHANNEL_1:
;;;1904       {       
;;;1905         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1906         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000c74  6822              LDR      r2,[r4,#0]
000c76  d006              BEQ      |L1.3206|
000c78  2904              CMP      r1,#4                 ;1901
000c7a  d009              BEQ      |L1.3216|
000c7c  2908              CMP      r1,#8                 ;1901
000c7e  d00c              BEQ      |L1.3226|
000c80  290c              CMP      r1,#0xc               ;1901
000c82  d113              BNE      |L1.3244|
000c84  e00e              B        |L1.3236|
                  |L1.3206|
000c86  68d0              LDR      r0,[r2,#0xc]
000c88  f4207000          BIC      r0,r0,#0x200
000c8c  60d0              STR      r0,[r2,#0xc]
;;;1907       }
;;;1908       break;
000c8e  e00d              B        |L1.3244|
                  |L1.3216|
;;;1909       
;;;1910       case TIM_CHANNEL_2:
;;;1911       {
;;;1912         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1913         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000c90  68d0              LDR      r0,[r2,#0xc]
000c92  f4206080          BIC      r0,r0,#0x400
000c96  60d0              STR      r0,[r2,#0xc]
;;;1914       }
;;;1915       break;
000c98  e008              B        |L1.3244|
                  |L1.3226|
;;;1916       
;;;1917       case TIM_CHANNEL_3:
;;;1918       {
;;;1919         /* Disable the TIM Capture/Compare 3  DMA request */
;;;1920         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
000c9a  68d0              LDR      r0,[r2,#0xc]
000c9c  f4206000          BIC      r0,r0,#0x800
000ca0  60d0              STR      r0,[r2,#0xc]
;;;1921       }
;;;1922       break;
000ca2  e003              B        |L1.3244|
                  |L1.3236|
;;;1923       
;;;1924       case TIM_CHANNEL_4:
;;;1925       {
;;;1926         /* Disable the TIM Capture/Compare 4  DMA request */
;;;1927         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
000ca4  68d0              LDR      r0,[r2,#0xc]
000ca6  f4205080          BIC      r0,r0,#0x1000
000caa  60d0              STR      r0,[r2,#0xc]
                  |L1.3244|
;;;1928       }
;;;1929       break;
;;;1930       
;;;1931       default:
;;;1932       break;
;;;1933     }
;;;1934   
;;;1935     /* Disable the Input Capture channel */
;;;1936     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000cac  2200              MOVS     r2,#0
000cae  6820              LDR      r0,[r4,#0]
000cb0  f7fffffe          BL       TIM_CCxChannelCmd
;;;1937     
;;;1938     /* Disable the Peripheral */
;;;1939     __HAL_TIM_DISABLE(htim); 
000cb4  6820              LDR      r0,[r4,#0]
000cb6  6a01              LDR      r1,[r0,#0x20]
000cb8  f2411211          MOV      r2,#0x1111
000cbc  4211              TST      r1,r2
000cbe  d107              BNE      |L1.3280|
000cc0  6a01              LDR      r1,[r0,#0x20]
000cc2  1092              ASRS     r2,r2,#2
000cc4  4211              TST      r1,r2
000cc6  d103              BNE      |L1.3280|
000cc8  6801              LDR      r1,[r0,#0]
000cca  f0210101          BIC      r1,r1,#1
000cce  6001              STR      r1,[r0,#0]
                  |L1.3280|
;;;1940     
;;;1941     /* Change the htim state */
;;;1942     htim->State = HAL_TIM_STATE_READY;
000cd0  2001              MOVS     r0,#1
000cd2  f8840039          STRB     r0,[r4,#0x39]
;;;1943     
;;;1944     /* Return function status */
;;;1945     return HAL_OK;
000cd6  2000              MOVS     r0,#0
;;;1946   }  
000cd8  bd10              POP      {r4,pc}
;;;1947   /**
                          ENDP

                  HAL_TIM_OnePulse_MspInit PROC
;;;2056     */
;;;2057   __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
000cda  4770              BX       lr
;;;2058   {
;;;2059     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2060               the HAL_TIM_OnePulse_MspInit could be implemented in the user file
;;;2061      */
;;;2062   }
;;;2063   
                          ENDP

                  HAL_TIM_OnePulse_Init PROC
;;;1982     */
;;;1983   HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
000cdc  b570              PUSH     {r4-r6,lr}
;;;1984   {
000cde  4604              MOV      r4,r0
000ce0  460d              MOV      r5,r1
;;;1985     /* Check the TIM handle allocation */
;;;1986     if(htim == NULL)
000ce2  2c00              CMP      r4,#0
000ce4  d003              BEQ      |L1.3310|
;;;1987     {
;;;1988       return HAL_ERROR;
;;;1989     }
;;;1990   
;;;1991     /* Check the parameters */
;;;1992     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1993     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1994     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1995     assert_param(IS_TIM_OPM_MODE(OnePulseMode));
;;;1996     
;;;1997     if(htim->State == HAL_TIM_STATE_RESET)
000ce6  f8940039          LDRB     r0,[r4,#0x39]
000cea  b110              CBZ      r0,|L1.3314|
000cec  e007              B        |L1.3326|
                  |L1.3310|
000cee  2001              MOVS     r0,#1                 ;1988
;;;1998     { 
;;;1999       /* Allocate lock resource and initialize it */
;;;2000       htim->Lock = HAL_UNLOCKED;
;;;2001       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2002       HAL_TIM_OnePulse_MspInit(htim);
;;;2003     }
;;;2004     
;;;2005     /* Set the TIM state */
;;;2006     htim->State= HAL_TIM_STATE_BUSY;  
;;;2007     
;;;2008     /* Configure the Time base in the One Pulse Mode */
;;;2009     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;2010     
;;;2011     /* Reset the OPM Bit */
;;;2012     htim->Instance->CR1 &= ~TIM_CR1_OPM;
;;;2013   
;;;2014     /* Configure the OPM Mode */
;;;2015     htim->Instance->CR1 |= OnePulseMode;
;;;2016      
;;;2017     /* Initialize the TIM state*/
;;;2018     htim->State= HAL_TIM_STATE_READY;
;;;2019     
;;;2020     return HAL_OK;
;;;2021   }
000cf0  bd70              POP      {r4-r6,pc}
                  |L1.3314|
000cf2  2000              MOVS     r0,#0                 ;2000
000cf4  f8840038          STRB     r0,[r4,#0x38]         ;2000
000cf8  4620              MOV      r0,r4                 ;2002
000cfa  f7fffffe          BL       HAL_TIM_OnePulse_MspInit
                  |L1.3326|
000cfe  2002              MOVS     r0,#2                 ;2006
000d00  f8840039          STRB     r0,[r4,#0x39]         ;2006
000d04  1d21              ADDS     r1,r4,#4              ;2009
000d06  6820              LDR      r0,[r4,#0]            ;2009
000d08  f7fffffe          BL       TIM_Base_SetConfig
000d0c  6820              LDR      r0,[r4,#0]            ;2012
000d0e  6801              LDR      r1,[r0,#0]            ;2012
000d10  f0210108          BIC      r1,r1,#8              ;2012
000d14  6001              STR      r1,[r0,#0]            ;2012
000d16  6820              LDR      r0,[r4,#0]            ;2015
000d18  6801              LDR      r1,[r0,#0]            ;2015
000d1a  4329              ORRS     r1,r1,r5              ;2015
000d1c  6001              STR      r1,[r0,#0]            ;2015
000d1e  2001              MOVS     r0,#1                 ;2018
000d20  f8840039          STRB     r0,[r4,#0x39]         ;2018
000d24  2000              MOVS     r0,#0                 ;2020
000d26  bd70              POP      {r4-r6,pc}
;;;2022   
                          ENDP

                  HAL_TIM_OnePulse_MspDeInit PROC
;;;2069     */
;;;2070   __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
000d28  4770              BX       lr
;;;2071   {
;;;2072     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2073               the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
;;;2074      */
;;;2075   }
;;;2076   
                          ENDP

                  HAL_TIM_OnePulse_DeInit PROC
;;;2028     */
;;;2029   HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
000d2a  b510              PUSH     {r4,lr}
;;;2030   {
000d2c  4604              MOV      r4,r0
;;;2031     /* Check the parameters */
;;;2032     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2033     
;;;2034     htim->State = HAL_TIM_STATE_BUSY;
000d2e  2002              MOVS     r0,#2
000d30  f8840039          STRB     r0,[r4,#0x39]
;;;2035     
;;;2036     /* Disable the TIM Peripheral Clock */
;;;2037     __HAL_TIM_DISABLE(htim);
000d34  6820              LDR      r0,[r4,#0]
000d36  6a01              LDR      r1,[r0,#0x20]
000d38  f2411211          MOV      r2,#0x1111
000d3c  4211              TST      r1,r2
000d3e  d107              BNE      |L1.3408|
000d40  6a01              LDR      r1,[r0,#0x20]
000d42  1092              ASRS     r2,r2,#2
000d44  4211              TST      r1,r2
000d46  d103              BNE      |L1.3408|
000d48  6801              LDR      r1,[r0,#0]
000d4a  f0210101          BIC      r1,r1,#1
000d4e  6001              STR      r1,[r0,#0]
                  |L1.3408|
;;;2038     
;;;2039     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2040     HAL_TIM_OnePulse_MspDeInit(htim);
000d50  4620              MOV      r0,r4
000d52  f7fffffe          BL       HAL_TIM_OnePulse_MspDeInit
;;;2041       
;;;2042     /* Change TIM state */  
;;;2043     htim->State = HAL_TIM_STATE_RESET;
000d56  2000              MOVS     r0,#0
000d58  f8840039          STRB     r0,[r4,#0x39]
;;;2044   
;;;2045     /* Release Lock */
;;;2046     __HAL_UNLOCK(htim);
000d5c  f8840038          STRB     r0,[r4,#0x38]
;;;2047   
;;;2048     return HAL_OK;
;;;2049   }
000d60  bd10              POP      {r4,pc}
;;;2050   
                          ENDP

                  HAL_TIM_OnePulse_Start PROC
;;;2086     */
;;;2087   HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000d62  b510              PUSH     {r4,lr}
;;;2088   {
000d64  4604              MOV      r4,r0
;;;2089     /* Enable the Capture compare and the Input Capture channels 
;;;2090       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2091       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2092       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2093       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2094       
;;;2095       No need to enable the counter, it's enabled automatically by hardware 
;;;2096       (the counter starts in response to a stimulus and generate a pulse */
;;;2097     
;;;2098     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
000d66  2201              MOVS     r2,#1
000d68  2100              MOVS     r1,#0
000d6a  6820              LDR      r0,[r4,#0]
000d6c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2099     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
000d70  2201              MOVS     r2,#1
000d72  2104              MOVS     r1,#4
000d74  6820              LDR      r0,[r4,#0]
000d76  f7fffffe          BL       TIM_CCxChannelCmd
;;;2100     
;;;2101     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000d7a  6820              LDR      r0,[r4,#0]
000d7c  f1a04180          SUB      r1,r0,#0x40000000
000d80  f5b13180          SUBS     r1,r1,#0x10000
000d84  d002              BEQ      |L1.3468|
000d86  f5b16180          SUBS     r1,r1,#0x400
000d8a  d103              BNE      |L1.3476|
                  |L1.3468|
;;;2102     {
;;;2103       /* Enable the main output */
;;;2104       __HAL_TIM_MOE_ENABLE(htim);
000d8c  6c41              LDR      r1,[r0,#0x44]
000d8e  f4414100          ORR      r1,r1,#0x8000
000d92  6441              STR      r1,[r0,#0x44]
                  |L1.3476|
;;;2105     }
;;;2106     
;;;2107     /* Return function status */
;;;2108     return HAL_OK;
000d94  2000              MOVS     r0,#0
;;;2109   }
000d96  bd10              POP      {r4,pc}
;;;2110   
                          ENDP

                  HAL_TIM_OnePulse_Stop PROC
;;;2120     */
;;;2121   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000d98  b510              PUSH     {r4,lr}
;;;2122   {
000d9a  4604              MOV      r4,r0
;;;2123     /* Disable the Capture compare and the Input Capture channels 
;;;2124     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2125     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2126     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2127     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2128     
;;;2129     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000d9c  2200              MOVS     r2,#0
000d9e  4611              MOV      r1,r2
000da0  6820              LDR      r0,[r4,#0]
000da2  f7fffffe          BL       TIM_CCxChannelCmd
;;;2130     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000da6  2200              MOVS     r2,#0
000da8  2104              MOVS     r1,#4
000daa  6820              LDR      r0,[r4,#0]
000dac  f7fffffe          BL       TIM_CCxChannelCmd
;;;2131       
;;;2132     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000db0  6821              LDR      r1,[r4,#0]
;;;2133     {
;;;2134       /* Disable the Main Output */
;;;2135       __HAL_TIM_MOE_DISABLE(htim);
000db2  f2411311          MOV      r3,#0x1111
000db6  109a              ASRS     r2,r3,#2
000db8  f1a14080          SUB      r0,r1,#0x40000000     ;2132
000dbc  f5b03080          SUBS     r0,r0,#0x10000        ;2132
000dc0  d002              BEQ      |L1.3528|
000dc2  f5b06080          SUBS     r0,r0,#0x400          ;2132
000dc6  d109              BNE      |L1.3548|
                  |L1.3528|
000dc8  6a08              LDR      r0,[r1,#0x20]
000dca  4218              TST      r0,r3
000dcc  d106              BNE      |L1.3548|
000dce  6a08              LDR      r0,[r1,#0x20]
000dd0  4210              TST      r0,r2
000dd2  d103              BNE      |L1.3548|
000dd4  6c48              LDR      r0,[r1,#0x44]
000dd6  f4204000          BIC      r0,r0,#0x8000
000dda  6448              STR      r0,[r1,#0x44]
                  |L1.3548|
;;;2136     }
;;;2137       
;;;2138     /* Disable the Peripheral */
;;;2139     __HAL_TIM_DISABLE(htim); 
000ddc  6820              LDR      r0,[r4,#0]
000dde  6a01              LDR      r1,[r0,#0x20]
000de0  4219              TST      r1,r3
000de2  d106              BNE      |L1.3570|
000de4  6a01              LDR      r1,[r0,#0x20]
000de6  4211              TST      r1,r2
000de8  d103              BNE      |L1.3570|
000dea  6801              LDR      r1,[r0,#0]
000dec  f0210101          BIC      r1,r1,#1
000df0  6001              STR      r1,[r0,#0]
                  |L1.3570|
;;;2140     
;;;2141     /* Return function status */
;;;2142     return HAL_OK;
000df2  2000              MOVS     r0,#0
;;;2143   }
000df4  bd10              POP      {r4,pc}
;;;2144   
                          ENDP

                  HAL_TIM_OnePulse_Start_IT PROC
;;;2154     */
;;;2155   HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000df6  b510              PUSH     {r4,lr}
;;;2156   {
000df8  4604              MOV      r4,r0
;;;2157     /* Enable the Capture compare and the Input Capture channels 
;;;2158       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2159       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2160       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2161       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2162       
;;;2163       No need to enable the counter, it's enabled automatically by hardware 
;;;2164       (the counter starts in response to a stimulus and generate a pulse */
;;;2165    
;;;2166     /* Enable the TIM Capture/Compare 1 interrupt */
;;;2167     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000dfa  6820              LDR      r0,[r4,#0]
000dfc  68c1              LDR      r1,[r0,#0xc]
000dfe  f0410102          ORR      r1,r1,#2
000e02  60c1              STR      r1,[r0,#0xc]
;;;2168     
;;;2169     /* Enable the TIM Capture/Compare 2 interrupt */
;;;2170     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000e04  6820              LDR      r0,[r4,#0]
000e06  68c1              LDR      r1,[r0,#0xc]
000e08  f0410104          ORR      r1,r1,#4
000e0c  60c1              STR      r1,[r0,#0xc]
;;;2171     
;;;2172     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
000e0e  2201              MOVS     r2,#1
000e10  2100              MOVS     r1,#0
000e12  6820              LDR      r0,[r4,#0]
000e14  f7fffffe          BL       TIM_CCxChannelCmd
;;;2173     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
000e18  2201              MOVS     r2,#1
000e1a  2104              MOVS     r1,#4
000e1c  6820              LDR      r0,[r4,#0]
000e1e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2174     
;;;2175     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000e22  6820              LDR      r0,[r4,#0]
000e24  f1a04180          SUB      r1,r0,#0x40000000
000e28  f5b13180          SUBS     r1,r1,#0x10000
000e2c  d002              BEQ      |L1.3636|
000e2e  f5b16180          SUBS     r1,r1,#0x400
000e32  d103              BNE      |L1.3644|
                  |L1.3636|
;;;2176     {
;;;2177       /* Enable the main output */
;;;2178       __HAL_TIM_MOE_ENABLE(htim);
000e34  6c41              LDR      r1,[r0,#0x44]
000e36  f4414100          ORR      r1,r1,#0x8000
000e3a  6441              STR      r1,[r0,#0x44]
                  |L1.3644|
;;;2179     }
;;;2180     
;;;2181     /* Return function status */
;;;2182     return HAL_OK;
000e3c  2000              MOVS     r0,#0
;;;2183   }
000e3e  bd10              POP      {r4,pc}
;;;2184   
                          ENDP

                  HAL_TIM_OnePulse_Stop_IT PROC
;;;2194     */
;;;2195   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000e40  b510              PUSH     {r4,lr}
;;;2196   {
000e42  4604              MOV      r4,r0
;;;2197     /* Disable the TIM Capture/Compare 1 interrupt */
;;;2198     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);  
000e44  6820              LDR      r0,[r4,#0]
000e46  68c1              LDR      r1,[r0,#0xc]
000e48  f0210102          BIC      r1,r1,#2
000e4c  60c1              STR      r1,[r0,#0xc]
;;;2199     
;;;2200     /* Disable the TIM Capture/Compare 2 interrupt */
;;;2201     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000e4e  6820              LDR      r0,[r4,#0]
000e50  68c1              LDR      r1,[r0,#0xc]
000e52  f0210104          BIC      r1,r1,#4
000e56  60c1              STR      r1,[r0,#0xc]
;;;2202     
;;;2203     /* Disable the Capture compare and the Input Capture channels 
;;;2204     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2205     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2206     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2207     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */  
;;;2208     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000e58  2200              MOVS     r2,#0
000e5a  4611              MOV      r1,r2
000e5c  6820              LDR      r0,[r4,#0]
000e5e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2209     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000e62  2200              MOVS     r2,#0
000e64  2104              MOVS     r1,#4
000e66  6820              LDR      r0,[r4,#0]
000e68  f7fffffe          BL       TIM_CCxChannelCmd
;;;2210       
;;;2211     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000e6c  6820              LDR      r0,[r4,#0]
;;;2212     {
;;;2213       /* Disable the Main Output */
;;;2214       __HAL_TIM_MOE_DISABLE(htim);
000e6e  f2411111          MOV      r1,#0x1111
000e72  108a              ASRS     r2,r1,#2
000e74  f1a04380          SUB      r3,r0,#0x40000000     ;2211
000e78  f5b33380          SUBS     r3,r3,#0x10000        ;2211
000e7c  d002              BEQ      |L1.3716|
000e7e  f5b36380          SUBS     r3,r3,#0x400          ;2211
000e82  d109              BNE      |L1.3736|
                  |L1.3716|
000e84  6a03              LDR      r3,[r0,#0x20]
000e86  420b              TST      r3,r1
000e88  d106              BNE      |L1.3736|
000e8a  6a03              LDR      r3,[r0,#0x20]
000e8c  4213              TST      r3,r2
000e8e  d103              BNE      |L1.3736|
000e90  6c43              LDR      r3,[r0,#0x44]
000e92  f4234300          BIC      r3,r3,#0x8000
000e96  6443              STR      r3,[r0,#0x44]
                  |L1.3736|
;;;2215     }
;;;2216       
;;;2217     /* Disable the Peripheral */
;;;2218      __HAL_TIM_DISABLE(htim);  
000e98  6820              LDR      r0,[r4,#0]
000e9a  6a03              LDR      r3,[r0,#0x20]
000e9c  420b              TST      r3,r1
000e9e  d106              BNE      |L1.3758|
000ea0  6a01              LDR      r1,[r0,#0x20]
000ea2  4211              TST      r1,r2
000ea4  d103              BNE      |L1.3758|
000ea6  6801              LDR      r1,[r0,#0]
000ea8  f0210101          BIC      r1,r1,#1
000eac  6001              STR      r1,[r0,#0]
                  |L1.3758|
;;;2219     
;;;2220     /* Return function status */
;;;2221     return HAL_OK;
000eae  2000              MOVS     r0,#0
;;;2222   }
000eb0  bd10              POP      {r4,pc}
;;;2223   /**
                          ENDP

                  HAL_TIM_Encoder_MspInit PROC
;;;2371     */
;;;2372   __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
000eb2  4770              BX       lr
;;;2373   {
;;;2374     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2375               the HAL_TIM_Encoder_MspInit could be implemented in the user file
;;;2376      */
;;;2377   }
;;;2378   
                          ENDP

                  HAL_TIM_Encoder_Init PROC
;;;2254     */
;;;2255   HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
000eb4  b570              PUSH     {r4-r6,lr}
;;;2256   {
000eb6  4604              MOV      r4,r0
000eb8  460d              MOV      r5,r1
;;;2257     uint32_t tmpsmcr = 0;
;;;2258     uint32_t tmpccmr1 = 0;
;;;2259     uint32_t tmpccer = 0;
;;;2260     
;;;2261     /* Check the TIM handle allocation */
;;;2262     if(htim == NULL)
000eba  2c00              CMP      r4,#0
000ebc  d003              BEQ      |L1.3782|
;;;2263     {
;;;2264       return HAL_ERROR;
;;;2265     }
;;;2266      
;;;2267     /* Check the parameters */
;;;2268     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2269     assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
;;;2270     assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
;;;2271     assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
;;;2272     assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
;;;2273     assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
;;;2274     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;2275     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
;;;2276     assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;2277     assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
;;;2278   
;;;2279     if(htim->State == HAL_TIM_STATE_RESET)
000ebe  f8940039          LDRB     r0,[r4,#0x39]
000ec2  b110              CBZ      r0,|L1.3786|
000ec4  e007              B        |L1.3798|
                  |L1.3782|
000ec6  2001              MOVS     r0,#1                 ;2264
;;;2280     { 
;;;2281       /* Allocate lock resource and initialize it */
;;;2282       htim->Lock = HAL_UNLOCKED;
;;;2283       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2284       HAL_TIM_Encoder_MspInit(htim);
;;;2285     }
;;;2286     
;;;2287     /* Set the TIM state */
;;;2288     htim->State= HAL_TIM_STATE_BUSY;   
;;;2289       
;;;2290     /* Reset the SMS bits */
;;;2291     htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;2292     
;;;2293     /* Configure the Time base in the Encoder Mode */
;;;2294     TIM_Base_SetConfig(htim->Instance, &htim->Init);  
;;;2295     
;;;2296     /* Get the TIMx SMCR register value */
;;;2297     tmpsmcr = htim->Instance->SMCR;
;;;2298   
;;;2299     /* Get the TIMx CCMR1 register value */
;;;2300     tmpccmr1 = htim->Instance->CCMR1;
;;;2301   
;;;2302     /* Get the TIMx CCER register value */
;;;2303     tmpccer = htim->Instance->CCER;
;;;2304   
;;;2305     /* Set the encoder Mode */
;;;2306     tmpsmcr |= sConfig->EncoderMode;
;;;2307   
;;;2308     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;2309     tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
;;;2310     tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8));
;;;2311     
;;;2312     /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
;;;2313     tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
;;;2314     tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
;;;2315     tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8);
;;;2316     tmpccmr1 |= (sConfig->IC1Filter << 4) | (sConfig->IC2Filter << 12);
;;;2317   
;;;2318     /* Set the TI1 and the TI2 Polarities */
;;;2319     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
;;;2320     tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
;;;2321     tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4);
;;;2322     
;;;2323     /* Write to TIMx SMCR */
;;;2324     htim->Instance->SMCR = tmpsmcr;
;;;2325   
;;;2326     /* Write to TIMx CCMR1 */
;;;2327     htim->Instance->CCMR1 = tmpccmr1;
;;;2328   
;;;2329     /* Write to TIMx CCER */
;;;2330     htim->Instance->CCER = tmpccer;
;;;2331     
;;;2332     /* Initialize the TIM state*/
;;;2333     htim->State= HAL_TIM_STATE_READY;
;;;2334     
;;;2335     return HAL_OK;
;;;2336   }
000ec8  bd70              POP      {r4-r6,pc}
                  |L1.3786|
000eca  2000              MOVS     r0,#0                 ;2282
000ecc  f8840038          STRB     r0,[r4,#0x38]         ;2282
000ed0  4620              MOV      r0,r4                 ;2284
000ed2  f7fffffe          BL       HAL_TIM_Encoder_MspInit
                  |L1.3798|
000ed6  2002              MOVS     r0,#2                 ;2288
000ed8  f8840039          STRB     r0,[r4,#0x39]         ;2288
000edc  6820              LDR      r0,[r4,#0]            ;2291
000ede  6881              LDR      r1,[r0,#8]            ;2291
000ee0  f0210107          BIC      r1,r1,#7              ;2291
000ee4  6081              STR      r1,[r0,#8]            ;2291
000ee6  1d21              ADDS     r1,r4,#4              ;2294
000ee8  6820              LDR      r0,[r4,#0]            ;2294
000eea  f7fffffe          BL       TIM_Base_SetConfig
000eee  6820              LDR      r0,[r4,#0]            ;2297
000ef0  6881              LDR      r1,[r0,#8]            ;2297
000ef2  6982              LDR      r2,[r0,#0x18]         ;2300
000ef4  6a03              LDR      r3,[r0,#0x20]         ;2303
000ef6  f8d5c000          LDR      r12,[r5,#0]           ;2306
000efa  ea4c0101          ORR      r1,r12,r1             ;2306
000efe  f0220203          BIC      r2,r2,#3              ;2309
000f02  f4227240          BIC      r2,r2,#0x300          ;2309
000f06  69ae              LDR      r6,[r5,#0x18]         ;2310
000f08  f8d5c008          LDR      r12,[r5,#8]           ;2310
000f0c  ea422206          ORR      r2,r2,r6,LSL #8       ;2310
000f10  ea4c0202          ORR      r2,r12,r2             ;2310
000f14  f022020c          BIC      r2,r2,#0xc            ;2313
000f18  f4226240          BIC      r2,r2,#0xc00          ;2313
000f1c  f02202f0          BIC      r2,r2,#0xf0           ;2314
000f20  f4224270          BIC      r2,r2,#0xf000         ;2314
000f24  69ee              LDR      r6,[r5,#0x1c]         ;2315
000f26  f8d5c00c          LDR      r12,[r5,#0xc]         ;2315
000f2a  ea422206          ORR      r2,r2,r6,LSL #8       ;2315
000f2e  ea4c0202          ORR      r2,r12,r2             ;2315
000f32  f8d5c010          LDR      r12,[r5,#0x10]        ;2316
000f36  6a2e              LDR      r6,[r5,#0x20]         ;2316
000f38  ea4f1c0c          LSL      r12,r12,#4            ;2316
000f3c  ea4c3c06          ORR      r12,r12,r6,LSL #12    ;2316
000f40  ea4c0202          ORR      r2,r12,r2             ;2316
000f44  f0230322          BIC      r3,r3,#0x22           ;2319
000f48  f0230388          BIC      r3,r3,#0x88           ;2320
000f4c  f8d5c004          LDR      r12,[r5,#4]           ;2321
000f50  696d              LDR      r5,[r5,#0x14]         ;2321
000f52  ea431305          ORR      r3,r3,r5,LSL #4       ;2321
000f56  ea4c0303          ORR      r3,r12,r3             ;2321
000f5a  6081              STR      r1,[r0,#8]            ;2324
000f5c  6820              LDR      r0,[r4,#0]            ;2327
000f5e  6182              STR      r2,[r0,#0x18]         ;2327
000f60  6820              LDR      r0,[r4,#0]            ;2330
000f62  6203              STR      r3,[r0,#0x20]         ;2330
000f64  2001              MOVS     r0,#1                 ;2333
000f66  f8840039          STRB     r0,[r4,#0x39]         ;2333
000f6a  2000              MOVS     r0,#0                 ;2335
000f6c  bd70              POP      {r4-r6,pc}
;;;2337   
                          ENDP

                  HAL_TIM_Encoder_MspDeInit PROC
;;;2384     */
;;;2385   __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
000f6e  4770              BX       lr
;;;2386   {
;;;2387     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2388               the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
;;;2389      */
;;;2390   }
;;;2391   
                          ENDP

                  HAL_TIM_Encoder_DeInit PROC
;;;2343     */
;;;2344   HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
000f70  b510              PUSH     {r4,lr}
;;;2345   {
000f72  4604              MOV      r4,r0
;;;2346     /* Check the parameters */
;;;2347     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2348     
;;;2349     htim->State = HAL_TIM_STATE_BUSY;
000f74  2002              MOVS     r0,#2
000f76  f8840039          STRB     r0,[r4,#0x39]
;;;2350     
;;;2351     /* Disable the TIM Peripheral Clock */
;;;2352     __HAL_TIM_DISABLE(htim);
000f7a  6820              LDR      r0,[r4,#0]
000f7c  6a01              LDR      r1,[r0,#0x20]
000f7e  f2411211          MOV      r2,#0x1111
000f82  4211              TST      r1,r2
000f84  d107              BNE      |L1.3990|
000f86  6a01              LDR      r1,[r0,#0x20]
000f88  1092              ASRS     r2,r2,#2
000f8a  4211              TST      r1,r2
000f8c  d103              BNE      |L1.3990|
000f8e  6801              LDR      r1,[r0,#0]
000f90  f0210101          BIC      r1,r1,#1
000f94  6001              STR      r1,[r0,#0]
                  |L1.3990|
;;;2353     
;;;2354     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2355     HAL_TIM_Encoder_MspDeInit(htim);
000f96  4620              MOV      r0,r4
000f98  f7fffffe          BL       HAL_TIM_Encoder_MspDeInit
;;;2356       
;;;2357     /* Change TIM state */  
;;;2358     htim->State = HAL_TIM_STATE_RESET;
000f9c  2000              MOVS     r0,#0
000f9e  f8840039          STRB     r0,[r4,#0x39]
;;;2359    
;;;2360     /* Release Lock */
;;;2361     __HAL_UNLOCK(htim);
000fa2  f8840038          STRB     r0,[r4,#0x38]
;;;2362   
;;;2363     return HAL_OK;
;;;2364   }
000fa6  bd10              POP      {r4,pc}
;;;2365   
                          ENDP

                  HAL_TIM_Encoder_Start PROC
;;;2402     */
;;;2403   HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000fa8  b510              PUSH     {r4,lr}
;;;2404   {
000faa  4604              MOV      r4,r0
;;;2405     /* Check the parameters */
;;;2406     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2407     
;;;2408     /* Enable the encoder interface channels */
;;;2409     switch (Channel)
000fac  2900              CMP      r1,#0
;;;2410     {
;;;2411       case TIM_CHANNEL_1:
;;;2412       {
;;;2413         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000fae  6820              LDR      r0,[r4,#0]
000fb0  d011              BEQ      |L1.4054|
000fb2  2904              CMP      r1,#4                 ;2409
000fb4  d014              BEQ      |L1.4064|
;;;2414         break; 
;;;2415       }
;;;2416       case TIM_CHANNEL_2:
;;;2417       { 
;;;2418         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
;;;2419         break;
;;;2420       }  
;;;2421       default :
;;;2422       {
;;;2423        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000fb6  2201              MOVS     r2,#1
000fb8  2100              MOVS     r1,#0
000fba  f7fffffe          BL       TIM_CCxChannelCmd
;;;2424        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000fbe  2201              MOVS     r2,#1
000fc0  2104              MOVS     r1,#4
000fc2  6820              LDR      r0,[r4,#0]
000fc4  f7fffffe          BL       TIM_CCxChannelCmd
                  |L1.4040|
;;;2425        break; 
;;;2426       }
;;;2427     }  
;;;2428     /* Enable the Peripheral */
;;;2429     __HAL_TIM_ENABLE(htim);
000fc8  6820              LDR      r0,[r4,#0]
000fca  6801              LDR      r1,[r0,#0]
000fcc  f0410101          ORR      r1,r1,#1
000fd0  6001              STR      r1,[r0,#0]
;;;2430     
;;;2431     /* Return function status */
;;;2432     return HAL_OK;
000fd2  2000              MOVS     r0,#0
;;;2433   }
000fd4  bd10              POP      {r4,pc}
                  |L1.4054|
000fd6  2201              MOVS     r2,#1                 ;2413
000fd8  2100              MOVS     r1,#0                 ;2413
000fda  f7fffffe          BL       TIM_CCxChannelCmd
000fde  e7f3              B        |L1.4040|
                  |L1.4064|
000fe0  2201              MOVS     r2,#1                 ;2418
000fe2  2104              MOVS     r1,#4                 ;2418
000fe4  f7fffffe          BL       TIM_CCxChannelCmd
000fe8  e7ee              B        |L1.4040|
;;;2434   
                          ENDP

                  HAL_TIM_Encoder_Stop PROC
;;;2445     */
;;;2446   HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000fea  b510              PUSH     {r4,lr}
;;;2447   {
000fec  4604              MOV      r4,r0
;;;2448     /* Check the parameters */
;;;2449       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2450       
;;;2451      /* Disable the Input Capture channels 1 and 2
;;;2452       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
;;;2453     switch (Channel)
000fee  2900              CMP      r1,#0
;;;2454     {
;;;2455       case TIM_CHANNEL_1:
;;;2456       {
;;;2457         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000ff0  6820              LDR      r0,[r4,#0]
000ff2  d01a              BEQ      |L1.4138|
000ff4  2904              CMP      r1,#4                 ;2453
000ff6  d01d              BEQ      |L1.4148|
;;;2458         break; 
;;;2459       }
;;;2460       case TIM_CHANNEL_2:
;;;2461       { 
;;;2462         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
;;;2463         break;
;;;2464       }  
;;;2465       default :
;;;2466       {
;;;2467        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000ff8  2200              MOVS     r2,#0
000ffa  4611              MOV      r1,r2
000ffc  f7fffffe          BL       TIM_CCxChannelCmd
;;;2468        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
001000  2200              MOVS     r2,#0
001002  2104              MOVS     r1,#4
001004  6820              LDR      r0,[r4,#0]
001006  f7fffffe          BL       TIM_CCxChannelCmd
                  |L1.4106|
;;;2469        break; 
;;;2470       }
;;;2471     }  
;;;2472     /* Disable the Peripheral */
;;;2473     __HAL_TIM_DISABLE(htim);
00100a  6820              LDR      r0,[r4,#0]
00100c  6a01              LDR      r1,[r0,#0x20]
00100e  f2411211          MOV      r2,#0x1111
001012  4211              TST      r1,r2
001014  d107              BNE      |L1.4134|
001016  6a01              LDR      r1,[r0,#0x20]
001018  1092              ASRS     r2,r2,#2
00101a  4211              TST      r1,r2
00101c  d103              BNE      |L1.4134|
00101e  6801              LDR      r1,[r0,#0]
001020  f0210101          BIC      r1,r1,#1
001024  6001              STR      r1,[r0,#0]
                  |L1.4134|
;;;2474     
;;;2475     /* Return function status */
;;;2476     return HAL_OK;
001026  2000              MOVS     r0,#0
;;;2477   }
001028  bd10              POP      {r4,pc}
                  |L1.4138|
00102a  2200              MOVS     r2,#0                 ;2457
00102c  4611              MOV      r1,r2                 ;2457
00102e  f7fffffe          BL       TIM_CCxChannelCmd
001032  e7ea              B        |L1.4106|
                  |L1.4148|
001034  2200              MOVS     r2,#0                 ;2462
001036  2104              MOVS     r1,#4                 ;2462
001038  f7fffffe          BL       TIM_CCxChannelCmd
00103c  e7e5              B        |L1.4106|
;;;2478   
                          ENDP

                  HAL_TIM_Encoder_Start_IT PROC
;;;2489     */
;;;2490   HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
00103e  b510              PUSH     {r4,lr}
;;;2491   {
001040  4604              MOV      r4,r0
;;;2492     /* Check the parameters */
;;;2493     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2494     
;;;2495     /* Enable the encoder interface channels */
;;;2496     /* Enable the capture compare Interrupts 1 and/or 2 */
;;;2497     switch (Channel)
001042  2900              CMP      r1,#0
;;;2498     {
;;;2499       case TIM_CHANNEL_1:
;;;2500       {
;;;2501         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
001044  6820              LDR      r0,[r4,#0]
001046  d01b              BEQ      |L1.4224|
001048  2904              CMP      r1,#4                 ;2497
00104a  d023              BEQ      |L1.4244|
;;;2502         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
;;;2503         break; 
;;;2504       }
;;;2505       case TIM_CHANNEL_2:
;;;2506       { 
;;;2507         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2508         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2); 
;;;2509         break;
;;;2510       }  
;;;2511       default :
;;;2512       {
;;;2513        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
00104c  2201              MOVS     r2,#1
00104e  2100              MOVS     r1,#0
001050  f7fffffe          BL       TIM_CCxChannelCmd
;;;2514        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
001054  2201              MOVS     r2,#1
001056  2104              MOVS     r1,#4
001058  6820              LDR      r0,[r4,#0]
00105a  f7fffffe          BL       TIM_CCxChannelCmd
;;;2515        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
00105e  6820              LDR      r0,[r4,#0]
001060  68c1              LDR      r1,[r0,#0xc]
001062  f0410102          ORR      r1,r1,#2
001066  60c1              STR      r1,[r0,#0xc]
;;;2516        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
001068  6820              LDR      r0,[r4,#0]
00106a  68c1              LDR      r1,[r0,#0xc]
00106c  f0410104          ORR      r1,r1,#4
001070  60c1              STR      r1,[r0,#0xc]
                  |L1.4210|
;;;2517        break; 
;;;2518       }
;;;2519     }
;;;2520     
;;;2521     /* Enable the Peripheral */
;;;2522     __HAL_TIM_ENABLE(htim);
001072  6820              LDR      r0,[r4,#0]
001074  6801              LDR      r1,[r0,#0]
001076  f0410101          ORR      r1,r1,#1
00107a  6001              STR      r1,[r0,#0]
;;;2523     
;;;2524     /* Return function status */
;;;2525     return HAL_OK;
00107c  2000              MOVS     r0,#0
;;;2526   }
00107e  bd10              POP      {r4,pc}
                  |L1.4224|
001080  2201              MOVS     r2,#1                 ;2501
001082  2100              MOVS     r1,#0                 ;2501
001084  f7fffffe          BL       TIM_CCxChannelCmd
001088  6820              LDR      r0,[r4,#0]            ;2502
00108a  68c1              LDR      r1,[r0,#0xc]          ;2502
00108c  f0410102          ORR      r1,r1,#2              ;2502
001090  60c1              STR      r1,[r0,#0xc]          ;2502
001092  e7ee              B        |L1.4210|
                  |L1.4244|
001094  2201              MOVS     r2,#1                 ;2507
001096  2104              MOVS     r1,#4                 ;2507
001098  f7fffffe          BL       TIM_CCxChannelCmd
00109c  6820              LDR      r0,[r4,#0]            ;2508
00109e  68c1              LDR      r1,[r0,#0xc]          ;2508
0010a0  f0410104          ORR      r1,r1,#4              ;2508
0010a4  60c1              STR      r1,[r0,#0xc]          ;2508
0010a6  e7e4              B        |L1.4210|
;;;2527   
                          ENDP

                  HAL_TIM_Encoder_Stop_IT PROC
;;;2538     */
;;;2539   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
0010a8  b510              PUSH     {r4,lr}
;;;2540   {
0010aa  4604              MOV      r4,r0
;;;2541     /* Check the parameters */
;;;2542     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2543       
;;;2544     /* Disable the Input Capture channels 1 and 2
;;;2545       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
;;;2546     if(Channel == TIM_CHANNEL_1)
0010ac  2900              CMP      r1,#0
;;;2547     {
;;;2548       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
0010ae  6820              LDR      r0,[r4,#0]
0010b0  d027              BEQ      |L1.4354|
;;;2549       
;;;2550       /* Disable the capture compare Interrupts 1 */
;;;2551     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
;;;2552     }  
;;;2553     else if(Channel == TIM_CHANNEL_2)
0010b2  2904              CMP      r1,#4
0010b4  d02f              BEQ      |L1.4374|
;;;2554     {  
;;;2555       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
;;;2556       
;;;2557       /* Disable the capture compare Interrupts 2 */
;;;2558     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
;;;2559     }  
;;;2560     else
;;;2561     {
;;;2562       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
0010b6  2200              MOVS     r2,#0
0010b8  4611              MOV      r1,r2
0010ba  f7fffffe          BL       TIM_CCxChannelCmd
;;;2563       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
0010be  2200              MOVS     r2,#0
0010c0  2104              MOVS     r1,#4
0010c2  6820              LDR      r0,[r4,#0]
0010c4  f7fffffe          BL       TIM_CCxChannelCmd
;;;2564       
;;;2565       /* Disable the capture compare Interrupts 1 and 2 */
;;;2566       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
0010c8  6820              LDR      r0,[r4,#0]
0010ca  68c1              LDR      r1,[r0,#0xc]
0010cc  f0210102          BIC      r1,r1,#2
0010d0  60c1              STR      r1,[r0,#0xc]
;;;2567       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
0010d2  6820              LDR      r0,[r4,#0]
0010d4  68c1              LDR      r1,[r0,#0xc]
0010d6  f0210104          BIC      r1,r1,#4
0010da  60c1              STR      r1,[r0,#0xc]
                  |L1.4316|
;;;2568     }
;;;2569       
;;;2570     /* Disable the Peripheral */
;;;2571     __HAL_TIM_DISABLE(htim);
0010dc  6820              LDR      r0,[r4,#0]
0010de  6a01              LDR      r1,[r0,#0x20]
0010e0  f2411211          MOV      r2,#0x1111
0010e4  4211              TST      r1,r2
0010e6  d107              BNE      |L1.4344|
0010e8  6a01              LDR      r1,[r0,#0x20]
0010ea  1092              ASRS     r2,r2,#2
0010ec  4211              TST      r1,r2
0010ee  d103              BNE      |L1.4344|
0010f0  6801              LDR      r1,[r0,#0]
0010f2  f0210101          BIC      r1,r1,#1
0010f6  6001              STR      r1,[r0,#0]
                  |L1.4344|
;;;2572     
;;;2573     /* Change the htim state */
;;;2574     htim->State = HAL_TIM_STATE_READY;
0010f8  2001              MOVS     r0,#1
0010fa  f8840039          STRB     r0,[r4,#0x39]
;;;2575     
;;;2576     /* Return function status */
;;;2577     return HAL_OK;
0010fe  2000              MOVS     r0,#0
;;;2578   }
001100  bd10              POP      {r4,pc}
                  |L1.4354|
001102  2200              MOVS     r2,#0                 ;2548
001104  4611              MOV      r1,r2                 ;2548
001106  f7fffffe          BL       TIM_CCxChannelCmd
00110a  6820              LDR      r0,[r4,#0]            ;2551
00110c  68c1              LDR      r1,[r0,#0xc]          ;2551
00110e  f0210102          BIC      r1,r1,#2              ;2551
001112  60c1              STR      r1,[r0,#0xc]          ;2551
001114  e7e2              B        |L1.4316|
                  |L1.4374|
001116  2200              MOVS     r2,#0                 ;2555
001118  2104              MOVS     r1,#4                 ;2555
00111a  f7fffffe          BL       TIM_CCxChannelCmd
00111e  6820              LDR      r0,[r4,#0]            ;2558
001120  68c1              LDR      r1,[r0,#0xc]          ;2558
001122  f0210104          BIC      r1,r1,#4              ;2558
001126  60c1              STR      r1,[r0,#0xc]          ;2558
001128  e7d8              B        |L1.4316|
;;;2579   
                          ENDP

                  HAL_TIM_Encoder_Start_DMA PROC
;;;2593     */
;;;2594   HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
00112a  e92d41f0          PUSH     {r4-r8,lr}
;;;2595   {
00112e  4604              MOV      r4,r0
001130  9d06              LDR      r5,[sp,#0x18]
001132  4698              MOV      r8,r3
;;;2596     /* Check the parameters */
;;;2597     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2598     
;;;2599     if((htim->State == HAL_TIM_STATE_BUSY))
001134  f8940039          LDRB     r0,[r4,#0x39]
001138  2802              CMP      r0,#2
00113a  d004              BEQ      |L1.4422|
;;;2600     {
;;;2601        return HAL_BUSY;
;;;2602     }
;;;2603     else if((htim->State == HAL_TIM_STATE_READY))
00113c  f8940039          LDRB     r0,[r4,#0x39]
001140  2801              CMP      r0,#1
001142  d003              BEQ      |L1.4428|
001144  e00d              B        |L1.4450|
                  |L1.4422|
001146  2002              MOVS     r0,#2                 ;2601
;;;2604     {
;;;2605       if((((pData1 == 0) || (pData2 == 0) )) && (Length > 0)) 
;;;2606       {
;;;2607         return HAL_ERROR;                                    
;;;2608       }
;;;2609       else
;;;2610       {
;;;2611         htim->State = HAL_TIM_STATE_BUSY;
;;;2612       }
;;;2613     }  
;;;2614      
;;;2615     switch (Channel)
;;;2616     {
;;;2617       case TIM_CHANNEL_1:
;;;2618       {
;;;2619         /* Set the DMA Period elapsed callback */
;;;2620         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2621        
;;;2622         /* Set the DMA error callback */
;;;2623         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;2624         
;;;2625         /* Enable the DMA Stream */
;;;2626         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length); 
;;;2627         
;;;2628         /* Enable the TIM Input Capture DMA request */      
;;;2629         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2630               
;;;2631         /* Enable the Peripheral */
;;;2632         __HAL_TIM_ENABLE(htim);
;;;2633         
;;;2634         /* Enable the Capture compare channel */
;;;2635         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2636       }
;;;2637       break;
;;;2638       
;;;2639       case TIM_CHANNEL_2:
;;;2640       {
;;;2641         /* Set the DMA Period elapsed callback */
;;;2642         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2643        
;;;2644         /* Set the DMA error callback */
;;;2645         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
;;;2646         /* Enable the DMA Stream */
;;;2647         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2648         
;;;2649         /* Enable the TIM Input Capture  DMA request */
;;;2650         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2651        
;;;2652         /* Enable the Peripheral */
;;;2653         __HAL_TIM_ENABLE(htim);
;;;2654         
;;;2655         /* Enable the Capture compare channel */
;;;2656         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2657       }
;;;2658       break;
;;;2659       
;;;2660       case TIM_CHANNEL_ALL:
;;;2661       {
;;;2662         /* Set the DMA Period elapsed callback */
;;;2663         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2664        
;;;2665         /* Set the DMA error callback */
;;;2666         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;2667         
;;;2668         /* Enable the DMA Stream */
;;;2669         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
;;;2670         
;;;2671         /* Set the DMA Period elapsed callback */
;;;2672         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2673        
;;;2674         /* Set the DMA error callback */
;;;2675         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;2676         
;;;2677         /* Enable the DMA Stream */
;;;2678         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2679             
;;;2680        /* Enable the Peripheral */
;;;2681         __HAL_TIM_ENABLE(htim);
;;;2682         
;;;2683         /* Enable the Capture compare channel */
;;;2684         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2685         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2686         
;;;2687         /* Enable the TIM Input Capture  DMA request */
;;;2688         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2689         /* Enable the TIM Input Capture  DMA request */
;;;2690         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2691       }
;;;2692       break;
;;;2693       
;;;2694       default:
;;;2695       break;
;;;2696     }  
;;;2697     /* Return function status */
;;;2698     return HAL_OK;
;;;2699   }
001148  e8bd81f0          POP      {r4-r8,pc}
                  |L1.4428|
00114c  b112              CBZ      r2,|L1.4436|
00114e  f1b80f00          CMP      r8,#0                 ;2605
001152  d103              BNE      |L1.4444|
                  |L1.4436|
001154  b115              CBZ      r5,|L1.4444|
001156  2001              MOVS     r0,#1                 ;2607
001158  e8bd81f0          POP      {r4-r8,pc}
                  |L1.4444|
00115c  2002              MOVS     r0,#2                 ;2611
00115e  f8840039          STRB     r0,[r4,#0x39]         ;2611
                  |L1.4450|
001162  f2af6617          ADR      r6,TIM_DMACaptureCplt + 1
001166  f6af77cb          ADR      r7,TIM_DMAError + 1
00116a  b121              CBZ      r1,|L1.4470|
00116c  2904              CMP      r1,#4                 ;2615
00116e  d01d              BEQ      |L1.4524|
001170  2918              CMP      r1,#0x18              ;2615
001172  d167              BNE      |L1.4676|
001174  e036              B        |L1.4580|
                  |L1.4470|
001176  6a20              LDR      r0,[r4,#0x20]         ;2620
001178  63c6              STR      r6,[r0,#0x3c]         ;2620
00117a  6a20              LDR      r0,[r4,#0x20]         ;2623
00117c  6487              STR      r7,[r0,#0x48]         ;2623
00117e  6820              LDR      r0,[r4,#0]            ;2626
001180  462b              MOV      r3,r5                 ;2626
001182  f1000134          ADD      r1,r0,#0x34           ;2626
001186  6a20              LDR      r0,[r4,#0x20]         ;2626
001188  f7fffffe          BL       HAL_DMA_Start_IT
00118c  6820              LDR      r0,[r4,#0]            ;2629
00118e  68c1              LDR      r1,[r0,#0xc]          ;2629
001190  f4417100          ORR      r1,r1,#0x200          ;2629
001194  60c1              STR      r1,[r0,#0xc]          ;2629
001196  6820              LDR      r0,[r4,#0]            ;2632
001198  6801              LDR      r1,[r0,#0]            ;2632
00119a  f0410101          ORR      r1,r1,#1              ;2632
00119e  6001              STR      r1,[r0,#0]            ;2632
0011a0  2201              MOVS     r2,#1                 ;2635
0011a2  2100              MOVS     r1,#0                 ;2635
0011a4  6820              LDR      r0,[r4,#0]            ;2635
0011a6  f7fffffe          BL       TIM_CCxChannelCmd
0011aa  e04b              B        |L1.4676|
                  |L1.4524|
0011ac  6a60              LDR      r0,[r4,#0x24]         ;2642
0011ae  63c6              STR      r6,[r0,#0x3c]         ;2642
0011b0  6a60              LDR      r0,[r4,#0x24]         ;2645
0011b2  6487              STR      r7,[r0,#0x48]         ;2645
0011b4  6820              LDR      r0,[r4,#0]            ;2647
0011b6  462b              MOV      r3,r5                 ;2647
0011b8  f1000138          ADD      r1,r0,#0x38           ;2647
0011bc  4642              MOV      r2,r8                 ;2647
0011be  6a60              LDR      r0,[r4,#0x24]         ;2647
0011c0  f7fffffe          BL       HAL_DMA_Start_IT
0011c4  6820              LDR      r0,[r4,#0]            ;2650
0011c6  68c1              LDR      r1,[r0,#0xc]          ;2650
0011c8  f4416180          ORR      r1,r1,#0x400          ;2650
0011cc  60c1              STR      r1,[r0,#0xc]          ;2650
0011ce  6820              LDR      r0,[r4,#0]            ;2653
0011d0  6801              LDR      r1,[r0,#0]            ;2653
0011d2  f0410101          ORR      r1,r1,#1              ;2653
0011d6  6001              STR      r1,[r0,#0]            ;2653
0011d8  2201              MOVS     r2,#1                 ;2656
0011da  2104              MOVS     r1,#4                 ;2656
0011dc  6820              LDR      r0,[r4,#0]            ;2656
0011de  f7fffffe          BL       TIM_CCxChannelCmd
0011e2  e02f              B        |L1.4676|
                  |L1.4580|
0011e4  6a20              LDR      r0,[r4,#0x20]         ;2663
0011e6  63c6              STR      r6,[r0,#0x3c]         ;2663
0011e8  6a20              LDR      r0,[r4,#0x20]         ;2666
0011ea  6487              STR      r7,[r0,#0x48]         ;2666
0011ec  6820              LDR      r0,[r4,#0]            ;2669
0011ee  462b              MOV      r3,r5                 ;2669
0011f0  f1000134          ADD      r1,r0,#0x34           ;2669
0011f4  6a20              LDR      r0,[r4,#0x20]         ;2669
0011f6  f7fffffe          BL       HAL_DMA_Start_IT
0011fa  6a60              LDR      r0,[r4,#0x24]         ;2672
0011fc  63c6              STR      r6,[r0,#0x3c]         ;2672
0011fe  6a60              LDR      r0,[r4,#0x24]         ;2675
001200  6487              STR      r7,[r0,#0x48]         ;2675
001202  6820              LDR      r0,[r4,#0]            ;2678
001204  462b              MOV      r3,r5                 ;2678
001206  f1000138          ADD      r1,r0,#0x38           ;2678
00120a  4642              MOV      r2,r8                 ;2678
00120c  6a60              LDR      r0,[r4,#0x24]         ;2678
00120e  f7fffffe          BL       HAL_DMA_Start_IT
001212  6820              LDR      r0,[r4,#0]            ;2681
001214  6801              LDR      r1,[r0,#0]            ;2681
001216  f0410101          ORR      r1,r1,#1              ;2681
00121a  6001              STR      r1,[r0,#0]            ;2681
00121c  2201              MOVS     r2,#1                 ;2684
00121e  2100              MOVS     r1,#0                 ;2684
001220  6820              LDR      r0,[r4,#0]            ;2684
001222  f7fffffe          BL       TIM_CCxChannelCmd
001226  2201              MOVS     r2,#1                 ;2685
001228  2104              MOVS     r1,#4                 ;2685
00122a  6820              LDR      r0,[r4,#0]            ;2685
00122c  f7fffffe          BL       TIM_CCxChannelCmd
001230  6820              LDR      r0,[r4,#0]            ;2688
001232  68c1              LDR      r1,[r0,#0xc]          ;2688
001234  f4417100          ORR      r1,r1,#0x200          ;2688
001238  60c1              STR      r1,[r0,#0xc]          ;2688
00123a  6820              LDR      r0,[r4,#0]            ;2690
00123c  68c1              LDR      r1,[r0,#0xc]          ;2690
00123e  f4416180          ORR      r1,r1,#0x400          ;2690
001242  60c1              STR      r1,[r0,#0xc]          ;2690
                  |L1.4676|
001244  2000              MOVS     r0,#0                 ;2698
001246  e8bd81f0          POP      {r4-r8,pc}
;;;2700   
                          ENDP

                  HAL_TIM_Encoder_Stop_DMA PROC
;;;2711     */
;;;2712   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
00124a  b510              PUSH     {r4,lr}
;;;2713   {
00124c  4604              MOV      r4,r0
;;;2714     /* Check the parameters */
;;;2715     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2716     
;;;2717     /* Disable the Input Capture channels 1 and 2
;;;2718       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
;;;2719     if(Channel == TIM_CHANNEL_1)
00124e  2900              CMP      r1,#0
;;;2720     {
;;;2721       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
001250  6820              LDR      r0,[r4,#0]
001252  d027              BEQ      |L1.4772|
;;;2722       
;;;2723       /* Disable the capture compare DMA Request 1 */
;;;2724       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
;;;2725     }  
;;;2726     else if(Channel == TIM_CHANNEL_2)
001254  2904              CMP      r1,#4
001256  d02f              BEQ      |L1.4792|
;;;2727     {  
;;;2728       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
;;;2729       
;;;2730       /* Disable the capture compare DMA Request 2 */
;;;2731       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
;;;2732     }  
;;;2733     else
;;;2734     {
;;;2735       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
001258  2200              MOVS     r2,#0
00125a  4611              MOV      r1,r2
00125c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2736       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
001260  2200              MOVS     r2,#0
001262  2104              MOVS     r1,#4
001264  6820              LDR      r0,[r4,#0]
001266  f7fffffe          BL       TIM_CCxChannelCmd
;;;2737       
;;;2738       /* Disable the capture compare DMA Request 1 and 2 */
;;;2739       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
00126a  6820              LDR      r0,[r4,#0]
00126c  68c1              LDR      r1,[r0,#0xc]
00126e  f4217100          BIC      r1,r1,#0x200
001272  60c1              STR      r1,[r0,#0xc]
;;;2740       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
001274  6820              LDR      r0,[r4,#0]
001276  68c1              LDR      r1,[r0,#0xc]
001278  f4216180          BIC      r1,r1,#0x400
00127c  60c1              STR      r1,[r0,#0xc]
                  |L1.4734|
;;;2741     }
;;;2742     
;;;2743     /* Disable the Peripheral */
;;;2744     __HAL_TIM_DISABLE(htim);
00127e  6820              LDR      r0,[r4,#0]
001280  6a01              LDR      r1,[r0,#0x20]
001282  f2411211          MOV      r2,#0x1111
001286  4211              TST      r1,r2
001288  d107              BNE      |L1.4762|
00128a  6a01              LDR      r1,[r0,#0x20]
00128c  1092              ASRS     r2,r2,#2
00128e  4211              TST      r1,r2
001290  d103              BNE      |L1.4762|
001292  6801              LDR      r1,[r0,#0]
001294  f0210101          BIC      r1,r1,#1
001298  6001              STR      r1,[r0,#0]
                  |L1.4762|
;;;2745     
;;;2746     /* Change the htim state */
;;;2747     htim->State = HAL_TIM_STATE_READY;
00129a  2001              MOVS     r0,#1
00129c  f8840039          STRB     r0,[r4,#0x39]
;;;2748     
;;;2749     /* Return function status */
;;;2750     return HAL_OK;
0012a0  2000              MOVS     r0,#0
;;;2751   }
0012a2  bd10              POP      {r4,pc}
                  |L1.4772|
0012a4  2200              MOVS     r2,#0                 ;2721
0012a6  4611              MOV      r1,r2                 ;2721
0012a8  f7fffffe          BL       TIM_CCxChannelCmd
0012ac  6820              LDR      r0,[r4,#0]            ;2724
0012ae  68c1              LDR      r1,[r0,#0xc]          ;2724
0012b0  f4217100          BIC      r1,r1,#0x200          ;2724
0012b4  60c1              STR      r1,[r0,#0xc]          ;2724
0012b6  e7e2              B        |L1.4734|
                  |L1.4792|
0012b8  2200              MOVS     r2,#0                 ;2728
0012ba  2104              MOVS     r1,#4                 ;2728
0012bc  f7fffffe          BL       TIM_CCxChannelCmd
0012c0  6820              LDR      r0,[r4,#0]            ;2731
0012c2  68c1              LDR      r1,[r0,#0xc]          ;2731
0012c4  f4216180          BIC      r1,r1,#0x400          ;2731
0012c8  60c1              STR      r1,[r0,#0xc]          ;2731
0012ca  e7d8              B        |L1.4734|
;;;2752   /**
                          ENDP

                  HAL_TIM_TriggerCallback PROC
;;;4303     */
;;;4304   __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
0012cc  4770              BX       lr
;;;4305   {
;;;4306     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4307               the HAL_TIM_TriggerCallback could be implemented in the user file
;;;4308      */
;;;4309   }
;;;4310   
                          ENDP

                  HAL_TIM_OC_DelayElapsedCallback PROC
;;;4265     */
;;;4266   __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
0012ce  4770              BX       lr
;;;4267   {
;;;4268     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4269               the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
;;;4270      */
;;;4271   }
;;;4272   /**
                          ENDP

                  HAL_TIM_IRQHandler PROC
;;;2774     */
;;;2775   void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
0012d0  b570              PUSH     {r4-r6,lr}
;;;2776   {
0012d2  4604              MOV      r4,r0
;;;2777     /* Capture compare 1 event */
;;;2778     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
0012d4  6820              LDR      r0,[r4,#0]
0012d6  6901              LDR      r1,[r0,#0x10]
0012d8  f04f0500          MOV      r5,#0
0012dc  f0110f02          TST      r1,#2
0012e0  d017              BEQ      |L1.4882|
;;;2779     {
;;;2780       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
0012e2  68c1              LDR      r1,[r0,#0xc]
0012e4  f0110f02          TST      r1,#2
0012e8  d013              BEQ      |L1.4882|
;;;2781       {
;;;2782         {
;;;2783           __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
0012ea  1ee9              SUBS     r1,r5,#3
0012ec  6101              STR      r1,[r0,#0x10]
;;;2784           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
0012ee  2001              MOVS     r0,#1
0012f0  7620              STRB     r0,[r4,#0x18]
;;;2785           
;;;2786           /* Input capture event */
;;;2787           if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
0012f2  6820              LDR      r0,[r4,#0]
0012f4  6980              LDR      r0,[r0,#0x18]
0012f6  f0100f03          TST      r0,#3
0012fa  d003              BEQ      |L1.4868|
;;;2788           {
;;;2789             HAL_TIM_IC_CaptureCallback(htim);
0012fc  4620              MOV      r0,r4
0012fe  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
001302  e005              B        |L1.4880|
                  |L1.4868|
;;;2790           }
;;;2791           /* Output compare event */
;;;2792           else
;;;2793           {
;;;2794             HAL_TIM_OC_DelayElapsedCallback(htim);
001304  4620              MOV      r0,r4
001306  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2795             HAL_TIM_PWM_PulseFinishedCallback(htim);
00130a  4620              MOV      r0,r4
00130c  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L1.4880|
;;;2796           }
;;;2797           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
001310  7625              STRB     r5,[r4,#0x18]
                  |L1.4882|
;;;2798         }
;;;2799       }
;;;2800     }
;;;2801     /* Capture compare 2 event */
;;;2802     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
001312  6820              LDR      r0,[r4,#0]
001314  6901              LDR      r1,[r0,#0x10]
001316  f0110f04          TST      r1,#4
00131a  d018              BEQ      |L1.4942|
;;;2803     {
;;;2804       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
00131c  68c1              LDR      r1,[r0,#0xc]
00131e  f0110f04          TST      r1,#4
001322  d014              BEQ      |L1.4942|
;;;2805       {
;;;2806         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
001324  f06f0104          MVN      r1,#4
001328  6101              STR      r1,[r0,#0x10]
;;;2807         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00132a  2002              MOVS     r0,#2
00132c  7620              STRB     r0,[r4,#0x18]
;;;2808         /* Input capture event */
;;;2809         if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
00132e  6820              LDR      r0,[r4,#0]
001330  6980              LDR      r0,[r0,#0x18]
001332  f4107f40          TST      r0,#0x300
001336  d003              BEQ      |L1.4928|
;;;2810         {          
;;;2811           HAL_TIM_IC_CaptureCallback(htim);
001338  4620              MOV      r0,r4
00133a  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
00133e  e005              B        |L1.4940|
                  |L1.4928|
;;;2812         }
;;;2813         /* Output compare event */
;;;2814         else
;;;2815         {
;;;2816           HAL_TIM_OC_DelayElapsedCallback(htim);
001340  4620              MOV      r0,r4
001342  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2817           HAL_TIM_PWM_PulseFinishedCallback(htim);
001346  4620              MOV      r0,r4
001348  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L1.4940|
;;;2818         }
;;;2819         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00134c  7625              STRB     r5,[r4,#0x18]
                  |L1.4942|
;;;2820       }
;;;2821     }
;;;2822     /* Capture compare 3 event */
;;;2823     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
00134e  6820              LDR      r0,[r4,#0]
001350  6901              LDR      r1,[r0,#0x10]
001352  f0110f08          TST      r1,#8
001356  d018              BEQ      |L1.5002|
;;;2824     {
;;;2825       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
001358  68c1              LDR      r1,[r0,#0xc]
00135a  f0110f08          TST      r1,#8
00135e  d014              BEQ      |L1.5002|
;;;2826       {
;;;2827         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
001360  f06f0108          MVN      r1,#8
001364  6101              STR      r1,[r0,#0x10]
;;;2828         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
001366  2004              MOVS     r0,#4
001368  7620              STRB     r0,[r4,#0x18]
;;;2829         /* Input capture event */
;;;2830         if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
00136a  6820              LDR      r0,[r4,#0]
00136c  69c0              LDR      r0,[r0,#0x1c]
00136e  f0100f03          TST      r0,#3
001372  d003              BEQ      |L1.4988|
;;;2831         {          
;;;2832           HAL_TIM_IC_CaptureCallback(htim);
001374  4620              MOV      r0,r4
001376  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
00137a  e005              B        |L1.5000|
                  |L1.4988|
;;;2833         }
;;;2834         /* Output compare event */
;;;2835         else
;;;2836         {
;;;2837           HAL_TIM_OC_DelayElapsedCallback(htim);
00137c  4620              MOV      r0,r4
00137e  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2838           HAL_TIM_PWM_PulseFinishedCallback(htim); 
001382  4620              MOV      r0,r4
001384  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L1.5000|
;;;2839         }
;;;2840         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
001388  7625              STRB     r5,[r4,#0x18]
                  |L1.5002|
;;;2841       }
;;;2842     }
;;;2843     /* Capture compare 4 event */
;;;2844     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
00138a  6820              LDR      r0,[r4,#0]
00138c  6901              LDR      r1,[r0,#0x10]
00138e  f0110f10          TST      r1,#0x10
001392  d018              BEQ      |L1.5062|
;;;2845     {
;;;2846       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
001394  68c1              LDR      r1,[r0,#0xc]
001396  f0110f10          TST      r1,#0x10
00139a  d014              BEQ      |L1.5062|
;;;2847       {
;;;2848         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
00139c  f06f0110          MVN      r1,#0x10
0013a0  6101              STR      r1,[r0,#0x10]
;;;2849         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
0013a2  2008              MOVS     r0,#8
0013a4  7620              STRB     r0,[r4,#0x18]
;;;2850         /* Input capture event */
;;;2851         if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
0013a6  6820              LDR      r0,[r4,#0]
0013a8  69c0              LDR      r0,[r0,#0x1c]
0013aa  f4107f40          TST      r0,#0x300
0013ae  d003              BEQ      |L1.5048|
;;;2852         {          
;;;2853           HAL_TIM_IC_CaptureCallback(htim);
0013b0  4620              MOV      r0,r4
0013b2  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0013b6  e005              B        |L1.5060|
                  |L1.5048|
;;;2854         }
;;;2855         /* Output compare event */
;;;2856         else
;;;2857         {
;;;2858           HAL_TIM_OC_DelayElapsedCallback(htim);
0013b8  4620              MOV      r0,r4
0013ba  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2859           HAL_TIM_PWM_PulseFinishedCallback(htim);
0013be  4620              MOV      r0,r4
0013c0  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L1.5060|
;;;2860         }
;;;2861         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0013c4  7625              STRB     r5,[r4,#0x18]
                  |L1.5062|
;;;2862       }
;;;2863     }
;;;2864     /* TIM Update event */
;;;2865     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
0013c6  6820              LDR      r0,[r4,#0]
0013c8  6901              LDR      r1,[r0,#0x10]
0013ca  f0110f01          TST      r1,#1
0013ce  d009              BEQ      |L1.5092|
;;;2866     {
;;;2867       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
0013d0  68c1              LDR      r1,[r0,#0xc]
0013d2  f0110f01          TST      r1,#1
0013d6  d005              BEQ      |L1.5092|
;;;2868       {
;;;2869         __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
0013d8  f06f0101          MVN      r1,#1
0013dc  6101              STR      r1,[r0,#0x10]
;;;2870         HAL_TIM_PeriodElapsedCallback(htim);
0013de  4620              MOV      r0,r4
0013e0  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
                  |L1.5092|
;;;2871       }
;;;2872     }
;;;2873     /* TIM Break input event */
;;;2874     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
0013e4  6820              LDR      r0,[r4,#0]
0013e6  6901              LDR      r1,[r0,#0x10]
0013e8  f0110f80          TST      r1,#0x80
0013ec  d009              BEQ      |L1.5122|
;;;2875     {
;;;2876       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
0013ee  68c1              LDR      r1,[r0,#0xc]
0013f0  f0110f80          TST      r1,#0x80
0013f4  d005              BEQ      |L1.5122|
;;;2877       {
;;;2878         __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
0013f6  f06f0180          MVN      r1,#0x80
0013fa  6101              STR      r1,[r0,#0x10]
;;;2879         HAL_TIMEx_BreakCallback(htim);
0013fc  4620              MOV      r0,r4
0013fe  f7fffffe          BL       HAL_TIMEx_BreakCallback
                  |L1.5122|
;;;2880       }
;;;2881     }
;;;2882     /* TIM Trigger detection event */
;;;2883     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
001402  6820              LDR      r0,[r4,#0]
001404  6901              LDR      r1,[r0,#0x10]
001406  f0110f40          TST      r1,#0x40
00140a  d009              BEQ      |L1.5152|
;;;2884     {
;;;2885       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
00140c  68c1              LDR      r1,[r0,#0xc]
00140e  f0110f40          TST      r1,#0x40
001412  d005              BEQ      |L1.5152|
;;;2886       {
;;;2887         __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
001414  f06f0140          MVN      r1,#0x40
001418  6101              STR      r1,[r0,#0x10]
;;;2888         HAL_TIM_TriggerCallback(htim);
00141a  4620              MOV      r0,r4
00141c  f7fffffe          BL       HAL_TIM_TriggerCallback
                  |L1.5152|
;;;2889       }
;;;2890     }
;;;2891     /* TIM commutation event */
;;;2892     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
001420  6820              LDR      r0,[r4,#0]
001422  6901              LDR      r1,[r0,#0x10]
001424  f0110f20          TST      r1,#0x20
001428  d00b              BEQ      |L1.5186|
;;;2893     {
;;;2894       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
00142a  68c1              LDR      r1,[r0,#0xc]
00142c  f0110f20          TST      r1,#0x20
001430  d007              BEQ      |L1.5186|
;;;2895       {
;;;2896         __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
001432  f06f0120          MVN      r1,#0x20
001436  6101              STR      r1,[r0,#0x10]
;;;2897         HAL_TIMEx_CommutationCallback(htim);
001438  4620              MOV      r0,r4
00143a  e8bd4070          POP      {r4-r6,lr}
00143e  f7ffbffe          B.W      HAL_TIMEx_CommutationCallback
                  |L1.5186|
;;;2898       }
;;;2899     }
;;;2900   }
001442  bd70              POP      {r4-r6,pc}
;;;2901   /**
                          ENDP

                  _Z17TIM_OC4_SetConfigP11TIM_TypeDefP18TIM_OC_InitTypeDef PROC ; TIM_OC4_SetConfig(TIM_TypeDef*, TIM_OC_InitTypeDef*)
;;;4862     */
;;;4863   static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
001444  b410              PUSH     {r4}
;;;4864   {
;;;4865     uint32_t tmpccmrx = 0;
;;;4866     uint32_t tmpccer = 0;
;;;4867     uint32_t tmpcr2 = 0;
;;;4868   
;;;4869     /* Disable the Channel 4: Reset the CC4E Bit */
;;;4870     TIMx->CCER &= ~TIM_CCER_CC4E;
001446  6a02              LDR      r2,[r0,#0x20]
001448  f4225280          BIC      r2,r2,#0x1000
00144c  6202              STR      r2,[r0,#0x20]
;;;4871     
;;;4872     /* Get the TIMx CCER register value */
;;;4873     tmpccer = TIMx->CCER;
00144e  f8d0c020          LDR      r12,[r0,#0x20]
;;;4874     /* Get the TIMx CR2 register value */
;;;4875     tmpcr2 = TIMx->CR2;
001452  6842              LDR      r2,[r0,#4]
;;;4876     
;;;4877     /* Get the TIMx CCMR2 register value */
;;;4878     tmpccmrx = TIMx->CCMR2;
001454  69c3              LDR      r3,[r0,#0x1c]
;;;4879       
;;;4880     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4881     tmpccmrx &= ~TIM_CCMR2_OC4M;
001456  f42343e0          BIC      r3,r3,#0x7000
;;;4882     tmpccmrx &= ~TIM_CCMR2_CC4S;
00145a  f4237340          BIC      r3,r3,#0x300
;;;4883     
;;;4884     /* Select the Output Compare Mode */
;;;4885     tmpccmrx |= (OC_Config->OCMode << 8);
00145e  680c              LDR      r4,[r1,#0]
001460  ea432304          ORR      r3,r3,r4,LSL #8
;;;4886     
;;;4887     /* Reset the Output Polarity level */
;;;4888     tmpccer &= ~TIM_CCER_CC4P;
001464  f42c5c00          BIC      r12,r12,#0x2000
;;;4889     /* Set the Output Compare Polarity */
;;;4890     tmpccer |= (OC_Config->OCPolarity << 12);
001468  688c              LDR      r4,[r1,#8]
00146a  ea4c3c04          ORR      r12,r12,r4,LSL #12
;;;4891      
;;;4892     /*if((TIMx == TIM1) || (TIMx == TIM8))*/
;;;4893     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
00146e  f1a04480          SUB      r4,r0,#0x40000000
001472  f5b43480          SUBS     r4,r4,#0x10000
001476  d002              BEQ      |L1.5246|
001478  f5b46480          SUBS     r4,r4,#0x400
00147c  d104              BNE      |L1.5256|
                  |L1.5246|
;;;4894     {
;;;4895       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4896       /* Reset the Output Compare IDLE State */
;;;4897       tmpcr2 &= ~TIM_CR2_OIS4;
00147e  f4224280          BIC      r2,r2,#0x4000
;;;4898       /* Set the Output Idle state */
;;;4899       tmpcr2 |= (OC_Config->OCIdleState << 6);
001482  694c              LDR      r4,[r1,#0x14]
001484  ea421284          ORR      r2,r2,r4,LSL #6
                  |L1.5256|
;;;4900     }
;;;4901     /* Write to TIMx CR2 */
;;;4902     TIMx->CR2 = tmpcr2;
001488  6042              STR      r2,[r0,#4]
;;;4903     
;;;4904     /* Write to TIMx CCMR2 */  
;;;4905     TIMx->CCMR2 = tmpccmrx;
00148a  61c3              STR      r3,[r0,#0x1c]
;;;4906       
;;;4907     /* Set the Capture Compare Register value */
;;;4908     TIMx->CCR4 = OC_Config->Pulse;
00148c  6849              LDR      r1,[r1,#4]
00148e  6401              STR      r1,[r0,#0x40]
;;;4909     
;;;4910     /* Write to TIMx CCER */
;;;4911     TIMx->CCER = tmpccer;
001490  f8c0c020          STR      r12,[r0,#0x20]
;;;4912   }
001494  bc10              POP      {r4}
001496  4770              BX       lr
;;;4913   
                          ENDP

                  _Z17TIM_OC3_SetConfigP11TIM_TypeDefP18TIM_OC_InitTypeDef PROC ; TIM_OC3_SetConfig(TIM_TypeDef*, TIM_OC_InitTypeDef*)
;;;4794     */
;;;4795   static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
001498  b410              PUSH     {r4}
;;;4796   {
;;;4797     uint32_t tmpccmrx = 0;
;;;4798     uint32_t tmpccer = 0;
;;;4799     uint32_t tmpcr2 = 0;   
;;;4800   
;;;4801     /* Disable the Channel 3: Reset the CC2E Bit */
;;;4802     TIMx->CCER &= ~TIM_CCER_CC3E;
00149a  6a02              LDR      r2,[r0,#0x20]
00149c  f4227280          BIC      r2,r2,#0x100
0014a0  6202              STR      r2,[r0,#0x20]
;;;4803     
;;;4804     /* Get the TIMx CCER register value */
;;;4805     tmpccer = TIMx->CCER;
0014a2  6a03              LDR      r3,[r0,#0x20]
;;;4806     /* Get the TIMx CR2 register value */
;;;4807     tmpcr2 = TIMx->CR2;
0014a4  6842              LDR      r2,[r0,#4]
;;;4808     
;;;4809     /* Get the TIMx CCMR2 register value */
;;;4810     tmpccmrx = TIMx->CCMR2;
0014a6  f8d0c01c          LDR      r12,[r0,#0x1c]
;;;4811       
;;;4812     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4813     tmpccmrx &= ~TIM_CCMR2_OC3M;
0014aa  f02c0c70          BIC      r12,r12,#0x70
;;;4814     tmpccmrx &= ~TIM_CCMR2_CC3S;  
0014ae  f02c0c03          BIC      r12,r12,#3
;;;4815     /* Select the Output Compare Mode */
;;;4816     tmpccmrx |= OC_Config->OCMode;
0014b2  680c              LDR      r4,[r1,#0]
0014b4  ea440c0c          ORR      r12,r4,r12
;;;4817     
;;;4818     /* Reset the Output Polarity level */
;;;4819     tmpccer &= ~TIM_CCER_CC3P;
0014b8  f4237300          BIC      r3,r3,#0x200
;;;4820     /* Set the Output Compare Polarity */
;;;4821     tmpccer |= (OC_Config->OCPolarity << 8);
0014bc  688c              LDR      r4,[r1,#8]
0014be  ea432304          ORR      r3,r3,r4,LSL #8
;;;4822       
;;;4823     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
0014c2  f1a04480          SUB      r4,r0,#0x40000000
0014c6  f5b43480          SUBS     r4,r4,#0x10000
0014ca  d002              BEQ      |L1.5330|
0014cc  f5b46480          SUBS     r4,r4,#0x400
0014d0  d110              BNE      |L1.5364|
                  |L1.5330|
;;;4824     {
;;;4825       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4826       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;4827       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4828       
;;;4829       /* Reset the Output N Polarity level */
;;;4830       tmpccer &= ~TIM_CCER_CC3NP;
0014d2  f4236300          BIC      r3,r3,#0x800
;;;4831       /* Set the Output N Polarity */
;;;4832       tmpccer |= (OC_Config->OCNPolarity << 8);
0014d6  68cc              LDR      r4,[r1,#0xc]
0014d8  ea432304          ORR      r3,r3,r4,LSL #8
;;;4833       /* Reset the Output N State */
;;;4834       tmpccer &= ~TIM_CCER_CC3NE;
0014dc  f4236380          BIC      r3,r3,#0x400
;;;4835       
;;;4836       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4837       tmpcr2 &= ~TIM_CR2_OIS3;
0014e0  f4225280          BIC      r2,r2,#0x1000
;;;4838       tmpcr2 &= ~TIM_CR2_OIS3N;
0014e4  f4225200          BIC      r2,r2,#0x2000
;;;4839       /* Set the Output Idle state */
;;;4840       tmpcr2 |= (OC_Config->OCIdleState << 4);
0014e8  694c              LDR      r4,[r1,#0x14]
0014ea  ea421204          ORR      r2,r2,r4,LSL #4
;;;4841       /* Set the Output N Idle state */
;;;4842       tmpcr2 |= (OC_Config->OCNIdleState << 4);
0014ee  698c              LDR      r4,[r1,#0x18]
0014f0  ea421204          ORR      r2,r2,r4,LSL #4
                  |L1.5364|
;;;4843     }
;;;4844     /* Write to TIMx CR2 */
;;;4845     TIMx->CR2 = tmpcr2;
0014f4  6042              STR      r2,[r0,#4]
;;;4846     
;;;4847     /* Write to TIMx CCMR2 */
;;;4848     TIMx->CCMR2 = tmpccmrx;
0014f6  f8c0c01c          STR      r12,[r0,#0x1c]
;;;4849     
;;;4850     /* Set the Capture Compare Register value */
;;;4851     TIMx->CCR3 = OC_Config->Pulse;
0014fa  6849              LDR      r1,[r1,#4]
0014fc  63c1              STR      r1,[r0,#0x3c]
;;;4852     
;;;4853     /* Write to TIMx CCER */
;;;4854     TIMx->CCER = tmpccer;
0014fe  6203              STR      r3,[r0,#0x20]
;;;4855   }
001500  bc10              POP      {r4}
001502  4770              BX       lr
;;;4856   
                          ENDP

                  TIM_OC2_SetConfig PROC
;;;4517     */
;;;4518   void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
001504  b410              PUSH     {r4}
;;;4519   {
;;;4520     uint32_t tmpccmrx = 0;
;;;4521     uint32_t tmpccer = 0;
;;;4522     uint32_t tmpcr2 = 0;
;;;4523      
;;;4524     /* Disable the Channel 2: Reset the CC2E Bit */
;;;4525     TIMx->CCER &= ~TIM_CCER_CC2E;
001506  6a02              LDR      r2,[r0,#0x20]
001508  f0220210          BIC      r2,r2,#0x10
00150c  6202              STR      r2,[r0,#0x20]
;;;4526     
;;;4527     /* Get the TIMx CCER register value */  
;;;4528     tmpccer = TIMx->CCER;
00150e  6a03              LDR      r3,[r0,#0x20]
;;;4529     /* Get the TIMx CR2 register value */
;;;4530     tmpcr2 = TIMx->CR2;
001510  6842              LDR      r2,[r0,#4]
;;;4531     
;;;4532     /* Get the TIMx CCMR1 register value */
;;;4533     tmpccmrx = TIMx->CCMR1;
001512  f8d0c018          LDR      r12,[r0,#0x18]
;;;4534       
;;;4535     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4536     tmpccmrx &= ~TIM_CCMR1_OC2M;
001516  f42c4ce0          BIC      r12,r12,#0x7000
;;;4537     tmpccmrx &= ~TIM_CCMR1_CC2S;
00151a  f42c7c40          BIC      r12,r12,#0x300
;;;4538     
;;;4539     /* Select the Output Compare Mode */
;;;4540     tmpccmrx |= (OC_Config->OCMode << 8);
00151e  680c              LDR      r4,[r1,#0]
001520  ea4c2c04          ORR      r12,r12,r4,LSL #8
;;;4541     
;;;4542     /* Reset the Output Polarity level */
;;;4543     tmpccer &= ~TIM_CCER_CC2P;
001524  f0230320          BIC      r3,r3,#0x20
;;;4544     /* Set the Output Compare Polarity */
;;;4545     tmpccer |= (OC_Config->OCPolarity << 4);
001528  688c              LDR      r4,[r1,#8]
00152a  ea431304          ORR      r3,r3,r4,LSL #4
;;;4546       
;;;4547     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
00152e  f1a04480          SUB      r4,r0,#0x40000000
001532  f5b43480          SUBS     r4,r4,#0x10000
001536  d002              BEQ      |L1.5438|
001538  f5b46480          SUBS     r4,r4,#0x400
00153c  d110              BNE      |L1.5472|
                  |L1.5438|
;;;4548     {
;;;4549       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4550       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;4551       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4552       
;;;4553       /* Reset the Output N Polarity level */
;;;4554       tmpccer &= ~TIM_CCER_CC2NP;
00153e  f0230380          BIC      r3,r3,#0x80
;;;4555       /* Set the Output N Polarity */
;;;4556       tmpccer |= (OC_Config->OCNPolarity << 4);
001542  68cc              LDR      r4,[r1,#0xc]
001544  ea431304          ORR      r3,r3,r4,LSL #4
;;;4557       /* Reset the Output N State */
;;;4558       tmpccer &= ~TIM_CCER_CC2NE;
001548  f0230340          BIC      r3,r3,#0x40
;;;4559       
;;;4560       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4561       tmpcr2 &= ~TIM_CR2_OIS2;
00154c  f4226280          BIC      r2,r2,#0x400
;;;4562       tmpcr2 &= ~TIM_CR2_OIS2N;
001550  f4226200          BIC      r2,r2,#0x800
;;;4563       /* Set the Output Idle state */
;;;4564       tmpcr2 |= (OC_Config->OCIdleState << 2);
001554  694c              LDR      r4,[r1,#0x14]
001556  ea420284          ORR      r2,r2,r4,LSL #2
;;;4565       /* Set the Output N Idle state */
;;;4566       tmpcr2 |= (OC_Config->OCNIdleState << 2);
00155a  698c              LDR      r4,[r1,#0x18]
00155c  ea420284          ORR      r2,r2,r4,LSL #2
                  |L1.5472|
;;;4567     }
;;;4568     /* Write to TIMx CR2 */
;;;4569     TIMx->CR2 = tmpcr2;
001560  6042              STR      r2,[r0,#4]
;;;4570     
;;;4571     /* Write to TIMx CCMR1 */
;;;4572     TIMx->CCMR1 = tmpccmrx;
001562  f8c0c018          STR      r12,[r0,#0x18]
;;;4573     
;;;4574     /* Set the Capture Compare Register value */
;;;4575     TIMx->CCR2 = OC_Config->Pulse;
001566  6849              LDR      r1,[r1,#4]
001568  6381              STR      r1,[r0,#0x38]
;;;4576     
;;;4577     /* Write to TIMx CCER */
;;;4578     TIMx->CCER = tmpccer;
00156a  6203              STR      r3,[r0,#0x20]
;;;4579   }
00156c  bc10              POP      {r4}
00156e  4770              BX       lr
;;;4580   
                          ENDP

                  _Z17TIM_OC1_SetConfigP11TIM_TypeDefP18TIM_OC_InitTypeDef PROC ; TIM_OC1_SetConfig(TIM_TypeDef*, TIM_OC_InitTypeDef*)
;;;4729     */
;;;4730   static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
001570  b410              PUSH     {r4}
;;;4731   {
;;;4732     uint32_t tmpccmrx = 0;
;;;4733     uint32_t tmpccer = 0;
;;;4734     uint32_t tmpcr2 = 0;  
;;;4735   
;;;4736     /* Disable the Channel 1: Reset the CC1E Bit */
;;;4737     TIMx->CCER &= ~TIM_CCER_CC1E;
001572  6a02              LDR      r2,[r0,#0x20]
001574  f0220201          BIC      r2,r2,#1
001578  6202              STR      r2,[r0,#0x20]
;;;4738     
;;;4739     /* Get the TIMx CCER register value */
;;;4740     tmpccer = TIMx->CCER;
00157a  6a03              LDR      r3,[r0,#0x20]
;;;4741     /* Get the TIMx CR2 register value */
;;;4742     tmpcr2 = TIMx->CR2;
00157c  6842              LDR      r2,[r0,#4]
;;;4743     
;;;4744     /* Get the TIMx CCMR1 register value */
;;;4745     tmpccmrx = TIMx->CCMR1;
00157e  f8d0c018          LDR      r12,[r0,#0x18]
;;;4746       
;;;4747     /* Reset the Output Compare Mode Bits */
;;;4748     tmpccmrx &= ~TIM_CCMR1_OC1M;
001582  f02c0c70          BIC      r12,r12,#0x70
;;;4749     tmpccmrx &= ~TIM_CCMR1_CC1S;
001586  f02c0c03          BIC      r12,r12,#3
;;;4750     /* Select the Output Compare Mode */
;;;4751     tmpccmrx |= OC_Config->OCMode;
00158a  680c              LDR      r4,[r1,#0]
00158c  ea440c0c          ORR      r12,r4,r12
;;;4752     
;;;4753     /* Reset the Output Polarity level */
;;;4754     tmpccer &= ~TIM_CCER_CC1P;
001590  f0230302          BIC      r3,r3,#2
;;;4755     /* Set the Output Compare Polarity */
;;;4756     tmpccer |= OC_Config->OCPolarity;
001594  688c              LDR      r4,[r1,#8]
001596  4323              ORRS     r3,r3,r4
;;;4757   
;;;4758       
;;;4759     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
001598  f1a04480          SUB      r4,r0,#0x40000000
00159c  f5b43480          SUBS     r4,r4,#0x10000
0015a0  d002              BEQ      |L1.5544|
0015a2  f5b46480          SUBS     r4,r4,#0x400
0015a6  d10d              BNE      |L1.5572|
                  |L1.5544|
;;;4760     {   
;;;4761       /* Reset the Output N Polarity level */
;;;4762       tmpccer &= ~TIM_CCER_CC1NP;
0015a8  f0230308          BIC      r3,r3,#8
;;;4763       /* Set the Output N Polarity */
;;;4764       tmpccer |= OC_Config->OCNPolarity;
0015ac  68cc              LDR      r4,[r1,#0xc]
0015ae  4323              ORRS     r3,r3,r4
;;;4765       /* Reset the Output N State */
;;;4766       tmpccer &= ~TIM_CCER_CC1NE;
0015b0  f0230304          BIC      r3,r3,#4
;;;4767       
;;;4768       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4769       tmpcr2 &= ~TIM_CR2_OIS1;
0015b4  f4227280          BIC      r2,r2,#0x100
;;;4770       tmpcr2 &= ~TIM_CR2_OIS1N;
0015b8  f4227200          BIC      r2,r2,#0x200
;;;4771       /* Set the Output Idle state */
;;;4772       tmpcr2 |= OC_Config->OCIdleState;
0015bc  694c              LDR      r4,[r1,#0x14]
0015be  4322              ORRS     r2,r2,r4
;;;4773       /* Set the Output N Idle state */
;;;4774       tmpcr2 |= OC_Config->OCNIdleState;
0015c0  698c              LDR      r4,[r1,#0x18]
0015c2  4322              ORRS     r2,r2,r4
                  |L1.5572|
;;;4775     }
;;;4776     /* Write to TIMx CR2 */
;;;4777     TIMx->CR2 = tmpcr2;
0015c4  6042              STR      r2,[r0,#4]
;;;4778     
;;;4779     /* Write to TIMx CCMR1 */
;;;4780     TIMx->CCMR1 = tmpccmrx;
0015c6  f8c0c018          STR      r12,[r0,#0x18]
;;;4781     
;;;4782     /* Set the Capture Compare Register value */
;;;4783     TIMx->CCR1 = OC_Config->Pulse;
0015ca  6849              LDR      r1,[r1,#4]
0015cc  6341              STR      r1,[r0,#0x34]
;;;4784     
;;;4785     /* Write to TIMx CCER */
;;;4786     TIMx->CCER = tmpccer;  
0015ce  6203              STR      r3,[r0,#0x20]
;;;4787   } 
0015d0  bc10              POP      {r4}
0015d2  4770              BX       lr
;;;4788   
                          ENDP

                  HAL_TIM_OC_ConfigChannel PROC
;;;2937     */
;;;2938   HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
0015d4  b570              PUSH     {r4-r6,lr}
;;;2939   {
0015d6  4604              MOV      r4,r0
;;;2940     /* Check the parameters */ 
;;;2941     assert_param(IS_TIM_CHANNELS(Channel)); 
;;;2942     assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
;;;2943     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;2944     assert_param(IS_TIM_OCN_POLARITY(sConfig->OCNPolarity));
;;;2945     assert_param(IS_TIM_OCNIDLE_STATE(sConfig->OCNIdleState));
;;;2946     assert_param(IS_TIM_OCIDLE_STATE(sConfig->OCIdleState));
;;;2947     
;;;2948     /* Check input state */
;;;2949     __HAL_LOCK(htim); 
0015d8  f8940038          LDRB     r0,[r4,#0x38]
0015dc  2801              CMP      r0,#1
0015de  d00d              BEQ      |L1.5628|
0015e0  2501              MOVS     r5,#1
0015e2  f8845038          STRB     r5,[r4,#0x38]
;;;2950     
;;;2951     htim->State = HAL_TIM_STATE_BUSY;
0015e6  2002              MOVS     r0,#2
0015e8  f8840039          STRB     r0,[r4,#0x39]
0015ec  b142              CBZ      r2,|L1.5632|
;;;2952     
;;;2953     switch (Channel)
0015ee  2a04              CMP      r2,#4
0015f0  d00a              BEQ      |L1.5640|
0015f2  2a08              CMP      r2,#8
0015f4  d00c              BEQ      |L1.5648|
0015f6  2a0c              CMP      r2,#0xc
0015f8  d111              BNE      |L1.5662|
0015fa  e00d              B        |L1.5656|
                  |L1.5628|
0015fc  2002              MOVS     r0,#2                 ;2949
;;;2954     {
;;;2955       case TIM_CHANNEL_1:
;;;2956       {
;;;2957         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;2958         /* Configure the TIM Channel 1 in Output Compare */
;;;2959         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;2960       }
;;;2961       break;
;;;2962       
;;;2963       case TIM_CHANNEL_2:
;;;2964       {
;;;2965         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2966         /* Configure the TIM Channel 2 in Output Compare */
;;;2967         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;2968       }
;;;2969       break;
;;;2970       
;;;2971       case TIM_CHANNEL_3:
;;;2972       {
;;;2973          assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;2974         /* Configure the TIM Channel 3 in Output Compare */
;;;2975         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;2976       }
;;;2977       break;
;;;2978       
;;;2979       case TIM_CHANNEL_4:
;;;2980       {
;;;2981         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;2982         /* Configure the TIM Channel 4 in Output Compare */
;;;2983         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;2984       }
;;;2985       break;
;;;2986       
;;;2987       default:
;;;2988       break;    
;;;2989     }
;;;2990     htim->State = HAL_TIM_STATE_READY;
;;;2991     
;;;2992     __HAL_UNLOCK(htim); 
;;;2993     
;;;2994     return HAL_OK;
;;;2995   }
0015fe  bd70              POP      {r4-r6,pc}
                  |L1.5632|
001600  6820              LDR      r0,[r4,#0]            ;2959
001602  f7fffffe          BL       _Z17TIM_OC1_SetConfigP11TIM_TypeDefP18TIM_OC_InitTypeDef ; TIM_OC1_SetConfig(TIM_TypeDef*, TIM_OC_InitTypeDef*)
001606  e00a              B        |L1.5662|
                  |L1.5640|
001608  6820              LDR      r0,[r4,#0]            ;2967
00160a  f7fffffe          BL       TIM_OC2_SetConfig
00160e  e006              B        |L1.5662|
                  |L1.5648|
001610  6820              LDR      r0,[r4,#0]            ;2975
001612  f7fffffe          BL       _Z17TIM_OC3_SetConfigP11TIM_TypeDefP18TIM_OC_InitTypeDef ; TIM_OC3_SetConfig(TIM_TypeDef*, TIM_OC_InitTypeDef*)
001616  e002              B        |L1.5662|
                  |L1.5656|
001618  6820              LDR      r0,[r4,#0]            ;2983
00161a  f7fffffe          BL       _Z17TIM_OC4_SetConfigP11TIM_TypeDefP18TIM_OC_InitTypeDef ; TIM_OC4_SetConfig(TIM_TypeDef*, TIM_OC_InitTypeDef*)
                  |L1.5662|
00161e  f8845039          STRB     r5,[r4,#0x39]         ;2990
001622  2000              MOVS     r0,#0                 ;2992
001624  f8840038          STRB     r0,[r4,#0x38]         ;2992
001628  bd70              POP      {r4-r6,pc}
;;;2996   
                          ENDP

                  _Z17TIM_TI4_SetConfigP11TIM_TypeDefjjj PROC ; TIM_TI4_SetConfig(TIM_TypeDef*, unsigned, unsigned, unsigned)
;;;5231     */
;;;5232   static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
00162a  b410              PUSH     {r4}
;;;5233                          uint32_t TIM_ICFilter)
;;;5234   {
;;;5235     uint32_t tmpccmr2 = 0;
;;;5236     uint32_t tmpccer = 0;
;;;5237   
;;;5238     /* Disable the Channel 4: Reset the CC4E Bit */
;;;5239     TIMx->CCER &= ~TIM_CCER_CC4E;
00162c  f8d0c020          LDR      r12,[r0,#0x20]
001630  f42c5c80          BIC      r12,r12,#0x1000
001634  f8c0c020          STR      r12,[r0,#0x20]
;;;5240     tmpccmr2 = TIMx->CCMR2;
001638  69c4              LDR      r4,[r0,#0x1c]
;;;5241     tmpccer = TIMx->CCER;
00163a  f8d0c020          LDR      r12,[r0,#0x20]
;;;5242   
;;;5243     /* Select the Input */
;;;5244     tmpccmr2 &= ~TIM_CCMR2_CC4S;
00163e  f4247440          BIC      r4,r4,#0x300
;;;5245     tmpccmr2 |= (TIM_ICSelection << 8);
001642  ea442202          ORR      r2,r4,r2,LSL #8
;;;5246   
;;;5247     /* Set the filter */
;;;5248     tmpccmr2 &= ~TIM_CCMR2_IC4F;
001646  f4224270          BIC      r2,r2,#0xf000
;;;5249     tmpccmr2 |= ((TIM_ICFilter << 12) & TIM_CCMR2_IC4F);
00164a  f44f4470          MOV      r4,#0xf000
00164e  ea043303          AND      r3,r4,r3,LSL #12
001652  431a              ORRS     r2,r2,r3
;;;5250   
;;;5251     /* Select the Polarity and set the CC4E Bit */
;;;5252     tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
001654  f42c4320          BIC      r3,r12,#0xa000
;;;5253     tmpccer |= ((TIM_ICPolarity << 12) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
001658  f44f4c20          MOV      r12,#0xa000
00165c  ea0c3101          AND      r1,r12,r1,LSL #12
001660  4319              ORRS     r1,r1,r3
;;;5254   
;;;5255     /* Write to TIMx CCMR2 and CCER registers */
;;;5256     TIMx->CCMR2 = tmpccmr2;
001662  61c2              STR      r2,[r0,#0x1c]
;;;5257     TIMx->CCER = tmpccer ;
001664  6201              STR      r1,[r0,#0x20]
;;;5258   }
001666  bc10              POP      {r4}
001668  4770              BX       lr
;;;5259   
                          ENDP

                  _Z17TIM_TI3_SetConfigP11TIM_TypeDefjjj PROC ; TIM_TI3_SetConfig(TIM_TypeDef*, unsigned, unsigned, unsigned)
;;;5183     */
;;;5184   static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
00166a  b410              PUSH     {r4}
;;;5185                          uint32_t TIM_ICFilter)
;;;5186   {
;;;5187     uint32_t tmpccmr2 = 0;
;;;5188     uint32_t tmpccer = 0;
;;;5189   
;;;5190     /* Disable the Channel 3: Reset the CC3E Bit */
;;;5191     TIMx->CCER &= ~TIM_CCER_CC3E;
00166c  f8d0c020          LDR      r12,[r0,#0x20]
001670  f42c7c80          BIC      r12,r12,#0x100
001674  f8c0c020          STR      r12,[r0,#0x20]
;;;5192     tmpccmr2 = TIMx->CCMR2;
001678  69c4              LDR      r4,[r0,#0x1c]
;;;5193     tmpccer = TIMx->CCER;
00167a  f8d0c020          LDR      r12,[r0,#0x20]
;;;5194   
;;;5195     /* Select the Input */
;;;5196     tmpccmr2 &= ~TIM_CCMR2_CC3S;
00167e  f0240403          BIC      r4,r4,#3
;;;5197     tmpccmr2 |= TIM_ICSelection;
001682  4322              ORRS     r2,r2,r4
;;;5198   
;;;5199     /* Set the filter */
;;;5200     tmpccmr2 &= ~TIM_CCMR2_IC3F;
001684  f02202f0          BIC      r2,r2,#0xf0
;;;5201     tmpccmr2 |= ((TIM_ICFilter << 4) & TIM_CCMR2_IC3F);
001688  24f0              MOVS     r4,#0xf0
00168a  ea041303          AND      r3,r4,r3,LSL #4
00168e  431a              ORRS     r2,r2,r3
;;;5202   
;;;5203     /* Select the Polarity and set the CC3E Bit */
;;;5204     tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
001690  f42c6320          BIC      r3,r12,#0xa00
;;;5205     tmpccer |= ((TIM_ICPolarity << 8) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
001694  f44f6c20          MOV      r12,#0xa00
001698  ea0c2101          AND      r1,r12,r1,LSL #8
00169c  4319              ORRS     r1,r1,r3
;;;5206   
;;;5207     /* Write to TIMx CCMR2 and CCER registers */
;;;5208     TIMx->CCMR2 = tmpccmr2;
00169e  61c2              STR      r2,[r0,#0x1c]
;;;5209     TIMx->CCER = tmpccer;
0016a0  6201              STR      r1,[r0,#0x20]
;;;5210   }
0016a2  bc10              POP      {r4}
0016a4  4770              BX       lr
;;;5211   
                          ENDP

                  _Z17TIM_TI2_SetConfigP11TIM_TypeDefjjj PROC ; TIM_TI2_SetConfig(TIM_TypeDef*, unsigned, unsigned, unsigned)
;;;5100     */
;;;5101   static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
0016a6  b410              PUSH     {r4}
;;;5102                          uint32_t TIM_ICFilter)
;;;5103   {
;;;5104     uint32_t tmpccmr1 = 0;
;;;5105     uint32_t tmpccer = 0;
;;;5106   
;;;5107     /* Disable the Channel 2: Reset the CC2E Bit */
;;;5108     TIMx->CCER &= ~TIM_CCER_CC2E;
0016a8  f8d0c020          LDR      r12,[r0,#0x20]
0016ac  f02c0c10          BIC      r12,r12,#0x10
0016b0  f8c0c020          STR      r12,[r0,#0x20]
;;;5109     tmpccmr1 = TIMx->CCMR1;
0016b4  6984              LDR      r4,[r0,#0x18]
;;;5110     tmpccer = TIMx->CCER;
0016b6  f8d0c020          LDR      r12,[r0,#0x20]
;;;5111     
;;;5112     /* Select the Input */
;;;5113     tmpccmr1 &= ~TIM_CCMR1_CC2S;
0016ba  f4247440          BIC      r4,r4,#0x300
;;;5114     tmpccmr1 |= (TIM_ICSelection << 8);
0016be  ea442202          ORR      r2,r4,r2,LSL #8
;;;5115     
;;;5116     /* Set the filter */
;;;5117     tmpccmr1 &= ~TIM_CCMR1_IC2F;
0016c2  f4224270          BIC      r2,r2,#0xf000
;;;5118     tmpccmr1 |= ((TIM_ICFilter << 12) & TIM_CCMR1_IC2F);
0016c6  f44f4470          MOV      r4,#0xf000
0016ca  ea043303          AND      r3,r4,r3,LSL #12
0016ce  431a              ORRS     r2,r2,r3
;;;5119   
;;;5120     /* Select the Polarity and set the CC2E Bit */
;;;5121     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
0016d0  f02c03a0          BIC      r3,r12,#0xa0
;;;5122     tmpccer |= ((TIM_ICPolarity << 4) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
0016d4  f04f0ca0          MOV      r12,#0xa0
0016d8  ea0c1101          AND      r1,r12,r1,LSL #4
0016dc  4319              ORRS     r1,r1,r3
;;;5123   
;;;5124     /* Write to TIMx CCMR1 and CCER registers */
;;;5125     TIMx->CCMR1 = tmpccmr1 ;
0016de  6182              STR      r2,[r0,#0x18]
;;;5126     TIMx->CCER = tmpccer;
0016e0  6201              STR      r1,[r0,#0x20]
;;;5127   }
0016e2  bc10              POP      {r4}
0016e4  4770              BX       lr
;;;5128   
                          ENDP

                  TIM_TI1_SetConfig PROC
;;;4475     */
;;;4476   void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
0016e6  b430              PUSH     {r4,r5}
;;;4477                          uint32_t TIM_ICFilter)
;;;4478   {
;;;4479     uint32_t tmpccmr1 = 0;
;;;4480     uint32_t tmpccer = 0;
;;;4481     
;;;4482     /* Disable the Channel 1: Reset the CC1E Bit */
;;;4483     TIMx->CCER &= ~TIM_CCER_CC1E;
0016e8  f8d0c020          LDR      r12,[r0,#0x20]
0016ec  f02c0c01          BIC      r12,r12,#1
0016f0  f8c0c020          STR      r12,[r0,#0x20]
;;;4484     tmpccmr1 = TIMx->CCMR1;
0016f4  f8d0c018          LDR      r12,[r0,#0x18]
;;;4485     tmpccer = TIMx->CCER;
0016f8  6a04              LDR      r4,[r0,#0x20]
;;;4486   
;;;4487     /* Select the Input */
;;;4488     if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
0016fa  f1a04580          SUB      r5,r0,#0x40000000
0016fe  f5b53580          SUBS     r5,r5,#0x10000
001702  d028              BEQ      |L1.5974|
001704  f1b04f80          CMP      r0,#0x40000000
001708  d025              BEQ      |L1.5974|
00170a  f515457c          ADDS     r5,r5,#0xfc00
00170e  d022              BEQ      |L1.5974|
001710  f5b56580          SUBS     r5,r5,#0x400
001714  d01f              BEQ      |L1.5974|
001716  f5b56580          SUBS     r5,r5,#0x400
00171a  d01c              BEQ      |L1.5974|
00171c  f5b54578          SUBS     r5,r5,#0xf800
001720  d019              BEQ      |L1.5974|
001722  f5b55570          SUBS     r5,r5,#0x3c00
001726  d016              BEQ      |L1.5974|
001728  f5153594          ADDS     r5,r5,#0x12800
00172c  d013              BEQ      |L1.5974|
;;;4489     {
;;;4490       tmpccmr1 &= ~TIM_CCMR1_CC1S;
;;;4491       tmpccmr1 |= TIM_ICSelection;
;;;4492     } 
;;;4493     else
;;;4494     {
;;;4495       tmpccmr1 &= ~TIM_CCMR1_CC1S;
00172e  f02c0203          BIC      r2,r12,#3
;;;4496       tmpccmr1 |= TIM_CCMR1_CC1S_0;
001732  f0420201          ORR      r2,r2,#1
                  |L1.5942|
;;;4497     }
;;;4498   
;;;4499     /* Set the filter */
;;;4500     tmpccmr1 &= ~TIM_CCMR1_IC1F;
001736  f02202f0          BIC      r2,r2,#0xf0
;;;4501     tmpccmr1 |= ((TIM_ICFilter << 4) & TIM_CCMR1_IC1F);
00173a  f04f0cf0          MOV      r12,#0xf0
00173e  ea0c1303          AND      r3,r12,r3,LSL #4
001742  431a              ORRS     r2,r2,r3
;;;4502   
;;;4503     /* Select the Polarity and set the CC1E Bit */
;;;4504     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
001744  f024030a          BIC      r3,r4,#0xa
;;;4505     tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
001748  f001010a          AND      r1,r1,#0xa
00174c  4319              ORRS     r1,r1,r3
;;;4506   
;;;4507     /* Write to TIMx CCMR1 and CCER registers */
;;;4508     TIMx->CCMR1 = tmpccmr1;
00174e  6182              STR      r2,[r0,#0x18]
;;;4509     TIMx->CCER = tmpccer;
001750  6201              STR      r1,[r0,#0x20]
;;;4510   }
001752  bc30              POP      {r4,r5}
001754  4770              BX       lr
                  |L1.5974|
001756  f02c0c03          BIC      r12,r12,#3            ;4490
00175a  ea4c0202          ORR      r2,r12,r2             ;4491
00175e  e7ea              B        |L1.5942|
;;;4511   
                          ENDP

                  HAL_TIM_IC_ConfigChannel PROC
;;;3010     */
;;;3011   HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
001760  b570              PUSH     {r4-r6,lr}
;;;3012   {
001762  4604              MOV      r4,r0
001764  460d              MOV      r5,r1
;;;3013     /* Check the parameters */
;;;3014     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3015     assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
;;;3016     assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
;;;3017     assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
;;;3018     assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
;;;3019     
;;;3020     __HAL_LOCK(htim);
001766  f8940038          LDRB     r0,[r4,#0x38]
00176a  2801              CMP      r0,#1
00176c  d021              BEQ      |L1.6066|
00176e  2601              MOVS     r6,#1
001770  f8846038          STRB     r6,[r4,#0x38]
;;;3021     
;;;3022     htim->State = HAL_TIM_STATE_BUSY;
001774  2002              MOVS     r0,#2
001776  f8840039          STRB     r0,[r4,#0x39]
00177a  b1e2              CBZ      r2,|L1.6070|
;;;3023     
;;;3024     if (Channel == TIM_CHANNEL_1)
;;;3025     {
;;;3026       /* TI1 Configuration */
;;;3027       TIM_TI1_SetConfig(htim->Instance,
;;;3028                  sConfig->ICPolarity,
;;;3029                  sConfig->ICSelection,
;;;3030                  sConfig->ICFilter);
;;;3031                  
;;;3032       /* Reset the IC1PSC Bits */
;;;3033       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3034   
;;;3035       /* Set the IC1PSC value */
;;;3036       htim->Instance->CCMR1 |= sConfig->ICPrescaler;
;;;3037     }
;;;3038     else if (Channel == TIM_CHANNEL_2)
00177c  2a04              CMP      r2,#4
00177e  d02b              BEQ      |L1.6104|
;;;3039     {
;;;3040       /* TI2 Configuration */
;;;3041       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3042       
;;;3043       TIM_TI2_SetConfig(htim->Instance, 
;;;3044                         sConfig->ICPolarity,
;;;3045                         sConfig->ICSelection,
;;;3046                         sConfig->ICFilter);
;;;3047                  
;;;3048       /* Reset the IC2PSC Bits */
;;;3049       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3050   
;;;3051       /* Set the IC2PSC value */
;;;3052       htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8);
;;;3053     }
;;;3054     else if (Channel == TIM_CHANNEL_3)
001780  2a08              CMP      r2,#8
001782  d03b              BEQ      |L1.6140|
;;;3055     {
;;;3056       /* TI3 Configuration */
;;;3057       assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3058       
;;;3059       TIM_TI3_SetConfig(htim->Instance,  
;;;3060                  sConfig->ICPolarity,
;;;3061                  sConfig->ICSelection,
;;;3062                  sConfig->ICFilter);
;;;3063                  
;;;3064       /* Reset the IC3PSC Bits */
;;;3065       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
;;;3066   
;;;3067       /* Set the IC3PSC value */
;;;3068       htim->Instance->CCMR2 |= sConfig->ICPrescaler;
;;;3069     }
;;;3070     else
;;;3071     {
;;;3072       /* TI4 Configuration */
;;;3073       assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3074       
;;;3075       TIM_TI4_SetConfig(htim->Instance, 
001784  68eb              LDR      r3,[r5,#0xc]
001786  686a              LDR      r2,[r5,#4]
001788  6829              LDR      r1,[r5,#0]
00178a  6820              LDR      r0,[r4,#0]
00178c  f7fffffe          BL       _Z17TIM_TI4_SetConfigP11TIM_TypeDefjjj ; TIM_TI4_SetConfig(TIM_TypeDef*, unsigned, unsigned, unsigned)
;;;3076                  sConfig->ICPolarity,
;;;3077                  sConfig->ICSelection,
;;;3078                  sConfig->ICFilter);
;;;3079                  
;;;3080       /* Reset the IC4PSC Bits */
;;;3081       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
001790  6820              LDR      r0,[r4,#0]
001792  69c1              LDR      r1,[r0,#0x1c]
001794  f4216140          BIC      r1,r1,#0xc00
001798  61c1              STR      r1,[r0,#0x1c]
;;;3082   
;;;3083       /* Set the IC4PSC value */
;;;3084       htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8);
00179a  6820              LDR      r0,[r4,#0]
00179c  69c1              LDR      r1,[r0,#0x1c]
00179e  68aa              LDR      r2,[r5,#8]
0017a0  ea412102          ORR      r1,r1,r2,LSL #8
0017a4  61c1              STR      r1,[r0,#0x1c]
                  |L1.6054|
;;;3085     }
;;;3086     
;;;3087     htim->State = HAL_TIM_STATE_READY;
0017a6  f8846039          STRB     r6,[r4,#0x39]
;;;3088       
;;;3089     __HAL_UNLOCK(htim);
0017aa  2000              MOVS     r0,#0
0017ac  f8840038          STRB     r0,[r4,#0x38]
;;;3090     
;;;3091     return HAL_OK; 
;;;3092   }
0017b0  bd70              POP      {r4-r6,pc}
                  |L1.6066|
0017b2  2002              MOVS     r0,#2                 ;3020
0017b4  bd70              POP      {r4-r6,pc}
                  |L1.6070|
0017b6  68eb              LDR      r3,[r5,#0xc]          ;3027
0017b8  686a              LDR      r2,[r5,#4]            ;3027
0017ba  6829              LDR      r1,[r5,#0]            ;3027
0017bc  6820              LDR      r0,[r4,#0]            ;3027
0017be  f7fffffe          BL       TIM_TI1_SetConfig
0017c2  6820              LDR      r0,[r4,#0]            ;3033
0017c4  6981              LDR      r1,[r0,#0x18]         ;3033
0017c6  f021010c          BIC      r1,r1,#0xc            ;3033
0017ca  6181              STR      r1,[r0,#0x18]         ;3033
0017cc  6820              LDR      r0,[r4,#0]            ;3036
0017ce  6981              LDR      r1,[r0,#0x18]         ;3036
0017d0  68aa              LDR      r2,[r5,#8]            ;3036
0017d2  4311              ORRS     r1,r1,r2              ;3036
0017d4  6181              STR      r1,[r0,#0x18]         ;3036
0017d6  e7e6              B        |L1.6054|
                  |L1.6104|
0017d8  68eb              LDR      r3,[r5,#0xc]          ;3043
0017da  686a              LDR      r2,[r5,#4]            ;3043
0017dc  6829              LDR      r1,[r5,#0]            ;3043
0017de  6820              LDR      r0,[r4,#0]            ;3043
0017e0  f7fffffe          BL       _Z17TIM_TI2_SetConfigP11TIM_TypeDefjjj ; TIM_TI2_SetConfig(TIM_TypeDef*, unsigned, unsigned, unsigned)
0017e4  6820              LDR      r0,[r4,#0]            ;3049
0017e6  6981              LDR      r1,[r0,#0x18]         ;3049
0017e8  f4216140          BIC      r1,r1,#0xc00          ;3049
0017ec  6181              STR      r1,[r0,#0x18]         ;3049
0017ee  6820              LDR      r0,[r4,#0]            ;3052
0017f0  6981              LDR      r1,[r0,#0x18]         ;3052
0017f2  68aa              LDR      r2,[r5,#8]            ;3052
0017f4  ea412102          ORR      r1,r1,r2,LSL #8       ;3052
0017f8  6181              STR      r1,[r0,#0x18]         ;3052
0017fa  e7d4              B        |L1.6054|
                  |L1.6140|
0017fc  68eb              LDR      r3,[r5,#0xc]          ;3059
0017fe  686a              LDR      r2,[r5,#4]            ;3059
001800  6829              LDR      r1,[r5,#0]            ;3059
001802  6820              LDR      r0,[r4,#0]            ;3059
001804  f7fffffe          BL       _Z17TIM_TI3_SetConfigP11TIM_TypeDefjjj ; TIM_TI3_SetConfig(TIM_TypeDef*, unsigned, unsigned, unsigned)
001808  6820              LDR      r0,[r4,#0]            ;3065
00180a  69c1              LDR      r1,[r0,#0x1c]         ;3065
00180c  f021010c          BIC      r1,r1,#0xc            ;3065
001810  61c1              STR      r1,[r0,#0x1c]         ;3065
001812  6820              LDR      r0,[r4,#0]            ;3068
001814  69c1              LDR      r1,[r0,#0x1c]         ;3068
001816  68aa              LDR      r2,[r5,#8]            ;3068
001818  4311              ORRS     r1,r1,r2              ;3068
00181a  61c1              STR      r1,[r0,#0x1c]         ;3068
00181c  e7c3              B        |L1.6054|
;;;3093   
                          ENDP

                  HAL_TIM_PWM_ConfigChannel PROC
;;;3107     */
;;;3108   HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
00181e  b570              PUSH     {r4-r6,lr}
;;;3109   {
001820  4604              MOV      r4,r0
001822  460d              MOV      r5,r1
;;;3110     __HAL_LOCK(htim);
001824  f8940038          LDRB     r0,[r4,#0x38]
001828  2801              CMP      r0,#1
00182a  d00d              BEQ      |L1.6216|
00182c  2601              MOVS     r6,#1
00182e  f8846038          STRB     r6,[r4,#0x38]
;;;3111     
;;;3112     /* Check the parameters */ 
;;;3113     assert_param(IS_TIM_CHANNELS(Channel)); 
;;;3114     assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
;;;3115     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;3116     assert_param(IS_TIM_OCN_POLARITY(sConfig->OCNPolarity));
;;;3117     assert_param(IS_TIM_OCNIDLE_STATE(sConfig->OCNIdleState));
;;;3118     assert_param(IS_TIM_OCIDLE_STATE(sConfig->OCIdleState));
;;;3119     assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
;;;3120   
;;;3121     htim->State = HAL_TIM_STATE_BUSY;
001832  2002              MOVS     r0,#2
001834  f8840039          STRB     r0,[r4,#0x39]
001838  b142              CBZ      r2,|L1.6220|
;;;3122       
;;;3123     switch (Channel)
00183a  2a04              CMP      r2,#4
00183c  d01a              BEQ      |L1.6260|
00183e  2a08              CMP      r2,#8
001840  d02d              BEQ      |L1.6302|
001842  2a0c              CMP      r2,#0xc
001844  d153              BNE      |L1.6382|
001846  e03e              B        |L1.6342|
                  |L1.6216|
001848  2002              MOVS     r0,#2                 ;3110
;;;3124     {
;;;3125       case TIM_CHANNEL_1:
;;;3126       {
;;;3127         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3128         /* Configure the Channel 1 in PWM mode */
;;;3129         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;3130         
;;;3131         /* Set the Preload enable bit for channel1 */
;;;3132         htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
;;;3133         
;;;3134         /* Configure the Output Fast mode */
;;;3135         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
;;;3136         htim->Instance->CCMR1 |= sConfig->OCFastMode;
;;;3137       }
;;;3138       break;
;;;3139       
;;;3140       case TIM_CHANNEL_2:
;;;3141       {
;;;3142         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3143         /* Configure the Channel 2 in PWM mode */
;;;3144         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;3145         
;;;3146         /* Set the Preload enable bit for channel2 */
;;;3147         htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
;;;3148         
;;;3149         /* Configure the Output Fast mode */
;;;3150         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
;;;3151         htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
;;;3152       }
;;;3153       break;
;;;3154       
;;;3155       case TIM_CHANNEL_3:
;;;3156       {
;;;3157         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3158         /* Configure the Channel 3 in PWM mode */
;;;3159         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;3160         
;;;3161         /* Set the Preload enable bit for channel3 */
;;;3162         htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
;;;3163         
;;;3164        /* Configure the Output Fast mode */
;;;3165         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
;;;3166         htim->Instance->CCMR2 |= sConfig->OCFastMode;  
;;;3167       }
;;;3168       break;
;;;3169       
;;;3170       case TIM_CHANNEL_4:
;;;3171       {
;;;3172         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3173         /* Configure the Channel 4 in PWM mode */
;;;3174         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;3175         
;;;3176         /* Set the Preload enable bit for channel4 */
;;;3177         htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
;;;3178         
;;;3179        /* Configure the Output Fast mode */
;;;3180         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
;;;3181         htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;  
;;;3182       }
;;;3183       break;
;;;3184       
;;;3185       default:
;;;3186       break;    
;;;3187     }
;;;3188     
;;;3189     htim->State = HAL_TIM_STATE_READY;
;;;3190       
;;;3191     __HAL_UNLOCK(htim);
;;;3192     
;;;3193     return HAL_OK;
;;;3194   }
00184a  bd70              POP      {r4-r6,pc}
                  |L1.6220|
00184c  4629              MOV      r1,r5                 ;3129
00184e  6820              LDR      r0,[r4,#0]            ;3129
001850  f7fffffe          BL       _Z17TIM_OC1_SetConfigP11TIM_TypeDefP18TIM_OC_InitTypeDef ; TIM_OC1_SetConfig(TIM_TypeDef*, TIM_OC_InitTypeDef*)
001854  6820              LDR      r0,[r4,#0]            ;3132
001856  6981              LDR      r1,[r0,#0x18]         ;3132
001858  f0410108          ORR      r1,r1,#8              ;3132
00185c  6181              STR      r1,[r0,#0x18]         ;3132
00185e  6820              LDR      r0,[r4,#0]            ;3135
001860  6981              LDR      r1,[r0,#0x18]         ;3135
001862  f0210104          BIC      r1,r1,#4              ;3135
001866  6181              STR      r1,[r0,#0x18]         ;3135
001868  6820              LDR      r0,[r4,#0]            ;3136
00186a  6981              LDR      r1,[r0,#0x18]         ;3136
00186c  692a              LDR      r2,[r5,#0x10]         ;3136
00186e  4311              ORRS     r1,r1,r2              ;3136
001870  6181              STR      r1,[r0,#0x18]         ;3136
001872  e03c              B        |L1.6382|
                  |L1.6260|
001874  4629              MOV      r1,r5                 ;3144
001876  6820              LDR      r0,[r4,#0]            ;3144
001878  f7fffffe          BL       TIM_OC2_SetConfig
00187c  6820              LDR      r0,[r4,#0]            ;3147
00187e  6981              LDR      r1,[r0,#0x18]         ;3147
001880  f4416100          ORR      r1,r1,#0x800          ;3147
001884  6181              STR      r1,[r0,#0x18]         ;3147
001886  6820              LDR      r0,[r4,#0]            ;3150
001888  6981              LDR      r1,[r0,#0x18]         ;3150
00188a  f4216180          BIC      r1,r1,#0x400          ;3150
00188e  6181              STR      r1,[r0,#0x18]         ;3150
001890  6820              LDR      r0,[r4,#0]            ;3151
001892  6981              LDR      r1,[r0,#0x18]         ;3151
001894  692a              LDR      r2,[r5,#0x10]         ;3151
001896  ea412102          ORR      r1,r1,r2,LSL #8       ;3151
00189a  6181              STR      r1,[r0,#0x18]         ;3151
00189c  e027              B        |L1.6382|
                  |L1.6302|
00189e  4629              MOV      r1,r5                 ;3159
0018a0  6820              LDR      r0,[r4,#0]            ;3159
0018a2  f7fffffe          BL       _Z17TIM_OC3_SetConfigP11TIM_TypeDefP18TIM_OC_InitTypeDef ; TIM_OC3_SetConfig(TIM_TypeDef*, TIM_OC_InitTypeDef*)
0018a6  6820              LDR      r0,[r4,#0]            ;3162
0018a8  69c1              LDR      r1,[r0,#0x1c]         ;3162
0018aa  f0410108          ORR      r1,r1,#8              ;3162
0018ae  61c1              STR      r1,[r0,#0x1c]         ;3162
0018b0  6820              LDR      r0,[r4,#0]            ;3165
0018b2  69c1              LDR      r1,[r0,#0x1c]         ;3165
0018b4  f0210104          BIC      r1,r1,#4              ;3165
0018b8  61c1              STR      r1,[r0,#0x1c]         ;3165
0018ba  6820              LDR      r0,[r4,#0]            ;3166
0018bc  69c1              LDR      r1,[r0,#0x1c]         ;3166
0018be  692a              LDR      r2,[r5,#0x10]         ;3166
0018c0  4311              ORRS     r1,r1,r2              ;3166
0018c2  61c1              STR      r1,[r0,#0x1c]         ;3166
0018c4  e013              B        |L1.6382|
                  |L1.6342|
0018c6  4629              MOV      r1,r5                 ;3174
0018c8  6820              LDR      r0,[r4,#0]            ;3174
0018ca  f7fffffe          BL       _Z17TIM_OC4_SetConfigP11TIM_TypeDefP18TIM_OC_InitTypeDef ; TIM_OC4_SetConfig(TIM_TypeDef*, TIM_OC_InitTypeDef*)
0018ce  6820              LDR      r0,[r4,#0]            ;3177
0018d0  69c1              LDR      r1,[r0,#0x1c]         ;3177
0018d2  f4416100          ORR      r1,r1,#0x800          ;3177
0018d6  61c1              STR      r1,[r0,#0x1c]         ;3177
0018d8  6820              LDR      r0,[r4,#0]            ;3180
0018da  69c1              LDR      r1,[r0,#0x1c]         ;3180
0018dc  f4216180          BIC      r1,r1,#0x400          ;3180
0018e0  61c1              STR      r1,[r0,#0x1c]         ;3180
0018e2  6820              LDR      r0,[r4,#0]            ;3181
0018e4  69c1              LDR      r1,[r0,#0x1c]         ;3181
0018e6  692a              LDR      r2,[r5,#0x10]         ;3181
0018e8  ea412102          ORR      r1,r1,r2,LSL #8       ;3181
0018ec  61c1              STR      r1,[r0,#0x1c]         ;3181
                  |L1.6382|
0018ee  f8846039          STRB     r6,[r4,#0x39]         ;3189
0018f2  2000              MOVS     r0,#0                 ;3191
0018f4  f8840038          STRB     r0,[r4,#0x38]         ;3191
0018f8  bd70              POP      {r4-r6,pc}
;;;3195   
                          ENDP

                  HAL_TIM_OnePulse_ConfigChannel PROC
;;;3211     */
;;;3212   HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
0018fa  b5f0              PUSH     {r4-r7,lr}
;;;3213   {
0018fc  b087              SUB      sp,sp,#0x1c
0018fe  4604              MOV      r4,r0
001900  460d              MOV      r5,r1
001902  461f              MOV      r7,r3
;;;3214     TIM_OC_InitTypeDef temp1;
;;;3215     
;;;3216     /* Check the parameters */
;;;3217     assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
;;;3218     assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
;;;3219   
;;;3220     if(OutputChannel != InputChannel)  
001904  42ba              CMP      r2,r7
001906  d070              BEQ      |L1.6634|
;;;3221     {
;;;3222       __HAL_LOCK(htim);
001908  f8940038          LDRB     r0,[r4,#0x38]
00190c  2801              CMP      r0,#1
00190e  d015              BEQ      |L1.6460|
001910  2601              MOVS     r6,#1
001912  f8846038          STRB     r6,[r4,#0x38]
;;;3223     
;;;3224       htim->State = HAL_TIM_STATE_BUSY;
001916  2002              MOVS     r0,#2
001918  f8840039          STRB     r0,[r4,#0x39]
;;;3225   
;;;3226       /* Extract the Output compare configuration from sConfig structure */  
;;;3227       temp1.OCMode = sConfig->OCMode;
00191c  6828              LDR      r0,[r5,#0]
00191e  9000              STR      r0,[sp,#0]
;;;3228       temp1.Pulse = sConfig->Pulse;
001920  6868              LDR      r0,[r5,#4]
001922  9001              STR      r0,[sp,#4]
;;;3229       temp1.OCPolarity = sConfig->OCPolarity;
001924  68a8              LDR      r0,[r5,#8]
001926  9002              STR      r0,[sp,#8]
;;;3230       temp1.OCNPolarity = sConfig->OCNPolarity;
001928  68e8              LDR      r0,[r5,#0xc]
00192a  9003              STR      r0,[sp,#0xc]
;;;3231       temp1.OCIdleState = sConfig->OCIdleState;
00192c  6928              LDR      r0,[r5,#0x10]
00192e  9005              STR      r0,[sp,#0x14]
;;;3232       temp1.OCNIdleState = sConfig->OCNIdleState; 
001930  6968              LDR      r0,[r5,#0x14]
001932  9006              STR      r0,[sp,#0x18]
001934  b12a              CBZ      r2,|L1.6466|
;;;3233       
;;;3234       switch (OutputChannel)
001936  2a04              CMP      r2,#4
001938  d10c              BNE      |L1.6484|
00193a  e007              B        |L1.6476|
                  |L1.6460|
;;;3235       {
;;;3236         case TIM_CHANNEL_1:
;;;3237         {
;;;3238           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3239         
;;;3240           TIM_OC1_SetConfig(htim->Instance, &temp1); 
;;;3241         }
;;;3242         break;
;;;3243         case TIM_CHANNEL_2:
;;;3244         {
;;;3245           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3246         
;;;3247           TIM_OC2_SetConfig(htim->Instance, &temp1);
;;;3248         }
;;;3249         break;
;;;3250         default:
;;;3251         break;  
;;;3252       } 
;;;3253       switch (InputChannel)
;;;3254       {
;;;3255         case TIM_CHANNEL_1:
;;;3256         {
;;;3257           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3258         
;;;3259           TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3260                           sConfig->ICSelection, sConfig->ICFilter);
;;;3261                  
;;;3262           /* Reset the IC1PSC Bits */
;;;3263           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3264   
;;;3265           /* Select the Trigger source */
;;;3266           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3267           htim->Instance->SMCR |= TIM_TS_TI1FP1;
;;;3268         
;;;3269           /* Select the Slave Mode */      
;;;3270           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3271           htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3272         }
;;;3273         break;
;;;3274         case TIM_CHANNEL_2:
;;;3275         {
;;;3276           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3277         
;;;3278           TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3279                    sConfig->ICSelection, sConfig->ICFilter);
;;;3280                  
;;;3281           /* Reset the IC2PSC Bits */
;;;3282           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3283   
;;;3284           /* Select the Trigger source */
;;;3285           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3286           htim->Instance->SMCR |= TIM_TS_TI2FP2;
;;;3287         
;;;3288           /* Select the Slave Mode */      
;;;3289           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3290           htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3291         }
;;;3292         break;
;;;3293       
;;;3294         default:
;;;3295         break;  
;;;3296       }
;;;3297     
;;;3298       htim->State = HAL_TIM_STATE_READY;
;;;3299       
;;;3300       __HAL_UNLOCK(htim);
;;;3301     
;;;3302       return HAL_OK;
;;;3303     }
;;;3304     else
;;;3305     {
;;;3306       return HAL_ERROR;
;;;3307     }
;;;3308   } 
00193c  b007              ADD      sp,sp,#0x1c
00193e  2002              MOVS     r0,#2                 ;3222
001940  bdf0              POP      {r4-r7,pc}
                  |L1.6466|
001942  4669              MOV      r1,sp                 ;3240
001944  6820              LDR      r0,[r4,#0]            ;3240
001946  f7fffffe          BL       _Z17TIM_OC1_SetConfigP11TIM_TypeDefP18TIM_OC_InitTypeDef ; TIM_OC1_SetConfig(TIM_TypeDef*, TIM_OC_InitTypeDef*)
00194a  e003              B        |L1.6484|
                  |L1.6476|
00194c  4669              MOV      r1,sp                 ;3247
00194e  6820              LDR      r0,[r4,#0]            ;3247
001950  f7fffffe          BL       TIM_OC2_SetConfig
                  |L1.6484|
001954  b117              CBZ      r7,|L1.6492|
001956  2f04              CMP      r7,#4                 ;3253
001958  d13f              BNE      |L1.6618|
00195a  e01f              B        |L1.6556|
                  |L1.6492|
00195c  6a2b              LDR      r3,[r5,#0x20]         ;3259
00195e  69ea              LDR      r2,[r5,#0x1c]         ;3259
001960  69a9              LDR      r1,[r5,#0x18]         ;3259
001962  6820              LDR      r0,[r4,#0]            ;3259
001964  f7fffffe          BL       TIM_TI1_SetConfig
001968  6820              LDR      r0,[r4,#0]            ;3263
00196a  6981              LDR      r1,[r0,#0x18]         ;3263
00196c  f021010c          BIC      r1,r1,#0xc            ;3263
001970  6181              STR      r1,[r0,#0x18]         ;3263
001972  6820              LDR      r0,[r4,#0]            ;3266
001974  6881              LDR      r1,[r0,#8]            ;3266
001976  f0210170          BIC      r1,r1,#0x70           ;3266
00197a  6081              STR      r1,[r0,#8]            ;3266
00197c  6820              LDR      r0,[r4,#0]            ;3267
00197e  6881              LDR      r1,[r0,#8]            ;3267
001980  f0410150          ORR      r1,r1,#0x50           ;3267
001984  6081              STR      r1,[r0,#8]            ;3267
001986  6820              LDR      r0,[r4,#0]            ;3270
001988  6881              LDR      r1,[r0,#8]            ;3270
00198a  f0210107          BIC      r1,r1,#7              ;3270
00198e  6081              STR      r1,[r0,#8]            ;3270
001990  6820              LDR      r0,[r4,#0]            ;3271
001992  6881              LDR      r1,[r0,#8]            ;3271
001994  f0410106          ORR      r1,r1,#6              ;3271
001998  6081              STR      r1,[r0,#8]            ;3271
00199a  e01e              B        |L1.6618|
                  |L1.6556|
00199c  6a2b              LDR      r3,[r5,#0x20]         ;3278
00199e  69ea              LDR      r2,[r5,#0x1c]         ;3278
0019a0  69a9              LDR      r1,[r5,#0x18]         ;3278
0019a2  6820              LDR      r0,[r4,#0]            ;3278
0019a4  f7fffffe          BL       _Z17TIM_TI2_SetConfigP11TIM_TypeDefjjj ; TIM_TI2_SetConfig(TIM_TypeDef*, unsigned, unsigned, unsigned)
0019a8  6820              LDR      r0,[r4,#0]            ;3282
0019aa  6981              LDR      r1,[r0,#0x18]         ;3282
0019ac  f4216140          BIC      r1,r1,#0xc00          ;3282
0019b0  6181              STR      r1,[r0,#0x18]         ;3282
0019b2  6820              LDR      r0,[r4,#0]            ;3285
0019b4  6881              LDR      r1,[r0,#8]            ;3285
0019b6  f0210170          BIC      r1,r1,#0x70           ;3285
0019ba  6081              STR      r1,[r0,#8]            ;3285
0019bc  6820              LDR      r0,[r4,#0]            ;3286
0019be  6881              LDR      r1,[r0,#8]            ;3286
0019c0  f0410160          ORR      r1,r1,#0x60           ;3286
0019c4  6081              STR      r1,[r0,#8]            ;3286
0019c6  6820              LDR      r0,[r4,#0]            ;3289
0019c8  6881              LDR      r1,[r0,#8]            ;3289
0019ca  f0210107          BIC      r1,r1,#7              ;3289
0019ce  6081              STR      r1,[r0,#8]            ;3289
0019d0  6820              LDR      r0,[r4,#0]            ;3290
0019d2  6881              LDR      r1,[r0,#8]            ;3290
0019d4  f0410106          ORR      r1,r1,#6              ;3290
0019d8  6081              STR      r1,[r0,#8]            ;3290
                  |L1.6618|
0019da  f8846039          STRB     r6,[r4,#0x39]         ;3298
0019de  2000              MOVS     r0,#0                 ;3300
0019e0  f8840038          STRB     r0,[r4,#0x38]         ;3300
0019e4  b007              ADD      sp,sp,#0x1c
0019e6  bdf0              POP      {r4-r7,pc}
0019e8  e7ff              B        |L1.6634|
                  |L1.6634|
0019ea  b007              ADD      sp,sp,#0x1c
0019ec  2001              MOVS     r0,#1                 ;3306
0019ee  bdf0              POP      {r4-r7,pc}
;;;3309   
                          ENDP

                  _Z18TIM_DMATriggerCpltP19__DMA_HandleTypeDef PROC ; TIM_DMATriggerCplt(__DMA_HandleTypeDef*)
;;;4714     */
;;;4715   static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
0019f0  b510              PUSH     {r4,lr}
;;;4716   {
;;;4717     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;  
0019f2  6b80              LDR      r0,[r0,#0x38]
;;;4718     
;;;4719     htim->State= HAL_TIM_STATE_READY; 
0019f4  2101              MOVS     r1,#1
0019f6  f8801039          STRB     r1,[r0,#0x39]
;;;4720     
;;;4721     HAL_TIM_TriggerCallback(htim);
0019fa  f7fffffe          BL       HAL_TIM_TriggerCallback
;;;4722   }
0019fe  bd10              POP      {r4,pc}
;;;4723   
                          ENDP

                  HAL_TIM_DMABurst_WriteStart PROC
;;;3348     */
;;;3349   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
001a00  e92d41f0          PUSH     {r4-r8,lr}
;;;3350                                                 uint32_t* BurstBuffer, uint32_t  BurstLength)
;;;3351   {
001a04  4604              MOV      r4,r0
001a06  9e06              LDR      r6,[sp,#0x18]
001a08  4688              MOV      r8,r1
001a0a  4615              MOV      r5,r2
001a0c  469c              MOV      r12,r3
;;;3352     /* Check the parameters */
;;;3353     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3354     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3355     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3356     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3357     
;;;3358     if((htim->State == HAL_TIM_STATE_BUSY))
001a0e  f8940039          LDRB     r0,[r4,#0x39]
001a12  2802              CMP      r0,#2
001a14  d004              BEQ      |L1.6688|
;;;3359     {
;;;3360        return HAL_BUSY;
;;;3361     }
;;;3362     else if((htim->State == HAL_TIM_STATE_READY))
001a16  f8940039          LDRB     r0,[r4,#0x39]
001a1a  2801              CMP      r0,#1
001a1c  d003              BEQ      |L1.6694|
001a1e  e00c              B        |L1.6714|
                  |L1.6688|
001a20  2002              MOVS     r0,#2                 ;3360
;;;3363     {
;;;3364       if((BurstBuffer == 0 ) && (BurstLength > 0)) 
;;;3365       {
;;;3366         return HAL_ERROR;                                    
;;;3367       }
;;;3368       else
;;;3369       {
;;;3370         htim->State = HAL_TIM_STATE_BUSY;
;;;3371       }
;;;3372     }
;;;3373     switch(BurstRequestSrc)
;;;3374     {
;;;3375       case TIM_DMA_UPDATE:
;;;3376       {  
;;;3377         /* Set the DMA Period elapsed callback */
;;;3378         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3379        
;;;3380         /* Set the DMA error callback */
;;;3381         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;3382     
;;;3383         /* Enable the DMA Stream */
;;;3384         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1); 
;;;3385       }
;;;3386       break;
;;;3387       case TIM_DMA_CC1:
;;;3388       {  
;;;3389         /* Set the DMA Period elapsed callback */
;;;3390         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;3391        
;;;3392         /* Set the DMA error callback */
;;;3393         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;3394     
;;;3395         /* Enable the DMA Stream */
;;;3396         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3397       }
;;;3398       break;
;;;3399       case TIM_DMA_CC2:
;;;3400       {  
;;;3401         /* Set the DMA Period elapsed callback */
;;;3402         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;3403        
;;;3404         /* Set the DMA error callback */
;;;3405         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;3406     
;;;3407         /* Enable the DMA Stream */
;;;3408         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3409       }
;;;3410       break;
;;;3411       case TIM_DMA_CC3:
;;;3412       {  
;;;3413         /* Set the DMA Period elapsed callback */
;;;3414         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;3415        
;;;3416         /* Set the DMA error callback */
;;;3417         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;3418     
;;;3419         /* Enable the DMA Stream */
;;;3420         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3421       }
;;;3422       break;
;;;3423       case TIM_DMA_CC4:
;;;3424       {  
;;;3425         /* Set the DMA Period elapsed callback */
;;;3426         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;3427        
;;;3428         /* Set the DMA error callback */
;;;3429         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;3430     
;;;3431         /* Enable the DMA Stream */
;;;3432         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3433       }
;;;3434       break;
;;;3435       case TIM_DMA_COM:
;;;3436       {  
;;;3437         /* Set the DMA Period elapsed callback */
;;;3438         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
;;;3439        
;;;3440         /* Set the DMA error callback */
;;;3441         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
;;;3442     
;;;3443         /* Enable the DMA Stream */
;;;3444         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3445       }
;;;3446       break;
;;;3447       case TIM_DMA_TRIGGER:
;;;3448       {  
;;;3449         /* Set the DMA Period elapsed callback */
;;;3450         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3451        
;;;3452         /* Set the DMA error callback */
;;;3453         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
;;;3454     
;;;3455         /* Enable the DMA Stream */
;;;3456         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3457       }
;;;3458       break;
;;;3459       default:
;;;3460       break;  
;;;3461     }
;;;3462      /* configure the DMA Burst Mode */
;;;3463      htim->Instance->DCR = BurstBaseAddress | BurstLength;  
;;;3464      
;;;3465      /* Enable the TIM DMA Request */
;;;3466      __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);  
;;;3467      
;;;3468      htim->State = HAL_TIM_STATE_READY;
;;;3469     
;;;3470     /* Return function status */
;;;3471     return HAL_OK;
;;;3472   }
001a22  e8bd81f0          POP      {r4-r8,pc}
                  |L1.6694|
001a26  f1bc0f00          CMP      r12,#0                ;3364
001a2a  d103              BNE      |L1.6708|
001a2c  b116              CBZ      r6,|L1.6708|
001a2e  2001              MOVS     r0,#1                 ;3366
001a30  e8bd81f0          POP      {r4-r8,pc}
                  |L1.6708|
001a34  2002              MOVS     r0,#2                 ;3370
001a36  f8840039          STRB     r0,[r4,#0x39]         ;3370
                  |L1.6714|
001a3a  2701              MOVS     r7,#1                 ;3366
001a3c  48f9              LDR      r0,|L1.7716|
001a3e  49fa              LDR      r1,|L1.7720|
001a40  eb072316          ADD      r3,r7,r6,LSR #8       ;3384
001a44  f5b56f00          CMP      r5,#0x800             ;3373
001a48  d039              BEQ      |L1.6846|
001a4a  dc09              BGT      |L1.6752|
001a4c  f5b57f80          CMP      r5,#0x100             ;3373
001a50  d010              BEQ      |L1.6772|
001a52  f5b57f00          CMP      r5,#0x200             ;3373
001a56  d01a              BEQ      |L1.6798|
001a58  f5b56f80          CMP      r5,#0x400             ;3373
001a5c  d160              BNE      |L1.6944|
001a5e  e022              B        |L1.6822|
                  |L1.6752|
001a60  f5b55f80          CMP      r5,#0x1000            ;3373
001a64  d037              BEQ      |L1.6870|
001a66  f5b55f00          CMP      r5,#0x2000            ;3373
001a6a  d040              BEQ      |L1.6894|
001a6c  f5b54f80          CMP      r5,#0x4000            ;3373
001a70  d156              BNE      |L1.6944|
001a72  e049              B        |L1.6920|
                  |L1.6772|
001a74  69e2              LDR      r2,[r4,#0x1c]         ;3378
001a76  49ed              LDR      r1,|L1.7724|
001a78  63d1              STR      r1,[r2,#0x3c]         ;3378
001a7a  69e1              LDR      r1,[r4,#0x1c]         ;3381
001a7c  6488              STR      r0,[r1,#0x48]         ;3381
001a7e  6820              LDR      r0,[r4,#0]            ;3384
001a80  4661              MOV      r1,r12                ;3384
001a82  f100024c          ADD      r2,r0,#0x4c           ;3384
001a86  69e0              LDR      r0,[r4,#0x1c]         ;3384
001a88  f7fffffe          BL       HAL_DMA_Start_IT
001a8c  e048              B        |L1.6944|
                  |L1.6798|
001a8e  6a22              LDR      r2,[r4,#0x20]         ;3390
001a90  63d1              STR      r1,[r2,#0x3c]         ;3390
001a92  6a21              LDR      r1,[r4,#0x20]         ;3393
001a94  6488              STR      r0,[r1,#0x48]         ;3393
001a96  6820              LDR      r0,[r4,#0]            ;3396
001a98  4661              MOV      r1,r12                ;3396
001a9a  f100024c          ADD      r2,r0,#0x4c           ;3396
001a9e  6a20              LDR      r0,[r4,#0x20]         ;3396
001aa0  f7fffffe          BL       HAL_DMA_Start_IT
001aa4  e03c              B        |L1.6944|
                  |L1.6822|
001aa6  6a62              LDR      r2,[r4,#0x24]         ;3402
001aa8  63d1              STR      r1,[r2,#0x3c]         ;3402
001aaa  6a61              LDR      r1,[r4,#0x24]         ;3405
001aac  6488              STR      r0,[r1,#0x48]         ;3405
001aae  6820              LDR      r0,[r4,#0]            ;3408
001ab0  4661              MOV      r1,r12                ;3408
001ab2  f100024c          ADD      r2,r0,#0x4c           ;3408
001ab6  6a60              LDR      r0,[r4,#0x24]         ;3408
001ab8  f7fffffe          BL       HAL_DMA_Start_IT
001abc  e030              B        |L1.6944|
                  |L1.6846|
001abe  6aa2              LDR      r2,[r4,#0x28]         ;3414
001ac0  63d1              STR      r1,[r2,#0x3c]         ;3414
001ac2  6aa1              LDR      r1,[r4,#0x28]         ;3417
001ac4  6488              STR      r0,[r1,#0x48]         ;3417
001ac6  6820              LDR      r0,[r4,#0]            ;3420
001ac8  4661              MOV      r1,r12                ;3420
001aca  f100024c          ADD      r2,r0,#0x4c           ;3420
001ace  6aa0              LDR      r0,[r4,#0x28]         ;3420
001ad0  f7fffffe          BL       HAL_DMA_Start_IT
001ad4  e024              B        |L1.6944|
                  |L1.6870|
001ad6  6ae2              LDR      r2,[r4,#0x2c]         ;3426
001ad8  63d1              STR      r1,[r2,#0x3c]         ;3426
001ada  6ae1              LDR      r1,[r4,#0x2c]         ;3429
001adc  6488              STR      r0,[r1,#0x48]         ;3429
001ade  6820              LDR      r0,[r4,#0]            ;3432
001ae0  4661              MOV      r1,r12                ;3432
001ae2  f100024c          ADD      r2,r0,#0x4c           ;3432
001ae6  6ae0              LDR      r0,[r4,#0x2c]         ;3432
001ae8  f7fffffe          BL       HAL_DMA_Start_IT
001aec  e018              B        |L1.6944|
                  |L1.6894|
001aee  6b22              LDR      r2,[r4,#0x30]         ;3438
001af0  49cf              LDR      r1,|L1.7728|
001af2  63d1              STR      r1,[r2,#0x3c]         ;3438
001af4  6b21              LDR      r1,[r4,#0x30]         ;3441
001af6  6488              STR      r0,[r1,#0x48]         ;3441
001af8  6820              LDR      r0,[r4,#0]            ;3444
001afa  4661              MOV      r1,r12                ;3444
001afc  f100024c          ADD      r2,r0,#0x4c           ;3444
001b00  6b20              LDR      r0,[r4,#0x30]         ;3444
001b02  f7fffffe          BL       HAL_DMA_Start_IT
001b06  e00b              B        |L1.6944|
                  |L1.6920|
001b08  6b62              LDR      r2,[r4,#0x34]         ;3450
001b0a  49ca              LDR      r1,|L1.7732|
001b0c  63d1              STR      r1,[r2,#0x3c]         ;3450
001b0e  6b61              LDR      r1,[r4,#0x34]         ;3453
001b10  6488              STR      r0,[r1,#0x48]         ;3453
001b12  6820              LDR      r0,[r4,#0]            ;3456
001b14  4661              MOV      r1,r12                ;3456
001b16  f100024c          ADD      r2,r0,#0x4c           ;3456
001b1a  6b60              LDR      r0,[r4,#0x34]         ;3456
001b1c  f7fffffe          BL       HAL_DMA_Start_IT
                  |L1.6944|
001b20  6821              LDR      r1,[r4,#0]            ;3463
001b22  ea480006          ORR      r0,r8,r6              ;3463
001b26  6488              STR      r0,[r1,#0x48]         ;3463
001b28  6820              LDR      r0,[r4,#0]            ;3466
001b2a  68c1              LDR      r1,[r0,#0xc]          ;3466
001b2c  4329              ORRS     r1,r1,r5              ;3466
001b2e  60c1              STR      r1,[r0,#0xc]          ;3466
001b30  f8847039          STRB     r7,[r4,#0x39]         ;3468
001b34  2000              MOVS     r0,#0                 ;3471
001b36  e8bd81f0          POP      {r4-r8,pc}
;;;3473   
                          ENDP

                  HAL_TIM_DMABurst_WriteStop PROC
;;;3480     */
;;;3481   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
001b3a  b570              PUSH     {r4-r6,lr}
;;;3482   {
001b3c  4604              MOV      r4,r0
001b3e  460d              MOV      r5,r1
;;;3483     /* Check the parameters */
;;;3484     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3485     
;;;3486     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3487     switch(BurstRequestSrc)
001b40  f5b56f00          CMP      r5,#0x800
001b44  d020              BEQ      |L1.7048|
001b46  dc09              BGT      |L1.7004|
001b48  f5b57f80          CMP      r5,#0x100
001b4c  d010              BEQ      |L1.7024|
001b4e  f5b57f00          CMP      r5,#0x200
001b52  d011              BEQ      |L1.7032|
001b54  f5b56f80          CMP      r5,#0x400
001b58  d125              BNE      |L1.7078|
001b5a  e011              B        |L1.7040|
                  |L1.7004|
001b5c  f5b55f80          CMP      r5,#0x1000
001b60  d016              BEQ      |L1.7056|
001b62  f5b55f00          CMP      r5,#0x2000
001b66  d017              BEQ      |L1.7064|
001b68  f5b54f80          CMP      r5,#0x4000
001b6c  d11b              BNE      |L1.7078|
001b6e  e017              B        |L1.7072|
                  |L1.7024|
;;;3488     {
;;;3489       case TIM_DMA_UPDATE:
;;;3490       {  
;;;3491         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
001b70  69e0              LDR      r0,[r4,#0x1c]
001b72  f7fffffe          BL       HAL_DMA_Abort
;;;3492       }
;;;3493       break;
001b76  e016              B        |L1.7078|
                  |L1.7032|
;;;3494       case TIM_DMA_CC1:
;;;3495       {  
;;;3496         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
001b78  6a20              LDR      r0,[r4,#0x20]
001b7a  f7fffffe          BL       HAL_DMA_Abort
;;;3497       }
;;;3498       break;
001b7e  e012              B        |L1.7078|
                  |L1.7040|
;;;3499       case TIM_DMA_CC2:
;;;3500       {  
;;;3501         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
001b80  6a60              LDR      r0,[r4,#0x24]
001b82  f7fffffe          BL       HAL_DMA_Abort
;;;3502       }
;;;3503       break;
001b86  e00e              B        |L1.7078|
                  |L1.7048|
;;;3504       case TIM_DMA_CC3:
;;;3505       {  
;;;3506         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
001b88  6aa0              LDR      r0,[r4,#0x28]
001b8a  f7fffffe          BL       HAL_DMA_Abort
;;;3507       }
;;;3508       break;
001b8e  e00a              B        |L1.7078|
                  |L1.7056|
;;;3509       case TIM_DMA_CC4:
;;;3510       {  
;;;3511         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
001b90  6ae0              LDR      r0,[r4,#0x2c]
001b92  f7fffffe          BL       HAL_DMA_Abort
;;;3512       }
;;;3513       break;
001b96  e006              B        |L1.7078|
                  |L1.7064|
;;;3514       case TIM_DMA_COM:
;;;3515       {  
;;;3516         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
001b98  6b20              LDR      r0,[r4,#0x30]
001b9a  f7fffffe          BL       HAL_DMA_Abort
;;;3517       }
;;;3518       break;
001b9e  e002              B        |L1.7078|
                  |L1.7072|
;;;3519       case TIM_DMA_TRIGGER:
;;;3520       {  
;;;3521         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
001ba0  6b60              LDR      r0,[r4,#0x34]
001ba2  f7fffffe          BL       HAL_DMA_Abort
                  |L1.7078|
;;;3522       }
;;;3523       break;
;;;3524       default:
;;;3525       break;
;;;3526     }
;;;3527   
;;;3528     /* Disable the TIM Update DMA request */
;;;3529     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
001ba6  6820              LDR      r0,[r4,#0]
001ba8  68c1              LDR      r1,[r0,#0xc]
001baa  43a9              BICS     r1,r1,r5
001bac  60c1              STR      r1,[r0,#0xc]
;;;3530         
;;;3531     /* Return function status */
;;;3532     return HAL_OK;  
001bae  2000              MOVS     r0,#0
;;;3533   }
001bb0  bd70              POP      {r4-r6,pc}
;;;3534   
                          ENDP

                  HAL_TIM_DMABurst_ReadStart PROC
;;;3573     */
;;;3574   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
001bb2  e92d41f0          PUSH     {r4-r8,lr}
;;;3575                                                uint32_t  *BurstBuffer, uint32_t  BurstLength)
;;;3576   {
001bb6  4615              MOV      r5,r2
001bb8  9e06              LDR      r6,[sp,#0x18]
001bba  4604              MOV      r4,r0
001bbc  4688              MOV      r8,r1
001bbe  461a              MOV      r2,r3
;;;3577     /* Check the parameters */
;;;3578     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3579     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3580     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3581     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3582     
;;;3583     if((htim->State == HAL_TIM_STATE_BUSY))
001bc0  f8940039          LDRB     r0,[r4,#0x39]
001bc4  2802              CMP      r0,#2
001bc6  d004              BEQ      |L1.7122|
;;;3584     {
;;;3585        return HAL_BUSY;
;;;3586     }
;;;3587     else if((htim->State == HAL_TIM_STATE_READY))
001bc8  f8940039          LDRB     r0,[r4,#0x39]
001bcc  2801              CMP      r0,#1
001bce  d003              BEQ      |L1.7128|
001bd0  e00a              B        |L1.7144|
                  |L1.7122|
001bd2  2002              MOVS     r0,#2                 ;3585
;;;3588     {
;;;3589       if((BurstBuffer == 0 ) && (BurstLength > 0)) 
;;;3590       {
;;;3591         return HAL_ERROR;                                    
;;;3592       }
;;;3593       else
;;;3594       {
;;;3595         htim->State = HAL_TIM_STATE_BUSY;
;;;3596       }
;;;3597     }  
;;;3598     switch(BurstRequestSrc)
;;;3599     {
;;;3600       case TIM_DMA_UPDATE:
;;;3601       {  
;;;3602         /* Set the DMA Period elapsed callback */
;;;3603         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3604        
;;;3605         /* Set the DMA error callback */
;;;3606         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;3607     
;;;3608         /* Enable the DMA Stream */
;;;3609          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);     
;;;3610       }
;;;3611       break;
;;;3612       case TIM_DMA_CC1:
;;;3613       {  
;;;3614         /* Set the DMA Period elapsed callback */
;;;3615         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;3616        
;;;3617         /* Set the DMA error callback */
;;;3618         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;3619     
;;;3620         /* Enable the DMA Stream */
;;;3621         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3622       }
;;;3623       break;
;;;3624       case TIM_DMA_CC2:
;;;3625       {  
;;;3626         /* Set the DMA Period elapsed callback */
;;;3627         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;3628        
;;;3629         /* Set the DMA error callback */
;;;3630         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;3631     
;;;3632         /* Enable the DMA Stream */
;;;3633         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);     
;;;3634       }
;;;3635       break;
;;;3636       case TIM_DMA_CC3:
;;;3637       {  
;;;3638         /* Set the DMA Period elapsed callback */
;;;3639         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
;;;3640        
;;;3641         /* Set the DMA error callback */
;;;3642         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;3643     
;;;3644         /* Enable the DMA Stream */
;;;3645         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3646       }
;;;3647       break;
;;;3648       case TIM_DMA_CC4:
;;;3649       {  
;;;3650         /* Set the DMA Period elapsed callback */
;;;3651         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
;;;3652        
;;;3653         /* Set the DMA error callback */
;;;3654         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;3655     
;;;3656         /* Enable the DMA Stream */
;;;3657         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3658       }
;;;3659       break;
;;;3660       case TIM_DMA_COM:
;;;3661       {  
;;;3662         /* Set the DMA Period elapsed callback */
;;;3663         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
;;;3664        
;;;3665         /* Set the DMA error callback */
;;;3666         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
;;;3667     
;;;3668         /* Enable the DMA Stream */
;;;3669         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3670       }
;;;3671       break;
;;;3672       case TIM_DMA_TRIGGER:
;;;3673       {  
;;;3674         /* Set the DMA Period elapsed callback */
;;;3675         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3676        
;;;3677         /* Set the DMA error callback */
;;;3678         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
;;;3679     
;;;3680         /* Enable the DMA Stream */
;;;3681         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3682       }
;;;3683       break;
;;;3684       default:
;;;3685       break;  
;;;3686     }
;;;3687   
;;;3688     /* configure the DMA Burst Mode */
;;;3689     htim->Instance->DCR = BurstBaseAddress | BurstLength;  
;;;3690     
;;;3691     /* Enable the TIM DMA Request */
;;;3692     __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;3693     
;;;3694     htim->State = HAL_TIM_STATE_READY;
;;;3695     
;;;3696     /* Return function status */
;;;3697     return HAL_OK;
;;;3698   }
001bd4  e8bd81f0          POP      {r4-r8,pc}
                  |L1.7128|
001bd8  b91a              CBNZ     r2,|L1.7138|
001bda  b116              CBZ      r6,|L1.7138|
001bdc  2001              MOVS     r0,#1                 ;3591
001bde  e8bd81f0          POP      {r4-r8,pc}
                  |L1.7138|
001be2  2002              MOVS     r0,#2                 ;3595
001be4  f8840039          STRB     r0,[r4,#0x39]         ;3595
                  |L1.7144|
001be8  2701              MOVS     r7,#1                 ;3591
001bea  488e              LDR      r0,|L1.7716|
001bec  4992              LDR      r1,|L1.7736|
001bee  eb072316          ADD      r3,r7,r6,LSR #8       ;3609
001bf2  f5b56f00          CMP      r5,#0x800             ;3598
001bf6  d03c              BEQ      |L1.7282|
001bf8  dc09              BGT      |L1.7182|
001bfa  f5b57f80          CMP      r5,#0x100             ;3598
001bfe  d010              BEQ      |L1.7202|
001c00  f5b57f00          CMP      r5,#0x200             ;3598
001c04  d01b              BEQ      |L1.7230|
001c06  f5b56f80          CMP      r5,#0x400             ;3598
001c0a  d167              BNE      |L1.7388|
001c0c  e024              B        |L1.7256|
                  |L1.7182|
001c0e  f5b55f80          CMP      r5,#0x1000            ;3598
001c12  d03b              BEQ      |L1.7308|
001c14  f5b55f00          CMP      r5,#0x2000            ;3598
001c18  d045              BEQ      |L1.7334|
001c1a  f5b54f80          CMP      r5,#0x4000            ;3598
001c1e  d15d              BNE      |L1.7388|
001c20  e04f              B        |L1.7362|
                  |L1.7202|
001c22  f8d4c01c          LDR      r12,[r4,#0x1c]        ;3603
001c26  4981              LDR      r1,|L1.7724|
001c28  f8cc103c          STR      r1,[r12,#0x3c]        ;3603
001c2c  69e1              LDR      r1,[r4,#0x1c]         ;3606
001c2e  6488              STR      r0,[r1,#0x48]         ;3606
001c30  6820              LDR      r0,[r4,#0]            ;3609
001c32  f100014c          ADD      r1,r0,#0x4c           ;3609
001c36  69e0              LDR      r0,[r4,#0x1c]         ;3609
001c38  f7fffffe          BL       HAL_DMA_Start_IT
001c3c  e04e              B        |L1.7388|
                  |L1.7230|
001c3e  f8d4c020          LDR      r12,[r4,#0x20]        ;3615
001c42  f8cc103c          STR      r1,[r12,#0x3c]        ;3615
001c46  6a21              LDR      r1,[r4,#0x20]         ;3618
001c48  6488              STR      r0,[r1,#0x48]         ;3618
001c4a  6820              LDR      r0,[r4,#0]            ;3621
001c4c  f100014c          ADD      r1,r0,#0x4c           ;3621
001c50  6a20              LDR      r0,[r4,#0x20]         ;3621
001c52  f7fffffe          BL       HAL_DMA_Start_IT
001c56  e041              B        |L1.7388|
                  |L1.7256|
001c58  f8d4c024          LDR      r12,[r4,#0x24]        ;3627
001c5c  f8cc103c          STR      r1,[r12,#0x3c]        ;3627
001c60  6a61              LDR      r1,[r4,#0x24]         ;3630
001c62  6488              STR      r0,[r1,#0x48]         ;3630
001c64  6820              LDR      r0,[r4,#0]            ;3633
001c66  f100014c          ADD      r1,r0,#0x4c           ;3633
001c6a  6a60              LDR      r0,[r4,#0x24]         ;3633
001c6c  f7fffffe          BL       HAL_DMA_Start_IT
001c70  e034              B        |L1.7388|
                  |L1.7282|
001c72  f8d4c028          LDR      r12,[r4,#0x28]        ;3639
001c76  f8cc103c          STR      r1,[r12,#0x3c]        ;3639
001c7a  6aa1              LDR      r1,[r4,#0x28]         ;3642
001c7c  6488              STR      r0,[r1,#0x48]         ;3642
001c7e  6820              LDR      r0,[r4,#0]            ;3645
001c80  f100014c          ADD      r1,r0,#0x4c           ;3645
001c84  6aa0              LDR      r0,[r4,#0x28]         ;3645
001c86  f7fffffe          BL       HAL_DMA_Start_IT
001c8a  e027              B        |L1.7388|
                  |L1.7308|
001c8c  f8d4c02c          LDR      r12,[r4,#0x2c]        ;3651
001c90  f8cc103c          STR      r1,[r12,#0x3c]        ;3651
001c94  6ae1              LDR      r1,[r4,#0x2c]         ;3654
001c96  6488              STR      r0,[r1,#0x48]         ;3654
001c98  6820              LDR      r0,[r4,#0]            ;3657
001c9a  f100014c          ADD      r1,r0,#0x4c           ;3657
001c9e  6ae0              LDR      r0,[r4,#0x2c]         ;3657
001ca0  f7fffffe          BL       HAL_DMA_Start_IT
001ca4  e01a              B        |L1.7388|
                  |L1.7334|
001ca6  f8d4c030          LDR      r12,[r4,#0x30]        ;3663
001caa  4961              LDR      r1,|L1.7728|
001cac  f8cc103c          STR      r1,[r12,#0x3c]        ;3663
001cb0  6b21              LDR      r1,[r4,#0x30]         ;3666
001cb2  6488              STR      r0,[r1,#0x48]         ;3666
001cb4  6820              LDR      r0,[r4,#0]            ;3669
001cb6  f100014c          ADD      r1,r0,#0x4c           ;3669
001cba  6b20              LDR      r0,[r4,#0x30]         ;3669
001cbc  f7fffffe          BL       HAL_DMA_Start_IT
001cc0  e00c              B        |L1.7388|
                  |L1.7362|
001cc2  f8d4c034          LDR      r12,[r4,#0x34]        ;3675
001cc6  495b              LDR      r1,|L1.7732|
001cc8  f8cc103c          STR      r1,[r12,#0x3c]        ;3675
001ccc  6b61              LDR      r1,[r4,#0x34]         ;3678
001cce  6488              STR      r0,[r1,#0x48]         ;3678
001cd0  6820              LDR      r0,[r4,#0]            ;3681
001cd2  f100014c          ADD      r1,r0,#0x4c           ;3681
001cd6  6b60              LDR      r0,[r4,#0x34]         ;3681
001cd8  f7fffffe          BL       HAL_DMA_Start_IT
                  |L1.7388|
001cdc  6821              LDR      r1,[r4,#0]            ;3689
001cde  ea480006          ORR      r0,r8,r6              ;3689
001ce2  6488              STR      r0,[r1,#0x48]         ;3689
001ce4  6820              LDR      r0,[r4,#0]            ;3692
001ce6  68c1              LDR      r1,[r0,#0xc]          ;3692
001ce8  4329              ORRS     r1,r1,r5              ;3692
001cea  60c1              STR      r1,[r0,#0xc]          ;3692
001cec  f8847039          STRB     r7,[r4,#0x39]         ;3694
001cf0  2000              MOVS     r0,#0                 ;3697
001cf2  e8bd81f0          POP      {r4-r8,pc}
;;;3699   
                          ENDP

                  HAL_TIM_DMABurst_ReadStop PROC
;;;3706     */
;;;3707   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
001cf6  b570              PUSH     {r4-r6,lr}
;;;3708   {
001cf8  4604              MOV      r4,r0
001cfa  460d              MOV      r5,r1
;;;3709     /* Check the parameters */
;;;3710     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3711     
;;;3712     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3713     switch(BurstRequestSrc)
001cfc  f5b56f00          CMP      r5,#0x800
001d00  d020              BEQ      |L1.7492|
001d02  dc09              BGT      |L1.7448|
001d04  f5b57f80          CMP      r5,#0x100
001d08  d010              BEQ      |L1.7468|
001d0a  f5b57f00          CMP      r5,#0x200
001d0e  d011              BEQ      |L1.7476|
001d10  f5b56f80          CMP      r5,#0x400
001d14  d125              BNE      |L1.7522|
001d16  e011              B        |L1.7484|
                  |L1.7448|
001d18  f5b55f80          CMP      r5,#0x1000
001d1c  d016              BEQ      |L1.7500|
001d1e  f5b55f00          CMP      r5,#0x2000
001d22  d017              BEQ      |L1.7508|
001d24  f5b54f80          CMP      r5,#0x4000
001d28  d11b              BNE      |L1.7522|
001d2a  e017              B        |L1.7516|
                  |L1.7468|
;;;3714     {
;;;3715       case TIM_DMA_UPDATE:
;;;3716       {  
;;;3717         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
001d2c  69e0              LDR      r0,[r4,#0x1c]
001d2e  f7fffffe          BL       HAL_DMA_Abort
;;;3718       }
;;;3719       break;
001d32  e016              B        |L1.7522|
                  |L1.7476|
;;;3720       case TIM_DMA_CC1:
;;;3721       {  
;;;3722         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
001d34  6a20              LDR      r0,[r4,#0x20]
001d36  f7fffffe          BL       HAL_DMA_Abort
;;;3723       }
;;;3724       break;
001d3a  e012              B        |L1.7522|
                  |L1.7484|
;;;3725       case TIM_DMA_CC2:
;;;3726       {  
;;;3727         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
001d3c  6a60              LDR      r0,[r4,#0x24]
001d3e  f7fffffe          BL       HAL_DMA_Abort
;;;3728       }
;;;3729       break;
001d42  e00e              B        |L1.7522|
                  |L1.7492|
;;;3730       case TIM_DMA_CC3:
;;;3731       {  
;;;3732         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
001d44  6aa0              LDR      r0,[r4,#0x28]
001d46  f7fffffe          BL       HAL_DMA_Abort
;;;3733       }
;;;3734       break;
001d4a  e00a              B        |L1.7522|
                  |L1.7500|
;;;3735       case TIM_DMA_CC4:
;;;3736       {  
;;;3737         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
001d4c  6ae0              LDR      r0,[r4,#0x2c]
001d4e  f7fffffe          BL       HAL_DMA_Abort
;;;3738       }
;;;3739       break;
001d52  e006              B        |L1.7522|
                  |L1.7508|
;;;3740       case TIM_DMA_COM:
;;;3741       {  
;;;3742         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
001d54  6b20              LDR      r0,[r4,#0x30]
001d56  f7fffffe          BL       HAL_DMA_Abort
;;;3743       }
;;;3744       break;
001d5a  e002              B        |L1.7522|
                  |L1.7516|
;;;3745       case TIM_DMA_TRIGGER:
;;;3746       {  
;;;3747         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
001d5c  6b60              LDR      r0,[r4,#0x34]
001d5e  f7fffffe          BL       HAL_DMA_Abort
                  |L1.7522|
;;;3748       }
;;;3749       break;
;;;3750       default:
;;;3751       break;  
;;;3752     }
;;;3753     
;;;3754     /* Disable the TIM Update DMA request */
;;;3755     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
001d62  6820              LDR      r0,[r4,#0]
001d64  68c1              LDR      r1,[r0,#0xc]
001d66  43a9              BICS     r1,r1,r5
001d68  60c1              STR      r1,[r0,#0xc]
;;;3756         
;;;3757     /* Return function status */
;;;3758     return HAL_OK;  
001d6a  2000              MOVS     r0,#0
;;;3759   }
001d6c  bd70              POP      {r4-r6,pc}
;;;3760   
                          ENDP

                  HAL_TIM_GenerateEvent PROC
;;;3779   
;;;3780   HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
001d6e  f8902038          LDRB     r2,[r0,#0x38]
;;;3781   {
;;;3782     /* Check the parameters */
;;;3783     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;3784     assert_param(IS_TIM_EVENT_SOURCE(EventSource));
;;;3785     
;;;3786     /* Process Locked */
;;;3787     __HAL_LOCK(htim);
001d72  2a01              CMP      r2,#1
001d74  d00e              BEQ      |L1.7572|
001d76  2201              MOVS     r2,#1
001d78  f8802038          STRB     r2,[r0,#0x38]
;;;3788     
;;;3789     /* Change the TIM state */
;;;3790     htim->State = HAL_TIM_STATE_BUSY;
001d7c  2302              MOVS     r3,#2
001d7e  f8803039          STRB     r3,[r0,#0x39]
;;;3791     
;;;3792     /* Set the event sources */
;;;3793     htim->Instance->EGR = EventSource;
001d82  6803              LDR      r3,[r0,#0]
001d84  6159              STR      r1,[r3,#0x14]
;;;3794     
;;;3795     /* Change the TIM state */
;;;3796     htim->State = HAL_TIM_STATE_READY;
001d86  f8802039          STRB     r2,[r0,#0x39]
;;;3797     
;;;3798     __HAL_UNLOCK(htim);
001d8a  2100              MOVS     r1,#0
001d8c  f8801038          STRB     r1,[r0,#0x38]
;;;3799     
;;;3800     /* Return function status */
;;;3801     return HAL_OK;  
001d90  2000              MOVS     r0,#0
;;;3802   }
001d92  4770              BX       lr
                  |L1.7572|
001d94  2002              MOVS     r0,#2                 ;3787
001d96  4770              BX       lr
;;;3803   
                          ENDP

                  _Z17TIM_ETR_SetConfigP11TIM_TypeDefjjj PROC ; TIM_ETR_SetConfig(TIM_TypeDef*, unsigned, unsigned, unsigned)
;;;5305     */
;;;5306   static void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
001d98  f8d0c008          LDR      r12,[r0,#8]
;;;5307                          uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
;;;5308   {
;;;5309     uint32_t tmpsmcr = 0;
;;;5310   
;;;5311     tmpsmcr = TIMx->SMCR;
;;;5312   
;;;5313     /* Reset the ETR Bits */
;;;5314     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
001d9c  f42c4c7f          BIC      r12,r12,#0xff00
;;;5315   
;;;5316     /* Set the Prescaler, the Filter value and the Polarity */
;;;5317     tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
001da0  ea422203          ORR      r2,r2,r3,LSL #8
001da4  4311              ORRS     r1,r1,r2
001da6  ea41010c          ORR      r1,r1,r12
;;;5318   
;;;5319     /* Write to TIMx SMCR */
;;;5320     TIMx->SMCR = tmpsmcr;
001daa  6081              STR      r1,[r0,#8]
;;;5321   } 
001dac  4770              BX       lr
;;;5322   
                          ENDP

                  HAL_TIM_ConfigOCrefClear PROC
;;;3817     */ 
;;;3818   HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
001dae  e92d41f0          PUSH     {r4-r8,lr}
;;;3819   { 
001db2  4604              MOV      r4,r0
001db4  460d              MOV      r5,r1
001db6  4616              MOV      r6,r2
;;;3820     /* Check the parameters */
;;;3821     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3822     assert_param(IS_TIM_CHANNELS(Channel));
;;;3823     assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
;;;3824     assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
;;;3825     assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
;;;3826     assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
;;;3827      
;;;3828     /* Process Locked */
;;;3829     __HAL_LOCK(htim);
001db8  f8940038          LDRB     r0,[r4,#0x38]
001dbc  2801              CMP      r0,#1
001dbe  d009              BEQ      |L1.7636|
001dc0  2701              MOVS     r7,#1
001dc2  f8847038          STRB     r7,[r4,#0x38]
;;;3830     
;;;3831     htim->State = HAL_TIM_STATE_BUSY;
001dc6  2002              MOVS     r0,#2
001dc8  f8840039          STRB     r0,[r4,#0x39]
;;;3832     
;;;3833     if(sClearInputConfig->ClearInputSource == TIM_CLEARINPUTSOURCE_ETR)
001dcc  6868              LDR      r0,[r5,#4]
001dce  2801              CMP      r0,#1
001dd0  d003              BEQ      |L1.7642|
001dd2  e008              B        |L1.7654|
                  |L1.7636|
001dd4  2002              MOVS     r0,#2                 ;3829
;;;3834     {
;;;3835       TIM_ETR_SetConfig(htim->Instance, 
;;;3836                         sClearInputConfig->ClearInputPrescaler,
;;;3837                         sClearInputConfig->ClearInputPolarity,
;;;3838                         sClearInputConfig->ClearInputFilter);
;;;3839     }
;;;3840     
;;;3841     switch (Channel)
;;;3842     {
;;;3843       case TIM_CHANNEL_1:
;;;3844       {        
;;;3845         if(sClearInputConfig->ClearInputState != RESET)  
;;;3846         {
;;;3847           /* Enable the Ocref clear feature for Channel 1 */
;;;3848           htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
;;;3849         }
;;;3850         else
;;;3851         {
;;;3852           /* Disable the Ocref clear feature for Channel 1 */
;;;3853           htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;      
;;;3854         }
;;;3855       }    
;;;3856       break;
;;;3857       case TIM_CHANNEL_2:    
;;;3858       { 
;;;3859         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance)); 
;;;3860         if(sClearInputConfig->ClearInputState != RESET)  
;;;3861         {
;;;3862           /* Enable the Ocref clear feature for Channel 2 */
;;;3863           htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
;;;3864         }
;;;3865         else
;;;3866         {
;;;3867           /* Disable the Ocref clear feature for Channel 2 */
;;;3868           htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;      
;;;3869         }
;;;3870       } 
;;;3871       break;
;;;3872       case TIM_CHANNEL_3:   
;;;3873       {  
;;;3874         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3875         if(sClearInputConfig->ClearInputState != RESET)  
;;;3876         {
;;;3877           /* Enable the Ocref clear feature for Channel 3 */
;;;3878           htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
;;;3879         }
;;;3880         else
;;;3881         {
;;;3882           /* Disable the Ocref clear feature for Channel 3 */
;;;3883           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;      
;;;3884         }
;;;3885       } 
;;;3886       break;
;;;3887       case TIM_CHANNEL_4:    
;;;3888       {  
;;;3889         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3890         if(sClearInputConfig->ClearInputState != RESET)  
;;;3891         {
;;;3892           /* Enable the Ocref clear feature for Channel 4 */
;;;3893           htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
;;;3894         }
;;;3895         else
;;;3896         {
;;;3897           /* Disable the Ocref clear feature for Channel 4 */
;;;3898           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;      
;;;3899         }
;;;3900       } 
;;;3901       break;
;;;3902       default:  
;;;3903       break;
;;;3904     } 
;;;3905   
;;;3906     htim->State = HAL_TIM_STATE_READY;
;;;3907     
;;;3908     __HAL_UNLOCK(htim);
;;;3909     
;;;3910     return HAL_OK;  
;;;3911   }  
001dd6  e8bd81f0          POP      {r4-r8,pc}
                  |L1.7642|
001dda  692b              LDR      r3,[r5,#0x10]         ;3835
001ddc  68aa              LDR      r2,[r5,#8]            ;3835
001dde  68e9              LDR      r1,[r5,#0xc]          ;3835
001de0  6820              LDR      r0,[r4,#0]            ;3835
001de2  f7fffffe          BL       _Z17TIM_ETR_SetConfigP11TIM_TypeDefjjj ; TIM_ETR_SetConfig(TIM_TypeDef*, unsigned, unsigned, unsigned)
                  |L1.7654|
001de6  b136              CBZ      r6,|L1.7670|
001de8  2e04              CMP      r6,#4                 ;3841
001dea  d012              BEQ      |L1.7698|
001dec  2e08              CMP      r6,#8                 ;3841
001dee  d02b              BEQ      |L1.7752|
001df0  2e0c              CMP      r6,#0xc               ;3841
001df2  d144              BNE      |L1.7806|
001df4  e036              B        |L1.7780|
                  |L1.7670|
001df6  6828              LDR      r0,[r5,#0]            ;3845
001df8  b128              CBZ      r0,|L1.7686|
001dfa  6820              LDR      r0,[r4,#0]            ;3848
001dfc  6981              LDR      r1,[r0,#0x18]         ;3848
001dfe  f0410180          ORR      r1,r1,#0x80           ;3848
001e02  6181              STR      r1,[r0,#0x18]         ;3848
001e04  e03b              B        |L1.7806|
                  |L1.7686|
001e06  6820              LDR      r0,[r4,#0]            ;3853
001e08  6981              LDR      r1,[r0,#0x18]         ;3853
001e0a  f0210180          BIC      r1,r1,#0x80           ;3853
001e0e  6181              STR      r1,[r0,#0x18]         ;3853
001e10  e035              B        |L1.7806|
                  |L1.7698|
001e12  6828              LDR      r0,[r5,#0]            ;3860
001e14  b190              CBZ      r0,|L1.7740|
001e16  6820              LDR      r0,[r4,#0]            ;3863
001e18  6981              LDR      r1,[r0,#0x18]         ;3863
001e1a  f4414100          ORR      r1,r1,#0x8000         ;3863
001e1e  6181              STR      r1,[r0,#0x18]         ;3863
001e20  e02d              B        |L1.7806|
001e22  0000              DCW      0x0000
                  |L1.7716|
                          DCD      TIM_DMAError
                  |L1.7720|
                          DCD      TIM_DMADelayPulseCplt
                  |L1.7724|
                          DCD      _Z24TIM_DMAPeriodElapsedCpltP19__DMA_HandleTypeDef ; TIM_DMAPeriodElapsedCplt(__DMA_HandleTypeDef*)
                  |L1.7728|
                          DCD      TIMEx_DMACommutationCplt
                  |L1.7732|
                          DCD      _Z18TIM_DMATriggerCpltP19__DMA_HandleTypeDef ; TIM_DMATriggerCplt(__DMA_HandleTypeDef*)
                  |L1.7736|
                          DCD      TIM_DMACaptureCplt
                  |L1.7740|
001e3c  6820              LDR      r0,[r4,#0]            ;3868
001e3e  6981              LDR      r1,[r0,#0x18]         ;3868
001e40  f4214100          BIC      r1,r1,#0x8000         ;3868
001e44  6181              STR      r1,[r0,#0x18]         ;3868
001e46  e01a              B        |L1.7806|
                  |L1.7752|
001e48  6828              LDR      r0,[r5,#0]            ;3875
001e4a  b128              CBZ      r0,|L1.7768|
001e4c  6820              LDR      r0,[r4,#0]            ;3878
001e4e  69c1              LDR      r1,[r0,#0x1c]         ;3878
001e50  f0410180          ORR      r1,r1,#0x80           ;3878
001e54  61c1              STR      r1,[r0,#0x1c]         ;3878
001e56  e012              B        |L1.7806|
                  |L1.7768|
001e58  6820              LDR      r0,[r4,#0]            ;3883
001e5a  69c1              LDR      r1,[r0,#0x1c]         ;3883
001e5c  f0210180          BIC      r1,r1,#0x80           ;3883
001e60  61c1              STR      r1,[r0,#0x1c]         ;3883
001e62  e00c              B        |L1.7806|
                  |L1.7780|
001e64  6828              LDR      r0,[r5,#0]            ;3890
001e66  b128              CBZ      r0,|L1.7796|
001e68  6820              LDR      r0,[r4,#0]            ;3893
001e6a  69c1              LDR      r1,[r0,#0x1c]         ;3893
001e6c  f4414100          ORR      r1,r1,#0x8000         ;3893
001e70  61c1              STR      r1,[r0,#0x1c]         ;3893
001e72  e004              B        |L1.7806|
                  |L1.7796|
001e74  6820              LDR      r0,[r4,#0]            ;3898
001e76  69c1              LDR      r1,[r0,#0x1c]         ;3898
001e78  f4214100          BIC      r1,r1,#0x8000         ;3898
001e7c  61c1              STR      r1,[r0,#0x1c]         ;3898
                  |L1.7806|
001e7e  f8847039          STRB     r7,[r4,#0x39]         ;3906
001e82  2000              MOVS     r0,#0                 ;3908
001e84  f8840038          STRB     r0,[r4,#0x38]         ;3908
001e88  e8bd81f0          POP      {r4-r8,pc}
;;;3912   
                          ENDP

                  _Z18TIM_ITRx_SetConfigP11TIM_TypeDeft PROC ; TIM_ITRx_SetConfig(TIM_TypeDef*, unsigned short)
;;;5274     */
;;;5275   static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t TIM_ITRx)
001e8c  6882              LDR      r2,[r0,#8]
;;;5276   {
;;;5277     uint32_t tmpsmcr = 0;
;;;5278     
;;;5279      /* Get the TIMx SMCR register value */
;;;5280      tmpsmcr = TIMx->SMCR;
;;;5281      /* Reset the TS Bits */
;;;5282      tmpsmcr &= ~TIM_SMCR_TS;
001e8e  f0220270          BIC      r2,r2,#0x70
;;;5283      /* Set the Input Trigger source and the slave mode*/
;;;5284      tmpsmcr |= TIM_ITRx | TIM_SLAVEMODE_EXTERNAL1;
001e92  4311              ORRS     r1,r1,r2
001e94  f0410107          ORR      r1,r1,#7
;;;5285      /* Write to TIMx SMCR */
;;;5286      TIMx->SMCR = tmpsmcr;
001e98  6081              STR      r1,[r0,#8]
;;;5287   }
001e9a  4770              BX       lr
;;;5288   
                          ENDP

                  _Z24TIM_TI1_ConfigInputStageP11TIM_TypeDefjj PROC ; TIM_TI1_ConfigInputStage(TIM_TypeDef*, unsigned, unsigned)
;;;5057     */
;;;5058   static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
001e9c  6a03              LDR      r3,[r0,#0x20]
;;;5059   {
;;;5060     uint32_t tmpccmr1 = 0;
;;;5061     uint32_t tmpccer = 0;
;;;5062     
;;;5063     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5064     tmpccer = TIMx->CCER;
;;;5065     TIMx->CCER &= ~TIM_CCER_CC1E;
001e9e  f8d0c020          LDR      r12,[r0,#0x20]
001ea2  f02c0c01          BIC      r12,r12,#1
001ea6  f8c0c020          STR      r12,[r0,#0x20]
;;;5066     tmpccmr1 = TIMx->CCMR1;    
001eaa  f8d0c018          LDR      r12,[r0,#0x18]
;;;5067     
;;;5068     /* Set the filter */
;;;5069     tmpccmr1 &= ~TIM_CCMR1_IC1F;
001eae  f02c0cf0          BIC      r12,r12,#0xf0
;;;5070     tmpccmr1 |= (TIM_ICFilter << 4);
001eb2  ea4c1202          ORR      r2,r12,r2,LSL #4
;;;5071     
;;;5072     /* Select the Polarity and set the CC1E Bit */
;;;5073     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
001eb6  f023030a          BIC      r3,r3,#0xa
;;;5074     tmpccer |= TIM_ICPolarity;
001eba  4319              ORRS     r1,r1,r3
;;;5075     
;;;5076     /* Write to TIMx CCMR1 and CCER registers */
;;;5077     TIMx->CCMR1 = tmpccmr1;
001ebc  6182              STR      r2,[r0,#0x18]
;;;5078     TIMx->CCER = tmpccer;
001ebe  6201              STR      r1,[r0,#0x20]
;;;5079   }
001ec0  4770              BX       lr
;;;5080   
                          ENDP

                  _Z24TIM_TI2_ConfigInputStageP11TIM_TypeDefjj PROC ; TIM_TI2_ConfigInputStage(TIM_TypeDef*, unsigned, unsigned)
;;;5140     */
;;;5141   static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
001ec2  6a03              LDR      r3,[r0,#0x20]
;;;5142   {
;;;5143     uint32_t tmpccmr1 = 0;
;;;5144     uint32_t tmpccer = 0;
;;;5145     
;;;5146     /* Disable the Channel 2: Reset the CC2E Bit */
;;;5147     TIMx->CCER &= ~TIM_CCER_CC2E;
001ec4  f0230310          BIC      r3,r3,#0x10
001ec8  6203              STR      r3,[r0,#0x20]
;;;5148     tmpccmr1 = TIMx->CCMR1;
001eca  f8d0c018          LDR      r12,[r0,#0x18]
;;;5149     tmpccer = TIMx->CCER;
001ece  6a03              LDR      r3,[r0,#0x20]
;;;5150     
;;;5151     /* Set the filter */
;;;5152     tmpccmr1 &= ~TIM_CCMR1_IC2F;
001ed0  f42c4c70          BIC      r12,r12,#0xf000
;;;5153     tmpccmr1 |= (TIM_ICFilter << 12);
001ed4  ea4c3202          ORR      r2,r12,r2,LSL #12
;;;5154   
;;;5155     /* Select the Polarity and set the CC2E Bit */
;;;5156     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
001ed8  f02303a0          BIC      r3,r3,#0xa0
;;;5157     tmpccer |= (TIM_ICPolarity << 4);
001edc  ea431101          ORR      r1,r3,r1,LSL #4
;;;5158   
;;;5159     /* Write to TIMx CCMR1 and CCER registers */
;;;5160     TIMx->CCMR1 = tmpccmr1 ;
001ee0  6182              STR      r2,[r0,#0x18]
;;;5161     TIMx->CCER = tmpccer;
001ee2  6201              STR      r1,[r0,#0x20]
;;;5162   }
001ee4  4770              BX       lr
;;;5163   
                          ENDP

                  HAL_TIM_ConfigClockSource PROC
;;;3920     */ 
;;;3921   HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)    
001ee6  b570              PUSH     {r4-r6,lr}
;;;3922   {
001ee8  4604              MOV      r4,r0
;;;3923     uint32_t tmpsmcr = 0;
;;;3924       
;;;3925     /* Process Locked */
;;;3926     __HAL_LOCK(htim);
001eea  f8940038          LDRB     r0,[r4,#0x38]
001eee  2801              CMP      r0,#1
001ef0  d018              BEQ      |L1.7972|
001ef2  2501              MOVS     r5,#1
001ef4  f8845038          STRB     r5,[r4,#0x38]
;;;3927     
;;;3928     htim->State = HAL_TIM_STATE_BUSY;
001ef8  2002              MOVS     r0,#2
001efa  f8840039          STRB     r0,[r4,#0x39]
;;;3929     
;;;3930     /* Check the parameters */
;;;3931     assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
;;;3932     assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;3933     assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;3934     assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;3935     
;;;3936     /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
;;;3937     tmpsmcr = htim->Instance->SMCR;
001efe  6820              LDR      r0,[r4,#0]
001f00  6882              LDR      r2,[r0,#8]
;;;3938     tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
001f02  f0220277          BIC      r2,r2,#0x77
;;;3939     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
001f06  f422427f          BIC      r2,r2,#0xff00
;;;3940     htim->Instance->SMCR = tmpsmcr;
001f0a  6082              STR      r2,[r0,#8]
;;;3941     
;;;3942     switch (sClockSourceConfig->ClockSource)
001f0c  6808              LDR      r0,[r1,#0]
001f0e  2850              CMP      r0,#0x50
001f10  d03a              BEQ      |L1.8072|
001f12  dc0e              BGT      |L1.7986|
001f14  2820              CMP      r0,#0x20
001f16  d05f              BEQ      |L1.8152|
001f18  dc06              BGT      |L1.7976|
001f1a  2800              CMP      r0,#0
001f1c  d052              BEQ      |L1.8132|
001f1e  2810              CMP      r0,#0x10
001f20  d163              BNE      |L1.8170|
001f22  e054              B        |L1.8142|
                  |L1.7972|
001f24  2002              MOVS     r0,#2                 ;3926
;;;3943     {
;;;3944       case TIM_CLOCKSOURCE_INTERNAL:
;;;3945       { 
;;;3946         assert_param(IS_TIM_INSTANCE(htim->Instance));      
;;;3947         /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;3948         htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3949       }
;;;3950       break;
;;;3951       
;;;3952       case TIM_CLOCKSOURCE_ETRMODE1:
;;;3953       {
;;;3954         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;3955         /* Configure the ETR Clock source */
;;;3956         TIM_ETR_SetConfig(htim->Instance, 
;;;3957                           sClockSourceConfig->ClockPrescaler, 
;;;3958                           sClockSourceConfig->ClockPolarity, 
;;;3959                           sClockSourceConfig->ClockFilter);
;;;3960         /* Get the TIMx SMCR register value */
;;;3961         tmpsmcr = htim->Instance->SMCR;
;;;3962         /* Reset the SMS and TS Bits */
;;;3963         tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;3964         /* Select the External clock mode1 and the ETRF trigger */
;;;3965         tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
;;;3966         /* Write to TIMx SMCR */
;;;3967         htim->Instance->SMCR = tmpsmcr;
;;;3968       }
;;;3969       break;
;;;3970       
;;;3971       case TIM_CLOCKSOURCE_ETRMODE2:
;;;3972       {
;;;3973         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;3974         /* Configure the ETR Clock source */
;;;3975         TIM_ETR_SetConfig(htim->Instance, 
;;;3976                           sClockSourceConfig->ClockPrescaler, 
;;;3977                           sClockSourceConfig->ClockPolarity,
;;;3978                           sClockSourceConfig->ClockFilter);
;;;3979         /* Enable the External clock mode2 */
;;;3980         htim->Instance->SMCR |= TIM_SMCR_ECE;
;;;3981       }
;;;3982       break;
;;;3983       
;;;3984       case TIM_CLOCKSOURCE_TI1:
;;;3985       {
;;;3986         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3987         TIM_TI1_ConfigInputStage(htim->Instance, 
;;;3988                           sClockSourceConfig->ClockPolarity, 
;;;3989                           sClockSourceConfig->ClockFilter);
;;;3990         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
;;;3991       }
;;;3992       break;
;;;3993       case TIM_CLOCKSOURCE_TI2:
;;;3994       {
;;;3995         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3996         TIM_TI2_ConfigInputStage(htim->Instance, 
;;;3997                           sClockSourceConfig->ClockPolarity, 
;;;3998                           sClockSourceConfig->ClockFilter);
;;;3999         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
;;;4000       }
;;;4001       break;
;;;4002       case TIM_CLOCKSOURCE_TI1ED:
;;;4003       {
;;;4004         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4005         TIM_TI1_ConfigInputStage(htim->Instance, 
;;;4006                           sClockSourceConfig->ClockPolarity,
;;;4007                           sClockSourceConfig->ClockFilter);
;;;4008         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
;;;4009       }
;;;4010       break;
;;;4011       case TIM_CLOCKSOURCE_ITR0:
;;;4012       {
;;;4013         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4014         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
;;;4015       }
;;;4016       break;
;;;4017       case TIM_CLOCKSOURCE_ITR1:
;;;4018       {
;;;4019         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4020         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
;;;4021       }
;;;4022       break;
;;;4023       case TIM_CLOCKSOURCE_ITR2:
;;;4024       {
;;;4025         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4026         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
;;;4027       }
;;;4028       break;
;;;4029       case TIM_CLOCKSOURCE_ITR3:
;;;4030       {
;;;4031         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4032         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
;;;4033       }
;;;4034       break;
;;;4035       
;;;4036       default:
;;;4037       break;    
;;;4038     }
;;;4039     htim->State = HAL_TIM_STATE_READY;
;;;4040     
;;;4041     __HAL_UNLOCK(htim);
;;;4042     
;;;4043     return HAL_OK;
;;;4044   }
001f26  bd70              POP      {r4-r6,pc}
                  |L1.7976|
001f28  2830              CMP      r0,#0x30              ;3942
001f2a  d05a              BEQ      |L1.8162|
001f2c  2840              CMP      r0,#0x40              ;3942
001f2e  d15c              BNE      |L1.8170|
001f30  e03e              B        |L1.8112|
                  |L1.7986|
001f32  2860              CMP      r0,#0x60              ;3942
001f34  d032              BEQ      |L1.8092|
001f36  2870              CMP      r0,#0x70              ;3942
001f38  d00c              BEQ      |L1.8020|
001f3a  f5b05f80          CMP      r0,#0x1000            ;3942
001f3e  d003              BEQ      |L1.8008|
001f40  f5b05f00          CMP      r0,#0x2000            ;3942
001f44  d151              BNE      |L1.8170|
001f46  e013              B        |L1.8048|
                  |L1.8008|
001f48  6820              LDR      r0,[r4,#0]            ;3948
001f4a  6881              LDR      r1,[r0,#8]            ;3948
001f4c  f0210107          BIC      r1,r1,#7              ;3948
001f50  6081              STR      r1,[r0,#8]            ;3948
001f52  e04a              B        |L1.8170|
                  |L1.8020|
001f54  68cb              LDR      r3,[r1,#0xc]          ;3956
001f56  684a              LDR      r2,[r1,#4]            ;3956
001f58  6889              LDR      r1,[r1,#8]            ;3956
001f5a  6820              LDR      r0,[r4,#0]            ;3956
001f5c  f7fffffe          BL       _Z17TIM_ETR_SetConfigP11TIM_TypeDefjjj ; TIM_ETR_SetConfig(TIM_TypeDef*, unsigned, unsigned, unsigned)
001f60  6820              LDR      r0,[r4,#0]            ;3961
001f62  6881              LDR      r1,[r0,#8]            ;3961
001f64  f0210177          BIC      r1,r1,#0x77           ;3963
001f68  f0410177          ORR      r1,r1,#0x77           ;3965
001f6c  6081              STR      r1,[r0,#8]            ;3967
001f6e  e03c              B        |L1.8170|
                  |L1.8048|
001f70  68cb              LDR      r3,[r1,#0xc]          ;3975
001f72  684a              LDR      r2,[r1,#4]            ;3975
001f74  6889              LDR      r1,[r1,#8]            ;3975
001f76  6820              LDR      r0,[r4,#0]            ;3975
001f78  f7fffffe          BL       _Z17TIM_ETR_SetConfigP11TIM_TypeDefjjj ; TIM_ETR_SetConfig(TIM_TypeDef*, unsigned, unsigned, unsigned)
001f7c  6820              LDR      r0,[r4,#0]            ;3980
001f7e  6881              LDR      r1,[r0,#8]            ;3980
001f80  f4414180          ORR      r1,r1,#0x4000         ;3980
001f84  6081              STR      r1,[r0,#8]            ;3980
001f86  e030              B        |L1.8170|
                  |L1.8072|
001f88  68ca              LDR      r2,[r1,#0xc]          ;3987
001f8a  6849              LDR      r1,[r1,#4]            ;3987
001f8c  6820              LDR      r0,[r4,#0]            ;3987
001f8e  f7fffffe          BL       _Z24TIM_TI1_ConfigInputStageP11TIM_TypeDefjj ; TIM_TI1_ConfigInputStage(TIM_TypeDef*, unsigned, unsigned)
001f92  2150              MOVS     r1,#0x50              ;3990
001f94  6820              LDR      r0,[r4,#0]            ;3990
001f96  f7fffffe          BL       _Z18TIM_ITRx_SetConfigP11TIM_TypeDeft ; TIM_ITRx_SetConfig(TIM_TypeDef*, unsigned short)
001f9a  e026              B        |L1.8170|
                  |L1.8092|
001f9c  68ca              LDR      r2,[r1,#0xc]          ;3996
001f9e  6849              LDR      r1,[r1,#4]            ;3996
001fa0  6820              LDR      r0,[r4,#0]            ;3996
001fa2  f7fffffe          BL       _Z24TIM_TI2_ConfigInputStageP11TIM_TypeDefjj ; TIM_TI2_ConfigInputStage(TIM_TypeDef*, unsigned, unsigned)
001fa6  2160              MOVS     r1,#0x60              ;3999
001fa8  6820              LDR      r0,[r4,#0]            ;3999
001faa  f7fffffe          BL       _Z18TIM_ITRx_SetConfigP11TIM_TypeDeft ; TIM_ITRx_SetConfig(TIM_TypeDef*, unsigned short)
001fae  e01c              B        |L1.8170|
                  |L1.8112|
001fb0  68ca              LDR      r2,[r1,#0xc]          ;4005
001fb2  6849              LDR      r1,[r1,#4]            ;4005
001fb4  6820              LDR      r0,[r4,#0]            ;4005
001fb6  f7fffffe          BL       _Z24TIM_TI1_ConfigInputStageP11TIM_TypeDefjj ; TIM_TI1_ConfigInputStage(TIM_TypeDef*, unsigned, unsigned)
001fba  2140              MOVS     r1,#0x40              ;4008
001fbc  6820              LDR      r0,[r4,#0]            ;4008
001fbe  f7fffffe          BL       _Z18TIM_ITRx_SetConfigP11TIM_TypeDeft ; TIM_ITRx_SetConfig(TIM_TypeDef*, unsigned short)
001fc2  e012              B        |L1.8170|
                  |L1.8132|
001fc4  2100              MOVS     r1,#0                 ;4014
001fc6  6820              LDR      r0,[r4,#0]            ;4014
001fc8  f7fffffe          BL       _Z18TIM_ITRx_SetConfigP11TIM_TypeDeft ; TIM_ITRx_SetConfig(TIM_TypeDef*, unsigned short)
001fcc  e00d              B        |L1.8170|
                  |L1.8142|
001fce  2110              MOVS     r1,#0x10              ;4020
001fd0  6820              LDR      r0,[r4,#0]            ;4020
001fd2  f7fffffe          BL       _Z18TIM_ITRx_SetConfigP11TIM_TypeDeft ; TIM_ITRx_SetConfig(TIM_TypeDef*, unsigned short)
001fd6  e008              B        |L1.8170|
                  |L1.8152|
001fd8  2120              MOVS     r1,#0x20              ;4026
001fda  6820              LDR      r0,[r4,#0]            ;4026
001fdc  f7fffffe          BL       _Z18TIM_ITRx_SetConfigP11TIM_TypeDeft ; TIM_ITRx_SetConfig(TIM_TypeDef*, unsigned short)
001fe0  e003              B        |L1.8170|
                  |L1.8162|
001fe2  2130              MOVS     r1,#0x30              ;4032
001fe4  6820              LDR      r0,[r4,#0]            ;4032
001fe6  f7fffffe          BL       _Z18TIM_ITRx_SetConfigP11TIM_TypeDeft ; TIM_ITRx_SetConfig(TIM_TypeDef*, unsigned short)
                  |L1.8170|
001fea  f8845039          STRB     r5,[r4,#0x39]         ;4039
001fee  2000              MOVS     r0,#0                 ;4041
001ff0  f8840038          STRB     r0,[r4,#0x38]         ;4041
001ff4  bd70              POP      {r4-r6,pc}
;;;4045   
                          ENDP

                  HAL_TIM_ConfigTI1Input PROC
;;;4058     */
;;;4059   HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
001ff6  6800              LDR      r0,[r0,#0]
;;;4060   {
;;;4061     uint32_t tmpcr2 = 0;
;;;4062     
;;;4063     /* Check the parameters */
;;;4064     assert_param(IS_TIM_XOR_INSTANCE(htim->Instance)); 
;;;4065     assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
;;;4066   
;;;4067     /* Get the TIMx CR2 register value */
;;;4068     tmpcr2 = htim->Instance->CR2;
001ff8  6842              LDR      r2,[r0,#4]
;;;4069   
;;;4070     /* Reset the TI1 selection */
;;;4071     tmpcr2 &= ~TIM_CR2_TI1S;
001ffa  f0220280          BIC      r2,r2,#0x80
;;;4072   
;;;4073     /* Set the TI1 selection */
;;;4074     tmpcr2 |= TI1_Selection;
001ffe  4311              ORRS     r1,r1,r2
;;;4075     
;;;4076     /* Write to TIMxCR2 */
;;;4077     htim->Instance->CR2 = tmpcr2;
002000  6041              STR      r1,[r0,#4]
;;;4078   
;;;4079     return HAL_OK;
002002  2000              MOVS     r0,#0
;;;4080   }
002004  4770              BX       lr
;;;4081   
                          ENDP

                  _Z24TIM_SlaveTimer_SetConfigP17TIM_HandleTypeDefP22TIM_SlaveConfigTypeDef PROC ; TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef*, TIM_SlaveConfigTypeDef*)
;;;4920     */
;;;4921   static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
002006  6802              LDR      r2,[r0,#0]
;;;4922                                 TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;4923   {
;;;4924     uint32_t tmpsmcr = 0;
;;;4925     uint32_t tmpccmr1 = 0;
;;;4926     uint32_t tmpccer = 0;
;;;4927   
;;;4928    /* Get the TIMx SMCR register value */
;;;4929     tmpsmcr = htim->Instance->SMCR;
002008  6893              LDR      r3,[r2,#8]
;;;4930   
;;;4931     /* Reset the Trigger Selection Bits */
;;;4932     tmpsmcr &= ~TIM_SMCR_TS;
00200a  f0230370          BIC      r3,r3,#0x70
;;;4933     /* Set the Input Trigger source */
;;;4934     tmpsmcr |= sSlaveConfig->InputTrigger;
00200e  f8d1c004          LDR      r12,[r1,#4]
002012  ea4c0303          ORR      r3,r12,r3
;;;4935   
;;;4936     /* Reset the slave mode Bits */
;;;4937     tmpsmcr &= ~TIM_SMCR_SMS;
002016  f0230307          BIC      r3,r3,#7
;;;4938     /* Set the slave mode */
;;;4939     tmpsmcr |= sSlaveConfig->SlaveMode;
00201a  f8d1c000          LDR      r12,[r1,#0]
00201e  ea4c0303          ORR      r3,r12,r3
;;;4940   
;;;4941     /* Write to TIMx SMCR */
;;;4942     htim->Instance->SMCR = tmpsmcr;
002022  6093              STR      r3,[r2,#8]
;;;4943     
;;;4944     /* Configure the trigger prescaler, filter, and polarity */
;;;4945     switch (sSlaveConfig->InputTrigger)
002024  684a              LDR      r2,[r1,#4]
002026  f0120f0f          TST      r2,#0xf
00202a  d120              BNE      |L1.8302|
00202c  1112              ASRS     r2,r2,#4
00202e  2a08              CMP      r2,#8
002030  d21d              BCS      |L1.8302|
002032  e8dff002          TBB      [pc,r2]
002036  1c1c              DCB      0x1c,0x1c
002038  1c1c091d          DCB      0x1c,0x1c,0x09,0x1d
00203c  2104              DCB      0x21,0x04
;;;4946     {
;;;4947     case TIM_TS_ETRF:
;;;4948       {
;;;4949         /* Check the parameters */
;;;4950         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;4951         assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
;;;4952         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4953         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4954         /* Configure the ETR Trigger source */
;;;4955         TIM_ETR_SetConfig(htim->Instance, 
00203e  690b              LDR      r3,[r1,#0x10]
002040  688a              LDR      r2,[r1,#8]
002042  68c9              LDR      r1,[r1,#0xc]
002044  6800              LDR      r0,[r0,#0]
002046  e7fe              B        _Z17TIM_ETR_SetConfigP11TIM_TypeDefjjj ; TIM_ETR_SetConfig(TIM_TypeDef*, unsigned, unsigned, unsigned)
;;;4956                           sSlaveConfig->TriggerPrescaler, 
;;;4957                           sSlaveConfig->TriggerPolarity, 
;;;4958                           sSlaveConfig->TriggerFilter);
;;;4959       }
;;;4960       break;
;;;4961       
;;;4962     case TIM_TS_TI1F_ED:
;;;4963       {
;;;4964         /* Check the parameters */
;;;4965         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4966         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4967         
;;;4968         /* Disable the Channel 1: Reset the CC1E Bit */
;;;4969         tmpccer = htim->Instance->CCER;
002048  6802              LDR      r2,[r0,#0]
00204a  6a13              LDR      r3,[r2,#0x20]
;;;4970         htim->Instance->CCER &= ~TIM_CCER_CC1E;
00204c  f8d2c020          LDR      r12,[r2,#0x20]
002050  f02c0c01          BIC      r12,r12,#1
002054  f8c2c020          STR      r12,[r2,#0x20]
;;;4971         tmpccmr1 = htim->Instance->CCMR1;    
002058  6802              LDR      r2,[r0,#0]
00205a  f8d2c018          LDR      r12,[r2,#0x18]
;;;4972         
;;;4973         /* Set the filter */
;;;4974         tmpccmr1 &= ~TIM_CCMR1_IC1F;
00205e  f02c0cf0          BIC      r12,r12,#0xf0
;;;4975         tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4);
002062  6909              LDR      r1,[r1,#0x10]
002064  ea4c1101          ORR      r1,r12,r1,LSL #4
;;;4976         
;;;4977         /* Write to TIMx CCMR1 and CCER registers */
;;;4978         htim->Instance->CCMR1 = tmpccmr1;
002068  6191              STR      r1,[r2,#0x18]
;;;4979         htim->Instance->CCER = tmpccer;                               
00206a  6800              LDR      r0,[r0,#0]
00206c  6203              STR      r3,[r0,#0x20]
                  |L1.8302|
;;;4980                                  
;;;4981       }
;;;4982       break;
;;;4983       
;;;4984     case TIM_TS_TI1FP1:
;;;4985       {
;;;4986         /* Check the parameters */
;;;4987         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4988         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4989         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4990   
;;;4991         /* Configure TI1 Filter and Polarity */
;;;4992         TIM_TI1_ConfigInputStage(htim->Instance,
;;;4993                                  sSlaveConfig->TriggerPolarity,
;;;4994                                  sSlaveConfig->TriggerFilter);
;;;4995       }
;;;4996       break;
;;;4997       
;;;4998     case TIM_TS_TI2FP2:
;;;4999       {
;;;5000         /* Check the parameters */
;;;5001         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5002         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5003         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5004         
;;;5005         /* Configure TI2 Filter and Polarity */
;;;5006         TIM_TI2_ConfigInputStage(htim->Instance,
;;;5007                                   sSlaveConfig->TriggerPolarity,
;;;5008                                   sSlaveConfig->TriggerFilter);
;;;5009       }
;;;5010       break;
;;;5011       
;;;5012     case TIM_TS_ITR0:
;;;5013       {
;;;5014         /* Check the parameter */
;;;5015         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5016       }
;;;5017       break;
;;;5018       
;;;5019     case TIM_TS_ITR1:
;;;5020       {
;;;5021         /* Check the parameter */
;;;5022         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5023       }
;;;5024       break;
;;;5025       
;;;5026     case TIM_TS_ITR2:
;;;5027       {
;;;5028         /* Check the parameter */
;;;5029         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5030       }
;;;5031       break;
;;;5032       
;;;5033     case TIM_TS_ITR3:
;;;5034       {
;;;5035         /* Check the parameter */
;;;5036         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5037       }
;;;5038       break;
;;;5039          
;;;5040     default:
;;;5041       break;
;;;5042     }
;;;5043   }
00206e  4770              BX       lr
002070  690a              LDR      r2,[r1,#0x10]         ;4992
002072  6889              LDR      r1,[r1,#8]            ;4992
002074  6800              LDR      r0,[r0,#0]            ;4992
002076  e7fe              B        _Z24TIM_TI1_ConfigInputStageP11TIM_TypeDefjj ; TIM_TI1_ConfigInputStage(TIM_TypeDef*, unsigned, unsigned)
002078  690a              LDR      r2,[r1,#0x10]         ;5006
00207a  6889              LDR      r1,[r1,#8]            ;5006
00207c  6800              LDR      r0,[r0,#0]            ;5006
00207e  e7fe              B        _Z24TIM_TI2_ConfigInputStageP11TIM_TypeDefjj ; TIM_TI2_ConfigInputStage(TIM_TypeDef*, unsigned, unsigned)
;;;5044   
                          ENDP

                  HAL_TIM_SlaveConfigSynchronization PROC
;;;4091     */
;;;4092   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
002080  b570              PUSH     {r4-r6,lr}
;;;4093   {
002082  4604              MOV      r4,r0
;;;4094     /* Check the parameters */
;;;4095     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4096     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4097     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4098      
;;;4099     __HAL_LOCK(htim);
002084  f8940038          LDRB     r0,[r4,#0x38]
002088  2801              CMP      r0,#1
00208a  d018              BEQ      |L1.8382|
00208c  2501              MOVS     r5,#1
00208e  f8845038          STRB     r5,[r4,#0x38]
;;;4100     
;;;4101     htim->State = HAL_TIM_STATE_BUSY;
002092  2002              MOVS     r0,#2
002094  f8840039          STRB     r0,[r4,#0x39]
;;;4102   
;;;4103     TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
002098  4620              MOV      r0,r4
00209a  f7fffffe          BL       _Z24TIM_SlaveTimer_SetConfigP17TIM_HandleTypeDefP22TIM_SlaveConfigTypeDef ; TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef*, TIM_SlaveConfigTypeDef*)
;;;4104     
;;;4105     /* Disable Trigger Interrupt */
;;;4106     __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
00209e  6820              LDR      r0,[r4,#0]
0020a0  68c1              LDR      r1,[r0,#0xc]
0020a2  f0210140          BIC      r1,r1,#0x40
0020a6  60c1              STR      r1,[r0,#0xc]
;;;4107     
;;;4108     /* Disable Trigger DMA request */
;;;4109     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
0020a8  6820              LDR      r0,[r4,#0]
0020aa  68c1              LDR      r1,[r0,#0xc]
0020ac  f4214180          BIC      r1,r1,#0x4000
0020b0  60c1              STR      r1,[r0,#0xc]
;;;4110     
;;;4111     htim->State = HAL_TIM_STATE_READY;
0020b2  f8845039          STRB     r5,[r4,#0x39]
;;;4112        
;;;4113     __HAL_UNLOCK(htim);  
0020b6  2000              MOVS     r0,#0
0020b8  f8840038          STRB     r0,[r4,#0x38]
;;;4114     
;;;4115     return HAL_OK;
;;;4116   } 
0020bc  bd70              POP      {r4-r6,pc}
                  |L1.8382|
0020be  2002              MOVS     r0,#2                 ;4099
0020c0  bd70              POP      {r4-r6,pc}
;;;4117   
                          ENDP

                  HAL_TIM_SlaveConfigSynchronization_IT PROC
;;;4126     */
;;;4127   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim, 
0020c2  b570              PUSH     {r4-r6,lr}
;;;4128                                                           TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;4129   {
0020c4  4604              MOV      r4,r0
;;;4130     /* Check the parameters */
;;;4131     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4132     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4133     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4134     
;;;4135     __HAL_LOCK(htim);
0020c6  f8940038          LDRB     r0,[r4,#0x38]
0020ca  2801              CMP      r0,#1
0020cc  d018              BEQ      |L1.8448|
0020ce  2501              MOVS     r5,#1
0020d0  f8845038          STRB     r5,[r4,#0x38]
;;;4136   
;;;4137     htim->State = HAL_TIM_STATE_BUSY;
0020d4  2002              MOVS     r0,#2
0020d6  f8840039          STRB     r0,[r4,#0x39]
;;;4138     
;;;4139     TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
0020da  4620              MOV      r0,r4
0020dc  f7fffffe          BL       _Z24TIM_SlaveTimer_SetConfigP17TIM_HandleTypeDefP22TIM_SlaveConfigTypeDef ; TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef*, TIM_SlaveConfigTypeDef*)
;;;4140     
;;;4141     /* Enable Trigger Interrupt */
;;;4142     __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
0020e0  6820              LDR      r0,[r4,#0]
0020e2  68c1              LDR      r1,[r0,#0xc]
0020e4  f0410140          ORR      r1,r1,#0x40
0020e8  60c1              STR      r1,[r0,#0xc]
;;;4143     
;;;4144     /* Disable Trigger DMA request */
;;;4145     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
0020ea  6820              LDR      r0,[r4,#0]
0020ec  68c1              LDR      r1,[r0,#0xc]
0020ee  f4214180          BIC      r1,r1,#0x4000
0020f2  60c1              STR      r1,[r0,#0xc]
;;;4146     
;;;4147     htim->State = HAL_TIM_STATE_READY;
0020f4  f8845039          STRB     r5,[r4,#0x39]
;;;4148        
;;;4149     __HAL_UNLOCK(htim);  
0020f8  2000              MOVS     r0,#0
0020fa  f8840038          STRB     r0,[r4,#0x38]
;;;4150     
;;;4151     return HAL_OK;
;;;4152   }
0020fe  bd70              POP      {r4-r6,pc}
                  |L1.8448|
002100  2002              MOVS     r0,#2                 ;4135
002102  bd70              POP      {r4-r6,pc}
;;;4153   
                          ENDP

                  HAL_TIM_ReadCapturedValue PROC
;;;4165     */
;;;4166   uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
002104  2200              MOVS     r2,#0
;;;4167   {
;;;4168     uint32_t tmpreg = 0;
;;;4169     
;;;4170     __HAL_LOCK(htim);
002106  f8903038          LDRB     r3,[r0,#0x38]
00210a  2b01              CMP      r3,#1
00210c  d00a              BEQ      |L1.8484|
00210e  2301              MOVS     r3,#1
002110  f8803038          STRB     r3,[r0,#0x38]
002114  b141              CBZ      r1,|L1.8488|
;;;4171     
;;;4172     switch (Channel)
002116  2904              CMP      r1,#4
002118  d009              BEQ      |L1.8494|
00211a  2908              CMP      r1,#8
00211c  d00a              BEQ      |L1.8500|
00211e  290c              CMP      r1,#0xc
002120  d10d              BNE      |L1.8510|
002122  e00a              B        |L1.8506|
                  |L1.8484|
002124  2002              MOVS     r0,#2                 ;4170
;;;4173     {
;;;4174       case TIM_CHANNEL_1:
;;;4175       {
;;;4176         /* Check the parameters */
;;;4177         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4178         
;;;4179         /* Return the capture 1 value */
;;;4180         tmpreg = htim->Instance->CCR1;
;;;4181         
;;;4182         break;
;;;4183       }
;;;4184       case TIM_CHANNEL_2:
;;;4185       {
;;;4186         /* Check the parameters */
;;;4187         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4188         
;;;4189         /* Return the capture 2 value */
;;;4190         tmpreg = htim->Instance->CCR2;
;;;4191         
;;;4192         break;
;;;4193       }
;;;4194       
;;;4195       case TIM_CHANNEL_3:
;;;4196       {
;;;4197         /* Check the parameters */
;;;4198         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;4199         
;;;4200         /* Return the capture 3 value */
;;;4201         tmpreg = htim->Instance->CCR3;
;;;4202         
;;;4203         break;
;;;4204       }
;;;4205       
;;;4206       case TIM_CHANNEL_4:
;;;4207       {
;;;4208         /* Check the parameters */
;;;4209         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;4210         
;;;4211         /* Return the capture 4 value */
;;;4212         tmpreg = htim->Instance->CCR4;
;;;4213         
;;;4214         break;
;;;4215       }
;;;4216       
;;;4217       default:
;;;4218       break;  
;;;4219     }
;;;4220        
;;;4221     __HAL_UNLOCK(htim);  
;;;4222     return tmpreg;
;;;4223   }
002126  4770              BX       lr
                  |L1.8488|
002128  6801              LDR      r1,[r0,#0]            ;4180
00212a  6b4a              LDR      r2,[r1,#0x34]         ;4180
00212c  e007              B        |L1.8510|
                  |L1.8494|
00212e  6801              LDR      r1,[r0,#0]            ;4190
002130  6b8a              LDR      r2,[r1,#0x38]         ;4190
002132  e004              B        |L1.8510|
                  |L1.8500|
002134  6801              LDR      r1,[r0,#0]            ;4201
002136  6bca              LDR      r2,[r1,#0x3c]         ;4201
002138  e001              B        |L1.8510|
                  |L1.8506|
00213a  6801              LDR      r1,[r0,#0]            ;4212
00213c  6c0a              LDR      r2,[r1,#0x40]         ;4212
                  |L1.8510|
00213e  2100              MOVS     r1,#0                 ;4221
002140  f8801038          STRB     r1,[r0,#0x38]         ;4221
002144  4610              MOV      r0,r2                 ;4222
002146  4770              BX       lr
;;;4224   /**
                          ENDP

                  HAL_TIM_Base_GetState PROC
;;;4347     */
;;;4348   HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
002148  f8900039          LDRB     r0,[r0,#0x39]
;;;4349   {
;;;4350     return htim->State;
;;;4351   }
00214c  4770              BX       lr
;;;4352   
                          ENDP

                  HAL_TIM_OC_GetState PROC
;;;4358     */
;;;4359   HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
00214e  f8900039          LDRB     r0,[r0,#0x39]
;;;4360   {
;;;4361     return htim->State;
;;;4362   }
002152  4770              BX       lr
;;;4363   
                          ENDP

                  HAL_TIM_PWM_GetState PROC
;;;4369     */
;;;4370   HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
002154  f8900039          LDRB     r0,[r0,#0x39]
;;;4371   {
;;;4372     return htim->State;
;;;4373   }
002158  4770              BX       lr
;;;4374   
                          ENDP

                  HAL_TIM_IC_GetState PROC
;;;4380     */
;;;4381   HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
00215a  f8900039          LDRB     r0,[r0,#0x39]
;;;4382   {
;;;4383     return htim->State;
;;;4384   }
00215e  4770              BX       lr
;;;4385   
                          ENDP

                  HAL_TIM_OnePulse_GetState PROC
;;;4391     */
;;;4392   HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
002160  f8900039          LDRB     r0,[r0,#0x39]
;;;4393   {
;;;4394     return htim->State;
;;;4395   }
002164  4770              BX       lr
;;;4396   
                          ENDP

                  HAL_TIM_Encoder_GetState PROC
;;;4402     */
;;;4403   HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
002166  f8900039          LDRB     r0,[r0,#0x39]
;;;4404   {
;;;4405     return htim->State;
;;;4406   }
00216a  4770              BX       lr
;;;4407   /**
                          ENDP


                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001

;*** Start embedded assembler ***

#line 1 "drivers\\src\\stm32f4xx_hal_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_tim_c_a9d95b52___Z7__REV16j|
#line 138 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.3.0\\CMSIS\\Include\\core_cmInstr.h"
|__asm___19_stm32f4xx_hal_tim_c_a9d95b52___Z7__REV16j| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_tim_c_a9d95b52___Z7__REVSHi|
#line 153
|__asm___19_stm32f4xx_hal_tim_c_a9d95b52___Z7__REVSHi| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_tim_c_a9d95b52___Z5__RRXj|
#line 328
|__asm___19_stm32f4xx_hal_tim_c_a9d95b52___Z5__RRXj| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
