; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--cpp --list --debug -c --asm --interleave -o.\objects\stm32f4xx_hal_flash_ex.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_hal_flash_ex.d --cpu=Cortex-M4.fp --apcs=interwork -O1 -Otime --diag_suppress=9931 -I.\device\GUI\inc -I.\device\hardware\inc -I.\device\init\inc -I.\misc\inc -I.\user\inc -I..\tester_1.03 -I.\memory\inc -I.\drivers\inc -IE:\KeilProj\tester_1.03\tester_1.03\tester_1.03\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.4.0 -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.4.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=514 -D_RTE_ -DSTM32F417xx -DSTM32F417xx -DColorDepthBpp16 -Dtftili9486 -DSOFTWARE_GL -DGUI_ALLIGN_LAYSIZE_TO_POW2 --omf_browse=.\objects\stm32f4xx_hal_flash_ex.crf drivers\src\stm32f4xx_hal_flash_ex.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  FLASH_Erase_Sector PROC
;;;981      */
;;;982    void FLASH_Erase_Sector(uint32_t Sector, uint8_t VoltageRange)
000000  2200              MOVS     r2,#0
;;;983    {
;;;984      uint32_t tmp_psize = 0;
;;;985    
;;;986      /* Check the parameters */
;;;987      assert_param(IS_FLASH_SECTOR(Sector));
;;;988      assert_param(IS_VOLTAGERANGE(VoltageRange));
;;;989      
;;;990      if(VoltageRange == FLASH_VOLTAGE_RANGE_1)
000002  2900              CMP      r1,#0
000004  d005              BEQ      |L1.18|
;;;991      {
;;;992         tmp_psize = FLASH_PSIZE_BYTE;
;;;993      }
;;;994      else if(VoltageRange == FLASH_VOLTAGE_RANGE_2)
000006  2901              CMP      r1,#1
000008  d01f              BEQ      |L1.74|
;;;995      {
;;;996        tmp_psize = FLASH_PSIZE_HALF_WORD;
;;;997      }
;;;998      else if(VoltageRange == FLASH_VOLTAGE_RANGE_3)
00000a  2902              CMP      r1,#2
00000c  d020              BEQ      |L1.80|
;;;999      {
;;;1000       tmp_psize = FLASH_PSIZE_WORD;
;;;1001     }
;;;1002     else
;;;1003     {
;;;1004       tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
00000e  f44f7240          MOV      r2,#0x300
                  |L1.18|
;;;1005     }
;;;1006   
;;;1007     /* If the previous operation is completed, proceed to erase the sector */
;;;1008     FLASH->CR &= CR_PSIZE_MASK;
000012  49ac              LDR      r1,|L1.708|
000014  680b              LDR      r3,[r1,#0]
000016  f4237340          BIC      r3,r3,#0x300
00001a  600b              STR      r3,[r1,#0]
;;;1009     FLASH->CR |= tmp_psize;
00001c  680b              LDR      r3,[r1,#0]
00001e  431a              ORRS     r2,r2,r3
000020  600a              STR      r2,[r1,#0]
;;;1010     FLASH->CR &= SECTOR_MASK;
000022  680a              LDR      r2,[r1,#0]
000024  f02202f8          BIC      r2,r2,#0xf8
000028  600a              STR      r2,[r1,#0]
;;;1011     FLASH->CR |= FLASH_CR_SER | (Sector << POSITION_VAL(FLASH_CR_SNB));
00002a  680a              LDR      r2,[r1,#0]
00002c  23f8              MOVS     r3,#0xf8
00002e  fa93f3a3          RBIT     r3,r3
000032  fab3f383          CLZ      r3,r3
000036  4098              LSLS     r0,r0,r3
000038  f0400002          ORR      r0,r0,#2
00003c  4310              ORRS     r0,r0,r2
00003e  6008              STR      r0,[r1,#0]
;;;1012     FLASH->CR |= FLASH_CR_STRT;
000040  6808              LDR      r0,[r1,#0]
000042  f4403080          ORR      r0,r0,#0x10000
000046  6008              STR      r0,[r1,#0]
;;;1013   }
000048  4770              BX       lr
                  |L1.74|
00004a  f44f7280          MOV      r2,#0x100             ;996
00004e  e7e0              B        |L1.18|
                  |L1.80|
000050  f44f7200          MOV      r2,#0x200             ;1000
000054  e7dd              B        |L1.18|
;;;1014   
                          ENDP

                  _Z15FLASH_MassErasehj PROC ; FLASH_MassErase(unsigned char, unsigned)
;;;949      */
;;;950    static void FLASH_MassErase(uint8_t VoltageRange, uint32_t Banks)
000056  489b              LDR      r0,|L1.708|
;;;951    {
;;;952      uint32_t tmp_psize = 0;
;;;953      
;;;954      /* Check the parameters */
;;;955      assert_param(IS_VOLTAGERANGE(VoltageRange));
;;;956      assert_param(IS_FLASH_BANK(Banks));
;;;957    
;;;958      /* If the previous operation is completed, proceed to erase all sectors */
;;;959       FLASH->CR &= CR_PSIZE_MASK;
000058  6801              LDR      r1,[r0,#0]
00005a  f4217140          BIC      r1,r1,#0x300
00005e  6001              STR      r1,[r0,#0]
;;;960       FLASH->CR |= tmp_psize;
000060  6801              LDR      r1,[r0,#0]
000062  6001              STR      r1,[r0,#0]
;;;961       FLASH->CR |= FLASH_CR_MER;
000064  6801              LDR      r1,[r0,#0]
000066  f0410104          ORR      r1,r1,#4
00006a  6001              STR      r1,[r0,#0]
;;;962       FLASH->CR |= FLASH_CR_STRT;
00006c  6801              LDR      r1,[r0,#0]
00006e  f4413180          ORR      r1,r1,#0x10000
000072  6001              STR      r1,[r0,#0]
;;;963    }
000074  4770              BX       lr
;;;964    
                          ENDP

                  HAL_FLASHEx_Erase PROC
;;;176      */
;;;177    HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)
000076  e92d41f0          PUSH     {r4-r8,lr}
;;;178    {
00007a  4604              MOV      r4,r0
00007c  460f              MOV      r7,r1
;;;179      HAL_StatusTypeDef status = HAL_ERROR;
;;;180      uint32_t index = 0;
;;;181      
;;;182      /* Process Locked */
;;;183      __HAL_LOCK(&pFlash);
00007e  f8df8248          LDR      r8,|L1.712|
000082  f8980018          LDRB     r0,[r8,#0x18]  ; pFlash
000086  2801              CMP      r0,#1
000088  d008              BEQ      |L1.156|
00008a  2001              MOVS     r0,#1
00008c  f8880018          STRB     r0,[r8,#0x18]
;;;184    
;;;185      /* Check the parameters */
;;;186      assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
;;;187    
;;;188      /* Wait for last operation to be completed */
;;;189      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000090  f24c3050          MOV      r0,#0xc350
000094  f7fffffe          BL       FLASH_WaitForLastOperation
000098  b118              CBZ      r0,|L1.162|
00009a  e034              B        |L1.262|
                  |L1.156|
00009c  2002              MOVS     r0,#2                 ;183
;;;190    
;;;191      if(status == HAL_OK)
;;;192      {
;;;193        /*Initialization of SectorError variable*/
;;;194        *SectorError = 0xFFFFFFFF;
;;;195        
;;;196        if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
;;;197        {
;;;198          /*Mass erase to be done*/
;;;199          FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);
;;;200    
;;;201          /* Wait for last operation to be completed */
;;;202          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
;;;203          
;;;204          /* if the erase operation is completed, disable the MER Bit */
;;;205          FLASH->CR &= (~FLASH_MER_BIT);
;;;206        }
;;;207        else
;;;208        {
;;;209          /* Check the parameters */
;;;210          assert_param(IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector));
;;;211    
;;;212          /* Erase by sector by sector to be done*/
;;;213          for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
;;;214          {
;;;215            FLASH_Erase_Sector(index, (uint8_t) pEraseInit->VoltageRange);
;;;216    
;;;217            /* Wait for last operation to be completed */
;;;218            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
;;;219            
;;;220            /* If the erase operation is completed, disable the SER Bit */
;;;221            FLASH->CR &= (~FLASH_CR_SER);
;;;222            FLASH->CR &= SECTOR_MASK; 
;;;223    
;;;224            if(status != HAL_OK) 
;;;225            {
;;;226              /* In case of error, stop erase procedure and return the faulty sector*/
;;;227              *SectorError = index;
;;;228              break;
;;;229            }
;;;230          }
;;;231        }
;;;232      }
;;;233    
;;;234      /* Process Unlocked */
;;;235      __HAL_UNLOCK(&pFlash);
;;;236    
;;;237      return status;
;;;238    }
00009e  e8bd81f0          POP      {r4-r8,pc}
                  |L1.162|
0000a2  f04f31ff          MOV      r1,#0xffffffff        ;194
0000a6  6039              STR      r1,[r7,#0]            ;194
0000a8  6821              LDR      r1,[r4,#0]            ;196
0000aa  4e86              LDR      r6,|L1.708|
0000ac  2901              CMP      r1,#1                 ;196
0000ae  d017              BEQ      |L1.224|
0000b0  68a5              LDR      r5,[r4,#8]            ;213
0000b2  68e1              LDR      r1,[r4,#0xc]          ;213
0000b4  4429              ADD      r1,r1,r5              ;213
0000b6  42a9              CMP      r1,r5                 ;213
0000b8  d925              BLS      |L1.262|
                  |L1.186|
0000ba  7c21              LDRB     r1,[r4,#0x10]         ;215
0000bc  4628              MOV      r0,r5                 ;215
0000be  f7fffffe          BL       FLASH_Erase_Sector
0000c2  f24c3050          MOV      r0,#0xc350            ;218
0000c6  f7fffffe          BL       FLASH_WaitForLastOperation
0000ca  6831              LDR      r1,[r6,#0]            ;221
0000cc  f0210102          BIC      r1,r1,#2              ;221
0000d0  6031              STR      r1,[r6,#0]            ;221
0000d2  6831              LDR      r1,[r6,#0]            ;222
0000d4  f02101f8          BIC      r1,r1,#0xf8           ;222
0000d8  6031              STR      r1,[r6,#0]            ;222
0000da  b170              CBZ      r0,|L1.250|
0000dc  603d              STR      r5,[r7,#0]            ;227
0000de  e012              B        |L1.262|
                  |L1.224|
0000e0  7c20              LDRB     r0,[r4,#0x10]         ;199
0000e2  6861              LDR      r1,[r4,#4]            ;199
0000e4  f7fffffe          BL       _Z15FLASH_MassErasehj ; FLASH_MassErase(unsigned char, unsigned)
0000e8  f24c3050          MOV      r0,#0xc350            ;202
0000ec  f7fffffe          BL       FLASH_WaitForLastOperation
0000f0  6831              LDR      r1,[r6,#0]            ;205
0000f2  f0210104          BIC      r1,r1,#4              ;205
0000f6  6031              STR      r1,[r6,#0]            ;205
0000f8  e005              B        |L1.262|
                  |L1.250|
0000fa  1c6d              ADDS     r5,r5,#1              ;213
0000fc  68a2              LDR      r2,[r4,#8]            ;213
0000fe  68e1              LDR      r1,[r4,#0xc]          ;213
000100  4411              ADD      r1,r1,r2              ;213
000102  42a9              CMP      r1,r5                 ;213
000104  d8d9              BHI      |L1.186|
                  |L1.262|
000106  2100              MOVS     r1,#0                 ;235
000108  f8881018          STRB     r1,[r8,#0x18]         ;235
00010c  e8bd81f0          POP      {r4-r8,pc}
;;;239    
                          ENDP

                  HAL_FLASHEx_Erase_IT PROC
;;;246      */
;;;247    HAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit)
000110  b510              PUSH     {r4,lr}
;;;248    {
;;;249      HAL_StatusTypeDef status = HAL_OK;
000112  2400              MOVS     r4,#0
;;;250    
;;;251      /* Process Locked */
;;;252      __HAL_LOCK(&pFlash);
000114  496c              LDR      r1,|L1.712|
000116  7e0a              LDRB     r2,[r1,#0x18]  ; pFlash
000118  2a01              CMP      r2,#1
00011a  d023              BEQ      |L1.356|
00011c  2301              MOVS     r3,#1
00011e  760b              STRB     r3,[r1,#0x18]
;;;253    
;;;254      /* Check the parameters */
;;;255      assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
;;;256    
;;;257      /* Enable End of FLASH Operation interrupt */
;;;258      __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP);
000120  4a68              LDR      r2,|L1.708|
000122  f8d2c000          LDR      r12,[r2,#0]
000126  f04c7c80          ORR      r12,r12,#0x1000000
00012a  f8c2c000          STR      r12,[r2,#0]
;;;259      
;;;260      /* Enable Error source interrupt */
;;;261      __HAL_FLASH_ENABLE_IT(FLASH_IT_ERR);
00012e  f8d2c000          LDR      r12,[r2,#0]
000132  f04c7c00          ORR      r12,r12,#0x2000000
000136  f8c2c000          STR      r12,[r2,#0]
;;;262      
;;;263      /* Clear pending flags (if any) */  
;;;264      __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP    | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |\
00013a  f8dfc190          LDR      r12,|L1.716|
00013e  22f3              MOVS     r2,#0xf3
000140  f8cc2000          STR      r2,[r12,#0]
;;;265                             FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR| FLASH_FLAG_PGSERR);  
;;;266      
;;;267      if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
000144  6802              LDR      r2,[r0,#0]
000146  2a01              CMP      r2,#1
000148  d00e              BEQ      |L1.360|
;;;268      {
;;;269        /*Mass erase to be done*/
;;;270        pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE;
;;;271        pFlash.Bank = pEraseInit->Banks;
;;;272        FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);
;;;273      }
;;;274      else
;;;275      {
;;;276        /* Erase by sector to be done*/
;;;277    
;;;278        /* Check the parameters */
;;;279        assert_param(IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector));
;;;280    
;;;281        pFlash.ProcedureOnGoing = FLASH_PROC_SECTERASE;
00014a  700b              STRB     r3,[r1,#0]
;;;282        pFlash.NbSectorsToErase = pEraseInit->NbSectors;
00014c  68c2              LDR      r2,[r0,#0xc]
00014e  604a              STR      r2,[r1,#4]  ; pFlash
;;;283        pFlash.Sector = pEraseInit->Sector;
000150  6882              LDR      r2,[r0,#8]
000152  60ca              STR      r2,[r1,#0xc]  ; pFlash
;;;284        pFlash.VoltageForErase = (uint8_t)pEraseInit->VoltageRange;
000154  7c02              LDRB     r2,[r0,#0x10]
000156  720a              STRB     r2,[r1,#8]
;;;285    
;;;286        /*Erase 1st sector and wait for IT*/
;;;287        FLASH_Erase_Sector(pEraseInit->Sector, pEraseInit->VoltageRange);
000158  7c01              LDRB     r1,[r0,#0x10]
00015a  6880              LDR      r0,[r0,#8]
00015c  f7fffffe          BL       FLASH_Erase_Sector
                  |L1.352|
;;;288      }
;;;289    
;;;290      return status;
000160  4620              MOV      r0,r4
;;;291    }
000162  bd10              POP      {r4,pc}
                  |L1.356|
000164  2002              MOVS     r0,#2                 ;252
000166  bd10              POP      {r4,pc}
                  |L1.360|
000168  2202              MOVS     r2,#2                 ;270
00016a  700a              STRB     r2,[r1,#0]            ;270
00016c  6842              LDR      r2,[r0,#4]            ;271
00016e  610a              STR      r2,[r1,#0x10]         ;271  ; pFlash
000170  6841              LDR      r1,[r0,#4]            ;272
000172  7c00              LDRB     r0,[r0,#0x10]         ;272
000174  f7fffffe          BL       _Z15FLASH_MassErasehj ; FLASH_MassErase(unsigned char, unsigned)
000178  e7f2              B        |L1.352|
;;;292    
                          ENDP

                  _Z24FLASH_OB_BOR_LevelConfigh PROC ; FLASH_OB_BOR_LevelConfig(unsigned char)
;;;1227     */
;;;1228   static HAL_StatusTypeDef FLASH_OB_BOR_LevelConfig(uint8_t Level)
00017a  4955              LDR      r1,|L1.720|
;;;1229   {
;;;1230     /* Check the parameters */
;;;1231     assert_param(IS_OB_BOR_LEVEL(Level));
;;;1232   
;;;1233     /* Set the BOR Level */
;;;1234     *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);
00017c  780a              LDRB     r2,[r1,#0]
00017e  f022020c          BIC      r2,r2,#0xc
000182  700a              STRB     r2,[r1,#0]
;;;1235     *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= Level;
000184  780a              LDRB     r2,[r1,#0]
000186  4310              ORRS     r0,r0,r2
000188  7008              STRB     r0,[r1,#0]
;;;1236     
;;;1237     return HAL_OK;
00018a  2000              MOVS     r0,#0
;;;1238     
;;;1239   }
00018c  4770              BX       lr
;;;1240   
                          ENDP

                  _Z19FLASH_OB_UserConfighhh PROC ; FLASH_OB_UserConfig(unsigned char, unsigned char, unsigned char)
;;;1191     */
;;;1192   static HAL_StatusTypeDef FLASH_OB_UserConfig(uint8_t Iwdg, uint8_t Stop, uint8_t Stdby)
00018e  b570              PUSH     {r4-r6,lr}
;;;1193   {
000190  4604              MOV      r4,r0
000192  460d              MOV      r5,r1
000194  4616              MOV      r6,r2
;;;1194     uint8_t optiontmp = 0xFF;
;;;1195     HAL_StatusTypeDef status = HAL_OK;
;;;1196   
;;;1197     /* Check the parameters */
;;;1198     assert_param(IS_OB_IWDG_SOURCE(Iwdg));
;;;1199     assert_param(IS_OB_STOP_SOURCE(Stop));
;;;1200     assert_param(IS_OB_STDBY_SOURCE(Stdby));
;;;1201   
;;;1202     /* Wait for last operation to be completed */
;;;1203     status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000196  f24c3050          MOV      r0,#0xc350
00019a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1204     
;;;1205     if(status == HAL_OK)
00019e  2800              CMP      r0,#0
0001a0  d10b              BNE      |L1.442|
;;;1206     {     
;;;1207       /* Mask OPTLOCK, OPTSTRT, BOR_LEV and BFB2 bits */
;;;1208       optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x1F);
0001a2  f8dfc12c          LDR      r12,|L1.720|
0001a6  f89c1000          LDRB     r1,[r12,#0]
0001aa  f001031f          AND      r3,r1,#0x1f
;;;1209   
;;;1210       /* Update User Option Byte */
;;;1211       *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = Iwdg | (uint8_t)(Stdby | (uint8_t)(Stop | ((uint8_t)optiontmp))); 
0001ae  ea450103          ORR      r1,r5,r3
0001b2  4331              ORRS     r1,r1,r6
0001b4  4321              ORRS     r1,r1,r4
0001b6  f88c1000          STRB     r1,[r12,#0]
                  |L1.442|
;;;1212     }
;;;1213     
;;;1214     return status; 
;;;1215   
;;;1216   }
0001ba  bd70              POP      {r4-r6,pc}
;;;1217   
                          ENDP

                  _Z24FLASH_OB_RDP_LevelConfigh PROC ; FLASH_OB_RDP_LevelConfig(unsigned char)
;;;1157     */
;;;1158   static HAL_StatusTypeDef FLASH_OB_RDP_LevelConfig(uint8_t Level)
0001bc  b510              PUSH     {r4,lr}
;;;1159   {
0001be  4604              MOV      r4,r0
;;;1160     HAL_StatusTypeDef status = HAL_OK;
;;;1161     
;;;1162     /* Check the parameters */
;;;1163     assert_param(IS_OB_RDP_LEVEL(Level));
;;;1164       
;;;1165     /* Wait for last operation to be completed */
;;;1166     status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
0001c0  f24c3050          MOV      r0,#0xc350
0001c4  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1167   
;;;1168     if(status == HAL_OK)
0001c8  2800              CMP      r0,#0
0001ca  d101              BNE      |L1.464|
;;;1169     { 
;;;1170       *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = Level;
0001cc  4941              LDR      r1,|L1.724|
0001ce  700c              STRB     r4,[r1,#0]
                  |L1.464|
;;;1171     }
;;;1172     
;;;1173     return status;
;;;1174   }
0001d0  bd10              POP      {r4,pc}
;;;1175   
                          ENDP

                  _Z19FLASH_OB_DisableWRPjj PROC ; FLASH_OB_DisableWRP(unsigned, unsigned)
;;;1067     */
;;;1068   static HAL_StatusTypeDef FLASH_OB_DisableWRP(uint32_t WRPSector, uint32_t Banks)
0001d2  b510              PUSH     {r4,lr}
;;;1069   {
0001d4  4604              MOV      r4,r0
;;;1070     HAL_StatusTypeDef status = HAL_OK;
;;;1071     
;;;1072     /* Check the parameters */
;;;1073     assert_param(IS_OB_WRP_SECTOR(WRPSector));
;;;1074     assert_param(IS_FLASH_BANK(Banks));
;;;1075       
;;;1076     /* Wait for last operation to be completed */
;;;1077     status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
0001d6  f24c3050          MOV      r0,#0xc350
0001da  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1078   
;;;1079     if(status == HAL_OK)
0001de  2800              CMP      r0,#0
0001e0  d103              BNE      |L1.490|
;;;1080     { 
;;;1081       *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)WRPSector; 
0001e2  493d              LDR      r1,|L1.728|
0001e4  880a              LDRH     r2,[r1,#0]
0001e6  4322              ORRS     r2,r2,r4
0001e8  800a              STRH     r2,[r1,#0]
                  |L1.490|
;;;1082     }
;;;1083     
;;;1084     return status;
;;;1085   }
0001ea  bd10              POP      {r4,pc}
;;;1086   #endif /* STM32F40xxx || STM32F41xxx || STM32F401xx || STM32F411xE || STM32F446xx */
                          ENDP

                  _Z18FLASH_OB_EnableWRPjj PROC ; FLASH_OB_EnableWRP(unsigned, unsigned)
;;;1031     */
;;;1032   static HAL_StatusTypeDef FLASH_OB_EnableWRP(uint32_t WRPSector, uint32_t Banks)
0001ec  b510              PUSH     {r4,lr}
;;;1033   {
0001ee  4604              MOV      r4,r0
;;;1034     HAL_StatusTypeDef status = HAL_OK;
;;;1035     
;;;1036     /* Check the parameters */
;;;1037     assert_param(IS_OB_WRP_SECTOR(WRPSector));
;;;1038     assert_param(IS_FLASH_BANK(Banks));
;;;1039       
;;;1040     /* Wait for last operation to be completed */
;;;1041     status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
0001f0  f24c3050          MOV      r0,#0xc350
0001f4  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1042   
;;;1043     if(status == HAL_OK)
0001f8  2800              CMP      r0,#0
0001fa  d103              BNE      |L1.516|
;;;1044     { 
;;;1045       *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~WRPSector);  
0001fc  4936              LDR      r1,|L1.728|
0001fe  880a              LDRH     r2,[r1,#0]
000200  43a2              BICS     r2,r2,r4
000202  800a              STRH     r2,[r1,#0]
                  |L1.516|
;;;1046     }
;;;1047     
;;;1048     return status;
;;;1049   }
000204  bd10              POP      {r4,pc}
;;;1050   
                          ENDP

                  HAL_FLASHEx_OBProgram PROC
;;;299      */
;;;300    HAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)
000206  b570              PUSH     {r4-r6,lr}
;;;301    {
000208  4604              MOV      r4,r0
;;;302      HAL_StatusTypeDef status = HAL_ERROR;
00020a  2001              MOVS     r0,#1
;;;303      
;;;304      /* Process Locked */
;;;305      __HAL_LOCK(&pFlash);
00020c  4d2e              LDR      r5,|L1.712|
00020e  7e29              LDRB     r1,[r5,#0x18]  ; pFlash
000210  2901              CMP      r1,#1
000212  d02a              BEQ      |L1.618|
000214  2101              MOVS     r1,#1
000216  7629              STRB     r1,[r5,#0x18]
;;;306    
;;;307      /* Check the parameters */
;;;308      assert_param(IS_OPTIONBYTE(pOBInit->OptionType));
;;;309    
;;;310      /*Write protection configuration*/
;;;311      if((pOBInit->OptionType & OPTIONBYTE_WRP) == OPTIONBYTE_WRP)
000218  7821              LDRB     r1,[r4,#0]
00021a  f0110f01          TST      r1,#1
00021e  d006              BEQ      |L1.558|
;;;312      {
;;;313        assert_param(IS_WRPSTATE(pOBInit->WRPState));
;;;314        if(pOBInit->WRPState == OB_WRPSTATE_ENABLE)
000220  6860              LDR      r0,[r4,#4]
000222  2801              CMP      r0,#1
000224  d023              BEQ      |L1.622|
;;;315        {
;;;316          /*Enable of Write protection on the selected Sector*/
;;;317          status = FLASH_OB_EnableWRP(pOBInit->WRPSector, pOBInit->Banks);
;;;318        }
;;;319        else
;;;320        {
;;;321          /*Disable of Write protection on the selected Sector*/
;;;322          status = FLASH_OB_DisableWRP(pOBInit->WRPSector, pOBInit->Banks);
000226  68e1              LDR      r1,[r4,#0xc]
000228  68a0              LDR      r0,[r4,#8]
00022a  f7fffffe          BL       _Z19FLASH_OB_DisableWRPjj ; FLASH_OB_DisableWRP(unsigned, unsigned)
                  |L1.558|
;;;323        }
;;;324      }
;;;325    
;;;326      /*Read protection configuration*/
;;;327      if((pOBInit->OptionType & OPTIONBYTE_RDP) == OPTIONBYTE_RDP)
00022e  7821              LDRB     r1,[r4,#0]
000230  f0110f02          TST      r1,#2
000234  d002              BEQ      |L1.572|
;;;328      {
;;;329        status = FLASH_OB_RDP_LevelConfig(pOBInit->RDPLevel);
000236  7c20              LDRB     r0,[r4,#0x10]
000238  f7fffffe          BL       _Z24FLASH_OB_RDP_LevelConfigh ; FLASH_OB_RDP_LevelConfig(unsigned char)
                  |L1.572|
;;;330      }
;;;331    
;;;332      /*USER  configuration*/
;;;333      if((pOBInit->OptionType & OPTIONBYTE_USER) == OPTIONBYTE_USER)
00023c  7821              LDRB     r1,[r4,#0]
00023e  f0110f04          TST      r1,#4
000242  d008              BEQ      |L1.598|
;;;334      {
;;;335        status = FLASH_OB_UserConfig(pOBInit->USERConfig&OB_IWDG_SW, 
000244  7e20              LDRB     r0,[r4,#0x18]
000246  f0000280          AND      r2,r0,#0x80
00024a  f0000140          AND      r1,r0,#0x40
00024e  f0000020          AND      r0,r0,#0x20
000252  f7fffffe          BL       _Z19FLASH_OB_UserConfighhh ; FLASH_OB_UserConfig(unsigned char, unsigned char, unsigned char)
                  |L1.598|
;;;336                                         pOBInit->USERConfig&OB_STOP_NO_RST,
;;;337                                         pOBInit->USERConfig&OB_STDBY_NO_RST);
;;;338      }
;;;339    
;;;340      /*BOR Level  configuration*/
;;;341      if((pOBInit->OptionType & OPTIONBYTE_BOR) == OPTIONBYTE_BOR)
000256  7821              LDRB     r1,[r4,#0]
000258  f0110f08          TST      r1,#8
00025c  d002              BEQ      |L1.612|
;;;342      {
;;;343        status = FLASH_OB_BOR_LevelConfig(pOBInit->BORLevel);
00025e  7d20              LDRB     r0,[r4,#0x14]
000260  f7fffffe          BL       _Z24FLASH_OB_BOR_LevelConfigh ; FLASH_OB_BOR_LevelConfig(unsigned char)
                  |L1.612|
;;;344      }
;;;345    
;;;346      /* Process Unlocked */
;;;347      __HAL_UNLOCK(&pFlash);
000264  2100              MOVS     r1,#0
000266  7629              STRB     r1,[r5,#0x18]
;;;348    
;;;349      return status;
;;;350    }
000268  bd70              POP      {r4-r6,pc}
                  |L1.618|
00026a  2002              MOVS     r0,#2                 ;305
00026c  bd70              POP      {r4-r6,pc}
                  |L1.622|
00026e  68e1              LDR      r1,[r4,#0xc]          ;317
000270  68a0              LDR      r0,[r4,#8]            ;317
000272  f7fffffe          BL       _Z18FLASH_OB_EnableWRPjj ; FLASH_OB_EnableWRP(unsigned, unsigned)
000276  e7da              B        |L1.558|
;;;351    
                          ENDP

                  _Z15FLASH_OB_GetBORv PROC ; FLASH_OB_GetBOR()
;;;1287     */
;;;1288   static uint8_t FLASH_OB_GetBOR(void)
000278  4815              LDR      r0,|L1.720|
;;;1289   {
;;;1290     /* Return the FLASH BOR level */
;;;1291     return (uint8_t)(*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0C);
00027a  7800              LDRB     r0,[r0,#0]
00027c  f000000c          AND      r0,r0,#0xc
;;;1292   }
000280  4770              BX       lr
;;;1293   
                          ENDP

                  _Z16FLASH_OB_GetUserv PROC ; FLASH_OB_GetUser()
;;;1245     */
;;;1246   static uint8_t FLASH_OB_GetUser(void)
000282  4813              LDR      r0,|L1.720|
;;;1247   {
;;;1248     /* Return the User Option Byte */
;;;1249     return ((uint8_t)(FLASH->OPTCR & 0xE0));
000284  6800              LDR      r0,[r0,#0]
000286  f00000e0          AND      r0,r0,#0xe0
;;;1250   }
00028a  4770              BX       lr
;;;1251   
                          ENDP

                  _Z15FLASH_OB_GetRDPv PROC ; FLASH_OB_GetRDP()
;;;1267     */
;;;1268   static FlagStatus FLASH_OB_GetRDP(void)
00028c  2000              MOVS     r0,#0
;;;1269   {
;;;1270     FlagStatus readstatus = RESET;
;;;1271   
;;;1272     if((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) != (uint8_t)OB_RDP_LEVEL_0))
00028e  4911              LDR      r1,|L1.724|
000290  7809              LDRB     r1,[r1,#0]
000292  29aa              CMP      r1,#0xaa
000294  d000              BEQ      |L1.664|
;;;1273     {
;;;1274       readstatus = SET;
000296  2001              MOVS     r0,#1
                  |L1.664|
;;;1275     }
;;;1276     
;;;1277     return readstatus;
;;;1278   }
000298  4770              BX       lr
;;;1279   
                          ENDP

                  _Z15FLASH_OB_GetWRPv PROC ; FLASH_OB_GetWRP()
;;;1255     */
;;;1256   static uint16_t FLASH_OB_GetWRP(void)
00029a  480f              LDR      r0,|L1.728|
;;;1257   {
;;;1258     /* Return the FLASH write protection Register value */
;;;1259     return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
00029c  8800              LDRH     r0,[r0,#0]
;;;1260   }
00029e  4770              BX       lr
;;;1261   
                          ENDP

                  HAL_FLASHEx_OBGetConfig PROC
;;;358      */
;;;359    void HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)
0002a0  b510              PUSH     {r4,lr}
;;;360    {
0002a2  4604              MOV      r4,r0
;;;361      pOBInit->OptionType = OPTIONBYTE_WRP | OPTIONBYTE_RDP | OPTIONBYTE_USER | OPTIONBYTE_BOR;
0002a4  200f              MOVS     r0,#0xf
0002a6  6020              STR      r0,[r4,#0]
;;;362    
;;;363      /*Get WRP*/
;;;364      pOBInit->WRPSector = FLASH_OB_GetWRP();
0002a8  f7fffffe          BL       _Z15FLASH_OB_GetWRPv ; FLASH_OB_GetWRP()
0002ac  60a0              STR      r0,[r4,#8]
;;;365    
;;;366      /*Get RDP Level*/
;;;367      pOBInit->RDPLevel = FLASH_OB_GetRDP();
0002ae  f7fffffe          BL       _Z15FLASH_OB_GetRDPv ; FLASH_OB_GetRDP()
0002b2  6120              STR      r0,[r4,#0x10]
;;;368    
;;;369      /*Get USER*/
;;;370      pOBInit->USERConfig = FLASH_OB_GetUser();
0002b4  f7fffffe          BL       _Z16FLASH_OB_GetUserv ; FLASH_OB_GetUser()
0002b8  7620              STRB     r0,[r4,#0x18]
;;;371    
;;;372      /*Get BOR Level*/
;;;373      pOBInit->BORLevel = FLASH_OB_GetBOR();
0002ba  f7fffffe          BL       _Z15FLASH_OB_GetBORv ; FLASH_OB_GetBOR()
0002be  6160              STR      r0,[r4,#0x14]
;;;374    }
0002c0  bd10              POP      {r4,pc}
;;;375    
                          ENDP

0002c2  0000              DCW      0x0000
                  |L1.708|
                          DCD      0x40023c10
                  |L1.712|
                          DCD      pFlash
                  |L1.716|
                          DCD      0x40023c0c
                  |L1.720|
                          DCD      0x40023c14
                  |L1.724|
                          DCD      0x40023c15
                  |L1.728|
                          DCD      0x40023c16

                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001

;*** Start embedded assembler ***

#line 1 "drivers\\src\\stm32f4xx_hal_flash_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___24_stm32f4xx_hal_flash_ex_c_6648b60e___Z7__REV16j|
#line 138 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.3.0\\CMSIS\\Include\\core_cmInstr.h"
|__asm___24_stm32f4xx_hal_flash_ex_c_6648b60e___Z7__REV16j| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___24_stm32f4xx_hal_flash_ex_c_6648b60e___Z7__REVSHi|
#line 153
|__asm___24_stm32f4xx_hal_flash_ex_c_6648b60e___Z7__REVSHi| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___24_stm32f4xx_hal_flash_ex_c_6648b60e___Z5__RRXj|
#line 328
|__asm___24_stm32f4xx_hal_flash_ex_c_6648b60e___Z5__RRXj| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
